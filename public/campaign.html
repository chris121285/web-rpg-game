<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Campaign - RPG Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, sans-serif;
            background: radial-gradient(ellipse at top, #1a1f3a 0%, #0d0f1a 100%);
            color: #e0e6ff;
            min-height: 100vh;
            padding: 20px;
        }

        body::before {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background:
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(99, 102, 241, 0.15) 0%, transparent 50%);
            animation: gradientShift 15s ease infinite;
            pointer-events: none;
        }

        @keyframes gradientShift {
            0%, 100% { transform: translate(0, 0); }
            50% { transform: translate(50px, 50px); }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 10;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
        }

        .back-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #e0e6ff;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(127, 156, 255, 0.5);
            transform: translateX(-2px);
        }

        .campaign-title {
            font-size: 32px;
            font-weight: 700;
            background: linear-gradient(135deg, #818cf8 0%, #a78bfa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .role-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .role-badge.dm {
            background: linear-gradient(135deg, #f59e0b 0%, #ef4444 100%);
            color: white;
        }

        .role-badge.player {
            background: linear-gradient(135deg, #10b981 0%, #3b82f6 100%);
            color: white;
        }

        /* Tabs for DM */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 10px;
        }

        .tab-btn {
            flex: 1;
            padding: 15px 25px;
            background: transparent;
            border: 2px solid transparent;
            border-radius: 12px;
            color: #a5b4fc;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tab-btn:hover {
            background: rgba(129, 140, 248, 0.1);
            color: #e0e6ff;
        }

        .tab-btn.active {
            background: linear-gradient(135deg, rgba(129, 140, 248, 0.2), rgba(167, 139, 250, 0.2));
            border-color: rgba(129, 140, 248, 0.5);
            color: #fff;
        }

        .content {
            display: none;
        }

        .content.active {
            display: block;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .section {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 24px;
            font-weight: 700;
            color: #c7d2fe;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(99, 102, 241, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .quest-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 18px;
        }

        .quest-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(129, 140, 248, 0.35);
            border-radius: 16px;
            padding: 18px;
            transition: border 0.3s ease, transform 0.3s ease;
        }

        .quest-card:hover {
            border-color: rgba(129, 140, 248, 0.7);
            transform: translateY(-2px);
        }

        .quest-card.expanded {
            border-color: rgba(129, 140, 248, 0.7);
        }

        .quest-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
            cursor: pointer;
        }

        .quest-title {
            font-size: 18px;
            font-weight: 600;
            color: #e0e6ff;
        }

        .quest-meta {
            font-size: 12px;
            color: rgba(224, 230, 255, 0.65);
            margin-top: 4px;
        }

        .quest-turnin-tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: #fef3c7;
            background: rgba(251, 191, 36, 0.15);
            border: 1px solid rgba(251, 191, 36, 0.4);
            border-radius: 999px;
            padding: 2px 10px;
            margin-top: 6px;
        }

        .quest-status {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(129, 140, 248, 0.15);
            color: #c7d2fe;
            white-space: nowrap;
        }

        .quest-status.completed {
            background: rgba(16, 185, 129, 0.2);
            color: #bbf7d0;
            border: 1px solid rgba(16, 185, 129, 0.4);
        }

        .quest-card-body {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.35s ease, margin-top 0.35s ease;
        }

        .quest-card.expanded .quest-card-body {
            margin-top: 14px;
            max-height: 600px;
        }

        .quest-description {
            font-size: 14px;
            color: rgba(224, 230, 255, 0.85);
            line-height: 1.5;
            white-space: pre-wrap;
        }

        .quest-rewards {
            margin-top: 16px;
            padding: 14px;
            border-radius: 12px;
            background: rgba(129, 140, 248, 0.08);
            border: 1px solid rgba(129, 140, 248, 0.2);
        }

        .quest-rewards-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: rgba(199, 210, 254, 0.9);
            margin-bottom: 6px;
        }

        .quest-rewards-text {
            font-size: 14px;
            color: #e0e6ff;
            white-space: pre-wrap;
        }

        .quest-empty-state {
            text-align: center;
            padding: 18px;
            border: 1px dashed rgba(129, 140, 248, 0.35);
            border-radius: 12px;
            color: rgba(224, 230, 255, 0.7);
        }

        .quest-expand-indicator {
            font-size: 18px;
            color: #a5b4fc;
            margin-left: 8px;
        }

        .quest-actions {
            display: flex;
            gap: 10px;
            margin-top: 14px;
        }

        .quest-actions button {
            flex: 1;
            padding: 8px 10px;
            border: none;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }

        .quest-actions .complete-btn {
            background: linear-gradient(120deg, #34d399, #059669);
            color: #04140b;
        }

        .quest-actions .abandon-btn {
            background: linear-gradient(120deg, #f87171, #dc2626);
            color: #fff;
        }

        .dice-log {
            background: rgba(15, 17, 34, 0.6);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 12px;
            padding: 18px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 320px;
            overflow-y: auto;
        }

        .dice-log-entry {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(129, 140, 248, 0.25);
            border-radius: 10px;
            padding: 10px 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            color: #e0e6ff;
        }

        .dice-log-entry .roll-meta {
            font-size: 12px;
            color: rgba(224, 230, 255, 0.7);
        }

        .quest-popup-overlay {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at center, rgba(15,9,2,0.85), rgba(3,2,1,0.92));
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 999;
        }

        .quest-popup-overlay.active {
            display: flex;
        }

        .quest-scroll-wrap {
            position: relative;
            padding: 30px 0;
        }

        .quest-scroll {
            width: min(540px, 92%);
            background: #f8e9c8;
            border: 6px solid #a06a2b;
            border-radius: 26px;
            padding: 36px 38px 32px;
            box-shadow: 0 35px 95px rgba(0, 0, 0, 0.7);
            position: relative;
            font-family: "Cinzel", "EB Garamond", serif;
            color: #2c1605;
            overflow: hidden;
        }

        .quest-scroll::before,
        .quest-scroll::after {
            content: "";
            position: absolute;
            left: 0;
            right: 0;
            height: 32px;
            background: linear-gradient(90deg, rgba(0,0,0,0) 0%, rgba(90,54,14,0.35) 50%, rgba(0,0,0,0) 100%);
        }

        .quest-scroll::before {
            top: -20px;
            transform: skewY(-4deg);
        }

        .quest-scroll::after {
            bottom: -22px;
            transform: skewY(4deg);
        }

        .quest-scroll-roll {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% + 80px);
            height: 28px;
            background: repeating-linear-gradient(
                90deg,
                #c5a062,
                #c5a062 14px,
                #d9b97d 14px,
                #d9b97d 28px
            );
            border-radius: 999px;
            z-index: -1;
        }

        .quest-scroll-roll.top {
            top: -34px;
            box-shadow: 0 6px 8px rgba(0,0,0,0.3);
        }

        .quest-scroll-roll.bottom {
            bottom: -34px;
            box-shadow: 0 -6px 8px rgba(0,0,0,0.3);
        }

        .quest-scroll-title {
            font-size: 38px;
            margin-bottom: 18px;
            text-align: center;
            color: #2a1406;
            text-shadow: 0 3px 0 rgba(255, 247, 214, 0.6);
        }

        .quest-scroll-heading {
            text-align: center;
            font-size: 20px;
            text-transform: uppercase;
            letter-spacing: 8px;
            color: rgba(43, 24, 6, 0.7);
            margin-bottom: 12px;
            font-family: "Cinzel", serif;
        }

        .quest-scroll-body {
            font-size: 20px;
            line-height: 1.75;
            padding: 18px 0;
            border-top: 1px solid rgba(0, 0, 0, 0.12);
            border-bottom: 1px solid rgba(0, 0, 0, 0.12);
            margin-bottom: 18px;
            font-family: "EB Garamond", serif;
            color: #2c1605;
        }

        .quest-scroll-rewards {
            background: rgba(255, 255, 255, 0.7);
            border: 1px dashed rgba(65, 38, 8, 0.3);
            border-radius: 14px;
            padding: 16px;
            font-size: 18px;
            color: #2a1604;
            font-family: "EB Garamond", serif;
            box-shadow: inset 0 0 12px rgba(0,0,0,0.05);
        }

        .quest-scroll-button {
            margin-top: 22px;
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 999px;
            background: linear-gradient(120deg, #d39537, #f1c166);
            color: #331a05;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
        }

        .quest-scroll-button:hover {
            transform: translateY(-2px);
        }

        .quest-scroll-seal {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #e27a5b, #a2311f 70%);
            color: #fbe8d4;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            margin: 20px auto 0;
            box-shadow: inset 0 4px 6px rgba(0,0,0,0.3), 0 6px 12px rgba(0,0,0,0.35);
        }

        /* Buttons */
        .btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #818cf8 0%, #a78bfa 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(129, 140, 248, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Info Grid */
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 12px;
            padding: 20px;
        }

        .info-label {
            font-size: 12px;
            color: #a5b4fc;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .info-value {
            font-size: 20px;
            font-weight: 600;
            color: #e0e6ff;
        }

        /* Players Grid */
        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }

        .player-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .player-card:hover {
            transform: translateY(-2px);
            border-color: rgba(129, 140, 248, 0.5);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        .player-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .player-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid rgba(129, 140, 248, 0.5);
            overflow: hidden;
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .player-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .player-avatar-placeholder {
            font-size: 30px;
        }

        .player-name {
            font-size: 18px;
            font-weight: 600;
            color: #e0e6ff;
        }

        .player-class {
            font-size: 14px;
            color: #a5b4fc;
        }

        .player-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .player-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .player-rest-summary {
            margin-top: 10px;
            font-size: 13px;
            color: #c084fc;
            background: rgba(192, 132, 252, 0.1);
            border-left: 3px solid rgba(192, 132, 252, 0.6);
            padding: 8px 10px;
            border-radius: 6px;
            display: none;
        }

        .player-status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-top: 12px;
            padding: 6px 12px;
            border-radius: 999px;
            background: rgba(245, 158, 11, 0.15);
            border: 1px solid rgba(245, 158, 11, 0.4);
            color: #fbbf24;
            font-size: 13px;
            font-weight: 600;
        }

        .levelup-callout-bar {
            display: none;
            justify-content: center;
            margin-bottom: 20px;
        }

        .levelup-callout {
            padding: 10px 30px;
            border-radius: 999px;
            background: rgba(16, 185, 129, 0.08);
            border: 1px solid rgba(16, 185, 129, 0.4);
            color: #34d399;
            font-weight: 700;
            letter-spacing: 0.5px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            transition: all 0.2s ease;
            text-transform: uppercase;
        }

        .levelup-callout:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 24px rgba(16, 185, 129, 0.25);
        }

        .rage-control {
            display: none;
            flex-direction: column;
            gap: 10px;
            padding: 12px;
            border-radius: 12px;
            border: 1px solid rgba(248, 113, 113, 0.3);
            background: rgba(248, 113, 113, 0.08);
        }

        .rage-control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #fecaca;
            font-weight: 600;
        }

        .rage-control-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .rage-control-actions button {
            flex: 1;
            min-width: 120px;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(248, 113, 113, 0.4);
            background: rgba(248, 113, 113, 0.15);
            color: #fecaca;
            font-weight: 600;
            cursor: pointer;
            transition: border 0.2s ease;
        }

        .rage-control-actions button:hover {
            border-color: rgba(248, 250, 229, 0.7);
        }

        .class-helper-wrapper {
            margin-top: 24px;
            display: none;
        }

        .class-helper-card {
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-left: 4px solid rgba(129, 140, 248, 0.6);
            border-radius: 18px;
            padding: 18px 22px;
            margin-bottom: 16px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
        }

        .class-helper-card.barbarian-helper {
            border-left-color: #f97316;
        }

        .class-helper-card.rogue-helper {
            border-left-color: #facc15;
        }

        .helper-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .helper-title {
            font-size: 18px;
            font-weight: 700;
            color: #e2e8f0;
        }

        .helper-subtitle {
            font-size: 13px;
            color: #94a3b8;
            margin-top: 2px;
        }

        .helper-badge {
            padding: 6px 14px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border: 1px solid rgba(99, 102, 241, 0.4);
            color: #a5b4fc;
        }

        .helper-badge.active {
            background: rgba(248, 113, 113, 0.15);
            color: #fecaca;
            border-color: rgba(248, 113, 113, 0.5);
        }

        .helper-metrics {
            display: flex;
            gap: 18px;
            flex-wrap: wrap;
            margin-top: 16px;
        }

        .helper-metric {
            flex: 1;
            min-width: 150px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 14px;
            padding: 12px 16px;
        }

        .helper-metric-label {
            font-size: 12px;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            margin-bottom: 4px;
        }

        .helper-metric-value {
            font-size: 22px;
            font-weight: 700;
            color: #f8fafc;
        }

        .helper-actions {
            margin-top: 16px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .helper-actions button {
            flex: 1;
            min-width: 140px;
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid rgba(148, 163, 184, 0.3);
            background: rgba(255, 255, 255, 0.04);
            color: #e2e8f0;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .helper-actions button:hover {
            border-color: rgba(129, 140, 248, 0.6);
            color: #c7d2fe;
        }

        .helper-note {
            margin-top: 12px;
            font-size: 13px;
            color: #94a3b8;
        }

        .levelup-modal {
            position: fixed;
            inset: 0;
            background: rgba(6, 11, 25, 0.85);
            backdrop-filter: blur(6px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .levelup-modal.active {
            display: flex;
        }

        .levelup-modal-card {
            width: min(900px, 90vw);
            max-height: 90vh;
            overflow-y: auto;
            padding: 32px;
            border-radius: 20px;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(129, 140, 248, 0.35);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
        }

        .levelup-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .levelup-modal-title {
            font-size: 28px;
            font-weight: 700;
            color: #c7d2fe;
        }

        .levelup-modal-close {
            background: transparent;
            border: none;
            color: #94a3b8;
            font-size: 22px;
            cursor: pointer;
        }

        .levelup-section {
            margin-bottom: 24px;
            padding: 20px;
            border-radius: 16px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            background: rgba(255, 255, 255, 0.02);
        }

        .levelup-section h4 {
            margin-bottom: 12px;
            font-size: 18px;
            color: #c7d2fe;
        }

        .levelup-columns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
        }

        .levelup-column-card {
            padding: 12px 14px;
            border-radius: 12px;
            border: 1px solid rgba(129, 140, 248, 0.3);
            background: rgba(129, 140, 248, 0.08);
        }

        .levelup-column-label {
            font-size: 12px;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .levelup-column-value {
            font-size: 16px;
            font-weight: 600;
            color: #e0e6ff;
        }

        .levelup-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            padding-top: 10px;
        }

        .levelup-toast-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 3000;
            pointer-events: none;
        }

        .levelup-toast {
            min-width: 280px;
            max-width: 90vw;
            padding: 16px 22px;
            border-radius: 18px;
            color: #fff;
            font-weight: 600;
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.35);
            opacity: 0;
            transform: translateY(-10px) scale(0.96);
            transition: opacity 0.35s ease, transform 0.35s ease;
            pointer-events: auto;
        }

        .levelup-toast.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .levelup-toast-info {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            border: 1px solid rgba(139, 92, 246, 0.6);
        }

        .levelup-toast-warning {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: 1px solid rgba(214, 158, 46, 0.8);
        }

        .levelup-toast-success {
            background: linear-gradient(135deg, #10b981, #059669);
            border: 1px solid rgba(16, 185, 129, 0.6);
        }

        .levelup-toast-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .levelup-toast-icon {
            font-size: 22px;
        }

        .stat-item {
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
        }

        .stat-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 700;
            color: #818cf8;
        }

        /* NPCs List */
        .npc-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .npc-card:hover {
            border-color: rgba(129, 140, 248, 0.5);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }

        .npc-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 15px;
        }

        .npc-name {
            font-size: 20px;
            font-weight: 700;
            color: #e0e6ff;
        }

        .npc-type {
            font-size: 14px;
            color: #a5b4fc;
            margin-top: 5px;
        }

        .npc-actions {
            display: flex;
            gap: 10px;
        }

        .npc-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
        }

        .npc-stat {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .npc-stat-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .npc-stat-value {
            font-size: 16px;
            font-weight: 700;
            color: #818cf8;
        }

        /* Combat Section */
        .combat-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .combat-status.active {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.1));
            border: 1px solid rgba(239, 68, 68, 0.5);
        }

        .combat-indicator {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .combat-pulse {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 2s ease-in-out infinite;
        }

        .combat-pulse.active {
            background: #ef4444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        .round-counter {
            font-size: 18px;
            font-weight: 600;
            color: #a5b4fc;
        }

        .combat-live-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .combat-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .live-sync {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .live-sync.small {
            gap: 8px;
        }

        .live-sync-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #94a3b8;
        }

        .live-sync-text {
            font-size: 14px;
            color: #e0e6ff;
        }

        .live-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #34d399;
            box-shadow: 0 0 12px rgba(52, 211, 153, 0.7);
        }

        .live-dot.stale {
            background: #f87171;
            box-shadow: 0 0 12px rgba(248, 113, 113, 0.7);
        }

        .combat-toolbar-actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .combat-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }

        @media (max-width: 1100px) {
            .combat-grid {
                grid-template-columns: 1fr;
            }
        }

        .combat-column {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 16px;
            padding: 20px;
        }

        .combat-column.secondary {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .combat-summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
        }

        .combat-summary-card {
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 12px;
            padding: 16px;
        }

        .summary-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #94a3b8;
            margin-bottom: 6px;
        }

        .summary-value {
            font-size: 26px;
            font-weight: 800;
            color: #e0e6ff;
            line-height: 1.2;
        }

        .summary-subtext {
            font-size: 12px;
            color: #a5b4fc;
            margin-top: 4px;
        }

        .initiative-tracker {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            overflow: hidden;
        }

        .initiative-item {
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .initiative-item:last-child {
            border-bottom: none;
        }

        .initiative-item.current-turn {
            background: linear-gradient(90deg, rgba(129, 140, 248, 0.3), transparent);
            border-left: 4px solid #818cf8;
        }

        .initiative-item.defeated {
            opacity: 0.55;
            background: rgba(15, 23, 42, 0.6);
        }

        .initiative-participant {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }

        .initiative-order {
            font-size: 24px;
            font-weight: 800;
            color: #818cf8;
            width: 40px;
        }

        .participant-info {
            flex: 1;
        }

        .participant-name {
            font-size: 16px;
            font-weight: 600;
            color: #e0e6ff;
        }

        .participant-type {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
        }

        .participant-tag {
            display: inline-block;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-left: 8px;
            color: #cbd5f5;
        }

        .participant-tag.defeated {
            color: #fca5a5;
        }

        .participant-hp {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .hp-bar {
            width: 100px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #059669);
            transition: width 0.3s ease, background 0.3s ease;
        }

        .hp-fill.hp-high {
            background: linear-gradient(90deg, #10b981, #059669);
        }

        .hp-fill.hp-medium {
            background: linear-gradient(90deg, #f59e0b, #d97706);
        }

        .hp-fill.hp-low {
            background: linear-gradient(90deg, #ef4444, #dc2626);
        }

        .hp-fill.hp-critical {
            background: linear-gradient(90deg, #991b1b, #7f1d1d);
            animation: pulse-critical 1s ease-in-out infinite;
        }

        @keyframes pulse-critical {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        @keyframes damage-flash {
            0% { background-color: rgba(239, 68, 68, 0); }
            50% { background-color: rgba(239, 68, 68, 0.4); }
            100% { background-color: rgba(239, 68, 68, 0); }
        }

        @keyframes heal-flash {
            0% { background-color: rgba(16, 185, 129, 0); }
            50% { background-color: rgba(16, 185, 129, 0.4); }
            100% { background-color: rgba(16, 185, 129, 0); }
        }

        .damage-flash {
            animation: damage-flash 0.5s ease-out;
        }

        .heal-flash {
            animation: heal-flash 0.5s ease-out;
        }

        .hp-text {
            font-size: 14px;
            font-weight: 600;
            color: #e0e6ff;
            min-width: 70px;
        }

        .hp-controls {
            display: flex;
            gap: 5px;
        }

        .hp-btn {
            padding: 4px 8px;
            font-size: 11px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e0e6ff;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .hp-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .hp-btn.heal {
            border-color: rgba(16, 185, 129, 0.5);
        }

        .hp-btn.damage {
            border-color: rgba(239, 68, 68, 0.5);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1f3a 0%, #0d0f1a 100%);
            border: 1px solid rgba(129, 140, 248, 0.3);
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: -30px -30px 25px -30px;
            padding: 20px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 20px 20px 0 0;
            border-bottom: 1px solid rgba(129, 140, 248, 0.3);
        }

        .modal-title {
            font-size: 24px;
            font-weight: 700;
            color: #ffffff;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 28px;
            color: #ffffff;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: all 0.3s ease;
            opacity: 0.8;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            opacity: 1;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #c7d2fe;
            margin-bottom: 8px;
        }

        .form-input {
            width: 100%;
            padding: 12px 16px;
            background: #2d3748;
            border: 1px solid rgba(129, 140, 248, 0.3);
            border-radius: 10px;
            color: #ffffff;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .form-input.readonly {
            background: rgba(148, 163, 184, 0.15);
            border-color: rgba(148, 163, 184, 0.4);
            cursor: not-allowed;
        }

        .form-input:focus {
            outline: none;
            border-color: #818cf8;
            background: #374151;
        }

        /* Specific styling for select dropdowns */
        select.form-input {
            background: #2d3748;
            color: #ffffff;
            cursor: pointer;
        }

        select.form-input option {
            background: #2d3748;
            color: #ffffff;
            padding: 8px;
        }

        select.form-input:hover {
            background: #374151;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .form-row-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 25px;
        }

        /* Dice Roller */
        .dice-roller {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 16px;
            padding: 30px;
            text-align: center;
        }

        .dice-container {
            margin: 30px 0;
        }

        .dice {
            width: 100px;
            height: 100px;
            margin: 0 auto;
            background: linear-gradient(135deg, #818cf8, #a78bfa);
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            font-weight: 800;
            color: white;
            box-shadow: 0 8px 32px rgba(129, 140, 248, 0.4);
            transition: all 0.3s ease;
        }

        .dice.rolling {
            animation: diceRoll 0.5s ease-in-out;
        }

        @keyframes diceRoll {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.1); }
            50% { transform: rotate(180deg) scale(1); }
            75% { transform: rotate(270deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .dice-result {
            font-size: 36px;
            font-weight: 800;
            color: #818cf8;
            margin: 20px 0;
        }

        .dice-options {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .dice-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(129, 140, 248, 0.3);
            border-radius: 10px;
            color: #e0e6ff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .dice-btn:hover {
            background: rgba(129, 140, 248, 0.2);
            border-color: #818cf8;
        }

        .dice-btn.active {
            background: #818cf8;
            border-color: #818cf8;
        }

        .roll-history {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(129, 140, 248, 0.2);
        }

        .dice-modal {
            position: fixed;
            inset: 0;
            background: rgba(7, 10, 25, 0.85);
            backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 2000;
        }

        .dice-modal.active {
            display: flex;
        }

        .dice-modal-content {
            width: 100%;
            max-width: 420px;
            background: rgba(13, 16, 40, 0.95);
            border: 1px solid rgba(129, 140, 248, 0.3);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 30px 80px rgba(2, 6, 23, 0.8);
            position: relative;
        }

        .dice-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
        }

        .dice-modal-title {
            font-size: 22px;
            font-weight: 700;
            color: #e0e6ff;
        }

        .dice-modal-subtitle {
            font-size: 14px;
            color: #a5b4fc;
            margin-top: 4px;
        }

        .dice-modal-close {
            background: transparent;
            border: none;
            color: #cbd5f5;
            font-size: 24px;
            cursor: pointer;
        }

        .dice-modal-info {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            text-align: center;
            margin-top: 20px;
        }

        .dice-modal-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #94a3b8;
            margin-bottom: 6px;
        }

        .dice-modal-value {
            font-size: 20px;
            font-weight: 700;
            color: #e0e6ff;
        }

        .critical-effect {
            position: fixed;
            inset: 0;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2200;
            opacity: 0;
            transition: opacity 0.3s ease;
            background: radial-gradient(circle at center, rgba(129, 140, 248, 0.2), transparent 65%);
        }

        .critical-effect.active {
            opacity: 1;
        }

        .critical-icon {
            font-size: 72px;
            margin-bottom: 16px;
            animation: pulseIcon 0.8s ease-in-out infinite;
        }

        .critical-effect.success .critical-icon {
            animation: fireworksBurst 1s ease-in-out infinite;
        }

        .critical-effect.fail .critical-icon {
            animation: bombShake 0.8s ease-in-out infinite;
        }

        .critical-text {
            font-size: 32px;
            font-weight: 800;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: white;
            text-shadow: 0 0 24px rgba(0, 0, 0, 0.6);
        }

        @keyframes pulseIcon {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes fireworksBurst {
            0% { transform: scale(0.8) rotate(0deg); }
            50% { transform: scale(1.2) rotate(15deg); }
            100% { transform: scale(1) rotate(-5deg); }
        }

        @keyframes bombShake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-5px, 2px); }
            50% { transform: translate(4px, -2px); }
            75% { transform: translate(-3px, 4px); }
        }

        .roll-history-title {
            font-size: 14px;
            color: #a5b4fc;
            margin-bottom: 10px;
        }

        .roll-history-item {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            margin-bottom: 5px;
            font-size: 14px;
            color: #e0e6ff;
        }

        /* Combat Alert */
        .combat-alert {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.1));
            border: 2px solid rgba(239, 68, 68, 0.5);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: left;
        }

        .combat-alert-title {
            font-size: 24px;
            font-weight: 700;
            color: #fca5a5;
            margin-bottom: 10px;
        }

        .combat-alert-header {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .player-combat-hud {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin: 20px 0;
        }

        .player-turn-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
        }

        .turn-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #fecaca;
            margin-bottom: 6px;
        }

        .turn-value {
            font-size: 20px;
            font-weight: 700;
            color: #fff;
        }

        .turn-sub {
            font-size: 13px;
            color: #fecdd3;
            margin-top: 4px;
        }

        .initiative-roller {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-top: 15px;
        }

        .your-turn-indicator {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.3), rgba(5, 150, 105, 0.2));
            border: 2px solid rgba(16, 185, 129, 0.5);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: center;
            font-size: 18px;
            font-weight: 700;
            color: #6ee7b7;
        }

        .loading {
            text-align: center;
            padding: 60px;
            font-size: 18px;
            color: #a5b4fc;
        }

        .error-message {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 12px;
            padding: 20px;
            color: #fca5a5;
            text-align: center;
            margin: 20px 0;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #888;
        }

        /* Combat Participant Selection */
        .participant-checkbox-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 10px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .participant-checkbox-item:hover {
            background: rgba(129, 140, 248, 0.1);
            border-color: rgba(129, 140, 248, 0.4);
        }

        .participant-checkbox-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #818cf8;
        }

        .participant-checkbox-label {
            flex: 1;
            cursor: pointer;
            font-size: 15px;
            color: #e0e6ff;
        }

        .participant-checkbox-details {
            font-size: 12px;
            color: #888;
        }

        .hide-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #a5b4fc;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .hide-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .hide-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        /* HP Input Controls */
        .hp-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
        }

        .hp-input-field {
            width: 50px;
            padding: 4px 8px;
            background: transparent;
            border: none;
            color: #e0e6ff;
            font-size: 16px;
            font-weight: 600;
            text-align: center;
        }

        .hp-input-field:focus {
            outline: none;
        }

        .hp-arrow-btn {
            padding: 2px 6px;
            font-size: 16px;
            font-weight: 700;
            background: rgba(129, 140, 248, 0.2);
            border: 1px solid rgba(129, 140, 248, 0.3);
            border-radius: 4px;
            color: #e0e6ff;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .hp-arrow-btn:hover {
            background: rgba(129, 140, 248, 0.4);
        }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background: #1a1f3a;
            border: 1px solid rgba(129, 140, 248, 0.3);
            border-radius: 10px;
            min-width: 200px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 100;
            max-height: 300px;
            overflow-y: auto;
        }

        .dropdown.active .dropdown-content {
            display: block;
        }

        .dropdown-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #e0e6ff;
        }

        .dropdown-item:hover {
            background: rgba(129, 140, 248, 0.2);
        }

        /* Character Sheet for Players */
        .character-sheet {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 16px;
            padding: 30px;
        }

        .character-header {
            display: flex;
            align-items: center;
            gap: 30px;
            margin-bottom: 30px;
            padding-bottom: 30px;
            border-bottom: 2px solid rgba(99, 102, 241, 0.3);
        }

        .character-avatar-large {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 4px solid rgba(129, 140, 248, 0.5);
            overflow: hidden;
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .character-avatar-large img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .character-avatar-large-placeholder {
            font-size: 60px;
        }

        .character-info {
            flex: 1;
        }

        .character-name-display {
            font-size: 36px;
            font-weight: 800;
            background: linear-gradient(135deg, #818cf8 0%, #a78bfa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .character-subtitle {
            font-size: 18px;
            color: #a5b4fc;
            margin-bottom: 5px;
        }

        .character-basics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .basic-stat {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }

        .basic-stat-label {
            font-size: 12px;
            color: #a5b4fc;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .basic-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #818cf8;
        }

        .abilities-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .rollable {
            cursor: pointer;
        }

        .ability-box {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.15), rgba(139, 92, 246, 0.1));
            border: 2px solid rgba(129, 140, 248, 0.3);
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .ability-box:hover {
            transform: translateY(-4px);
            border-color: rgba(129, 140, 248, 0.6);
            box-shadow: 0 8px 24px rgba(129, 140, 248, 0.3);
        }

        .ability-name {
            font-size: 12px;
            color: #a5b4fc;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .ability-score {
            font-size: 36px;
            font-weight: 800;
            color: #818cf8;
            margin-bottom: 5px;
        }

        .ability-modifier {
            font-size: 16px;
            color: #a78bfa;
            font-weight: 600;
        }

        .hp-tracker {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .hp-tracker-title {
            font-size: 16px;
            font-weight: 600;
            color: #c7d2fe;
            margin-bottom: 15px;
        }

        .hp-tracker-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .hp-input {
            flex: 1;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(129, 140, 248, 0.3);
            border-radius: 10px;
            color: #e0e6ff;
            font-size: 18px;
            font-weight: 600;
            text-align: center;
        }

        /* Game UI Styles */
        .game-ui-container {
            background: linear-gradient(135deg, rgba(30, 20, 50, 0.8), rgba(20, 15, 40, 0.9));
            border: 2px solid rgba(129, 140, 248, 0.3);
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .game-health-section {
            margin-bottom: 20px;
        }

        .game-health-label {
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 2px;
            color: #a5b4fc;
            margin-bottom: 10px;
        }

        .game-health-bar-container {
            position: relative;
            margin-bottom: 15px;
        }

        .game-health-bar-bg {
            width: 100%;
            height: 40px;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.7));
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            overflow: hidden;
            position: relative;
        }

        .game-health-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #34d399);
            transition: width 0.5s ease, background 0.3s ease;
            box-shadow: inset 0 2px 8px rgba(255, 255, 255, 0.3),
                        0 0 20px rgba(16, 185, 129, 0.4);
            border-radius: 18px;
        }

        .game-health-bar-fill.low {
            background: linear-gradient(90deg, #f59e0b, #fbbf24);
            box-shadow: inset 0 2px 8px rgba(255, 255, 255, 0.3),
                        0 0 20px rgba(245, 158, 11, 0.4);
        }

        .game-health-bar-fill.critical {
            background: linear-gradient(90deg, #ef4444, #f87171);
            box-shadow: inset 0 2px 8px rgba(255, 255, 255, 0.3),
                        0 0 20px rgba(239, 68, 68, 0.4);
        }

        .game-health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            font-weight: 700;
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        .game-hp-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }

        .game-hp-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid rgba(129, 140, 248, 0.4);
            background: rgba(129, 140, 248, 0.2);
            color: #e0e6ff;
            font-size: 20px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .game-hp-btn:hover {
            background: rgba(129, 140, 248, 0.3);
            border-color: rgba(129, 140, 248, 0.6);
            transform: scale(1.05);
        }

        .game-hp-minus {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.4);
        }

        .game-hp-minus:hover {
            background: rgba(239, 68, 68, 0.3);
            border-color: rgba(239, 68, 68, 0.6);
        }

        .game-hp-plus {
            background: rgba(16, 185, 129, 0.2);
            border-color: rgba(16, 185, 129, 0.4);
        }

        .game-hp-plus:hover {
            background: rgba(16, 185, 129, 0.3);
            border-color: rgba(16, 185, 129, 0.6);
        }

        .game-hp-input {
            width: 80px;
            height: 40px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(129, 140, 248, 0.3);
            border-radius: 8px;
            color: #e0e6ff;
            font-size: 18px;
            font-weight: 700;
            text-align: center;
        }

        .game-hp-save-btn {
            width: 50px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid rgba(16, 185, 129, 0.4);
            background: rgba(16, 185, 129, 0.2);
            color: #6ee7b7;
            font-size: 20px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .game-hp-save-btn:hover {
            background: rgba(16, 185, 129, 0.3);
            border-color: rgba(16, 185, 129, 0.6);
            transform: scale(1.05);
        }

        .game-stats-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            align-items: stretch;
        }

        .game-stat-box {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(129, 140, 248, 0.3);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.3s ease;
        }

        .game-stat-box:hover {
            background: rgba(0, 0, 0, 0.5);
            border-color: rgba(129, 140, 248, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(129, 140, 248, 0.2);
        }

        .game-stat-icon {
            font-size: 32px;
        }

        .game-stat-info {
            flex: 1;
        }

        .game-stat-label {
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 1px;
            color: #94a3b8;
            margin-bottom: 4px;
        }

        .game-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #e0e6ff;
        }

        .game-rest-box {
            background: rgba(59, 130, 246, 0.08);
            border: 1px solid rgba(59, 130, 246, 0.35);
            border-radius: 12px;
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            justify-content: center;
        }

        .game-rest-label {
            font-size: 13px;
            letter-spacing: 1px;
            color: #bfdbfe;
            text-transform: uppercase;
        }

        .game-rest-buttons {
            display: flex;
            gap: 8px;
        }

        .rest-btn-inline {
            flex: 1;
            padding: 8px 10px;
            border: none;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .rest-btn-inline:hover {
            transform: translateY(-1px);
        }

        .rest-btn-short {
            background: linear-gradient(120deg, #60a5fa, #3b82f6);
            color: #021631;
        }

        .rest-btn-long {
            background: linear-gradient(120deg, #34d399, #059669);
            color: #02140b;
        }

        .game-rest-summary {
            font-size: 12px;
            color: #e0f2fe;
            background: rgba(15, 23, 42, 0.45);
            border: 1px solid rgba(96, 165, 250, 0.3);
            border-radius: 8px;
            padding: 8px 10px;
            display: none;
        }

        .death-save-box {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 10px 12px;
            margin-top: 10px;
        }

        .death-save-label {
            font-size: 12px;
            letter-spacing: 0.08em;
            color: #c084fc;
            margin-bottom: 6px;
            text-transform: uppercase;
        }

        .death-save-tracker {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .death-save-dots {
            display: flex;
            gap: 6px;
        }

        .death-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.04);
        }

        .death-dot.success {
            border-color: #22c55e;
            background: #22c55e33;
        }

        .death-dot.fail {
            border-color: #ef4444;
            background: #ef444433;
        }

        .death-save-actions {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .death-save-status {
            font-size: 12px;
            color: #cbd5f5;
        }

        .game-spell-slots-title {
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 2px;
            color: #a5b4fc;
            margin-bottom: 15px;
        }

        #gameSpellSlotsContainer {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .spell-level-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 10px;
        }

        .spell-level-label {
            font-size: 14px;
            font-weight: 600;
            color: #a5b4fc;
            min-width: 80px;
        }

        .spell-slots {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .spell-slot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid rgba(129, 140, 248, 0.4);
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .spell-slot.filled {
            background: linear-gradient(135deg, #818cf8, #6366f1);
            border-color: #a5b4fc;
            box-shadow: 0 0 12px rgba(129, 140, 248, 0.5);
        }

        .spell-slot:hover {
            transform: scale(1.1);
            border-color: #a5b4fc;
        }

        /* Collapsible Sections */
        .collapsible-section {
            margin-bottom: 15px;
        }

        .collapsible-header {
            background: linear-gradient(135deg, rgba(129, 140, 248, 0.2), rgba(99, 102, 241, 0.15));
            border: 2px solid rgba(129, 140, 248, 0.3);
            border-radius: 12px;
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.3s ease;
            user-select: none;
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, rgba(129, 140, 248, 0.3), rgba(99, 102, 241, 0.2));
            border-color: rgba(129, 140, 248, 0.5);
            transform: translateY(-2px);
        }

        .collapsible-title {
            font-size: 18px;
            font-weight: 700;
            color: #c7d2fe;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .collapsible-icon {
            font-size: 24px;
            transition: transform 0.3s ease;
        }

        .collapsible-header.collapsed .collapsible-icon {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.4s ease, opacity 0.3s ease, margin 0.3s ease;
            opacity: 1;
            margin-top: 15px;
        }

        .collapsible-content.collapsed {
            max-height: 0;
            opacity: 0;
            margin-top: 0;
        }

        /* Inventory Styles */
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .inventory-item {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(129, 140, 248, 0.2);
            border-radius: 10px;
            padding: 15px;
            transition: all 0.3s ease;
        }

        .inventory-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(129, 140, 248, 0.4);
            transform: translateY(-2px);
        }

        .inventory-item-name {
            font-size: 16px;
            font-weight: 600;
            color: #e0e6ff;
            margin-bottom: 8px;
        }

        .inventory-item-description {
            font-size: 14px;
            color: #94a3b8;
            line-height: 1.5;
        }

        .inventory-item-quantity {
            font-size: 14px;
            color: #a5b4fc;
            margin-top: 8px;
            font-weight: 600;
        }

        .add-item-btn {
            margin-top: 15px;
            padding: 12px 24px;
            background: rgba(16, 185, 129, 0.2);
            border: 2px solid rgba(16, 185, 129, 0.4);
            border-radius: 10px;
            color: #6ee7b7;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .add-item-btn:hover {
            background: rgba(16, 185, 129, 0.3);
            border-color: rgba(16, 185, 129, 0.6);
            transform: translateY(-2px);
        }

        /* Notes Styles */
        .notes-textarea {
            width: 100%;
            min-height: 200px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(129, 140, 248, 0.3);
            border-radius: 10px;
            padding: 15px;
            color: #e0e6ff;
            font-size: 14px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            resize: vertical;
            margin-top: 15px;
        }

        .notes-textarea:focus {
            outline: none;
            border-color: rgba(129, 140, 248, 0.5);
            background: rgba(0, 0, 0, 0.4);
        }

        .save-notes-btn {
            margin-top: 15px;
            padding: 12px 24px;
            background: rgba(129, 140, 248, 0.2);
            border: 2px solid rgba(129, 140, 248, 0.4);
            border-radius: 10px;
            color: #c7d2fe;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .save-notes-btn:hover {
            background: rgba(129, 140, 248, 0.3);
            border-color: rgba(129, 140, 248, 0.6);
            transform: translateY(-2px);
        }

        .notes-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .note-card {
            border: 1px solid rgba(129, 140, 248, 0.3);
            border-radius: 12px;
            padding: 16px;
            background: rgba(15, 23, 42, 0.6);
            box-shadow: 0 10px 20px rgba(3, 7, 18, 0.4);
            transition: all 0.3s ease;
        }

        .note-card.collapsed textarea,
        .note-card.collapsed .note-card-actions,
        .note-card.collapsed .note-meta {
            display: none;
        }

        .note-card.collapsed {
            cursor: pointer;
        }

        .note-card.collapsed:hover {
            border-color: rgba(251, 191, 36, 0.4);
            background: rgba(15, 23, 42, 0.75);
        }

        .note-title {
            width: 100%;
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid rgba(129, 140, 248, 0.4);
            background: rgba(0, 0, 0, 0.4);
            color: #e0e6ff;
            font-size: 15px;
            margin-bottom: 10px;
        }

        .note-title:focus {
            outline: none;
            border-color: rgba(129, 140, 248, 0.8);
        }

        .note-card textarea {
            min-height: 140px;
        }

        .note-card-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 10px;
        }

        .note-meta {
            font-size: 12px;
            color: #94a3b8;
            margin-top: 6px;
        }

        .note-empty-state {
            text-align: center;
            color: #94a3b8;
            padding: 30px 15px;
            border: 1px dashed rgba(129, 140, 248, 0.3);
            border-radius: 10px;
        }

        .popout-tools {
            margin: 20px 0 10px;
            text-align: right;
        }

        .popout-tools .btn {
            background: rgba(14, 165, 233, 0.2);
            border: 1px solid rgba(14, 165, 233, 0.4);
        }

        .popout-tools .btn:hover {
            background: rgba(14, 165, 233, 0.3);
            border-color: rgba(14, 165, 233, 0.6);
        }

        body.tools-popup {
            padding: 25px;
        }

        body.tools-popup .header,
        body.tools-popup #combatAlertSection,
        body.tools-popup #playerHPSection,
        body.tools-popup .popout-tools,
        body.tools-popup #dmView {
            display: none !important;
        }

        body.tools-popup #playerView {
            margin-top: 0;
        }

        /* Drag and Drop Styles */
        .draggable-section {
            transition: all 0.3s ease;
        }

        .draggable-section.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .draggable-section.drag-over {
            border-top: 3px solid #818cf8;
            padding-top: 5px;
        }

        .drag-handle {
            cursor: grab;
            font-size: 20px;
            color: #94a3b8;
            transition: color 0.3s ease;
            user-select: none;
        }

        .drag-handle:hover {
            color: #c7d2fe;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .collapsible-arrow {
            font-size: 16px;
            color: #94a3b8;
            transition: transform 0.3s ease, color 0.3s ease;
            user-select: none;
        }

        .collapsible-header:hover .collapsible-arrow {
            color: #c7d2fe;
        }

        /* D&D Character Sheet Styles */
        .dnd-sheet {
            color: #e0e6ff;
        }
        .character-sheet-card {
            background: rgba(13, 15, 26, 0.7);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 18px;
            padding: 28px;
            box-shadow: 0 20px 35px rgba(3, 7, 18, 0.6);
        }
        .character-hero {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 18px;
            margin-bottom: 20px;
        }
        .hero-left {
            display: flex;
            align-items: center;
            gap: 18px;
        }
        .hero-avatar {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid rgba(129, 140, 248, 0.5);
            background: rgba(129, 140, 248, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
        }
        .hero-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .hero-name {
            font-size: 30px;
            font-weight: 700;
            color: #f8fafc;
        }
        .hero-subtitle {
            font-size: 16px;
            color: #c7d2fe;
            margin-top: 4px;
        }
        .hero-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        .hero-tag {
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #cbd5f5;
        }
        .hero-level-card {
            min-width: 110px;
            text-align: center;
            padding: 12px 16px;
            border-radius: 12px;
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.25), rgba(217, 70, 239, 0.25));
            border: 1px solid rgba(217, 70, 239, 0.4);
        }
        .hero-level-label {
            font-size: 12px;
            color: #ffe4e6;
            letter-spacing: 1px;
        }
        .hero-level-value {
            font-size: 34px;
            font-weight: 700;
            color: #fda4af;
            line-height: 1.2;
        }
        .quick-stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-bottom: 25px;
        }
        .quick-stat-card {
            padding: 14px 16px;
            border-radius: 14px;
            border: 1px solid rgba(129, 140, 248, 0.2);
            background: rgba(14, 23, 42, 0.7);
        }
        .quick-stat-label {
            font-size: 12px;
            text-transform: uppercase;
            color: #94a3b8;
            letter-spacing: 0.8px;
        }
        .quick-stat-value {
            font-size: 22px;
            font-weight: 700;
            color: #e0e7ff;
            margin-top: 6px;
        }
        .quick-stat-sub {
            font-size: 12px;
            color: #94a3b8;
            margin-top: 4px;
        }
        .sheet-columns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 20px;
        }
        .expertise-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .expertise-badge {
            padding: 6px 12px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 600;
            color: #fef3c7;
            background: rgba(251, 191, 36, 0.15);
            border: 1px solid rgba(251, 191, 36, 0.4);
        }
        .skill-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            margin-left: 6px;
            border-radius: 999px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: rgba(251, 191, 36, 0.15);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }
        .skill-row.expert {
            border-color: rgba(251, 191, 36, 0.6);
            box-shadow: 0 0 12px rgba(251, 191, 36, 0.15);
        }
        .trait-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
            margin-bottom: 15px;
        }
        .trait-card {
            padding: 14px;
            border-radius: 10px;
            border: 1px solid rgba(148, 163, 184, 0.25);
            background: rgba(15, 23, 42, 0.6);
        }
        .trait-label {
            font-size: 12px;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            margin-bottom: 6px;
        }
        .trait-value {
            font-size: 14px;
            color: #e2e8f0;
            line-height: 1.5;
            white-space: pre-wrap;
        }
        .proficiency-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 12px;
            border-radius: 10px;
            border: 1px solid rgba(129, 140, 248, 0.25);
            background: rgba(15, 16, 35, 0.7);
        }
        .proficiency-line {
            font-size: 13px;
            color: #dbeafe;
            line-height: 1.4;
        }

        .stat-section-title {
            font-size: 14px;
            font-weight: 700;
            color: #818cf8;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 25px 0 12px 0;
            padding-bottom: 8px;
            border-bottom: 2px solid rgba(129, 140, 248, 0.3);
        }

        .core-stats-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .core-stat {
            background: rgba(129, 140, 248, 0.1);
            border: 2px solid rgba(129, 140, 248, 0.3);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .core-stat:hover {
            background: rgba(129, 140, 248, 0.15);
            border-color: rgba(129, 140, 248, 0.5);
            transform: translateY(-2px);
        }

        .core-stat-value {
            font-size: 28px;
            font-weight: 700;
            color: #a5b4fc;
            margin-bottom: 5px;
        }

        .core-stat-label {
            font-size: 12px;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Saving Throws */
        .saves-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .save-row {
            display: grid;
            grid-template-columns: 25px 50px 1fr;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .save-row:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(129, 140, 248, 0.4);
        }

        .save-row.proficient {
            background: rgba(129, 140, 248, 0.1);
            border-color: rgba(129, 140, 248, 0.4);
        }

        .save-row.proficient:hover {
            background: rgba(129, 140, 248, 0.15);
        }

        .save-prof {
            font-size: 16px;
            color: #818cf8;
        }

        .save-modifier {
            font-size: 18px;
            font-weight: 700;
            color: #a5b4fc;
            text-align: center;
        }

        .save-name {
            font-size: 14px;
            color: #c7d2fe;
        }

        /* Skills */
        .skills-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
            margin-bottom: 15px;
        }

        .skill-row {
            display: grid;
            grid-template-columns: 25px 50px 1fr auto;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(129, 140, 248, 0.15);
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .skill-row:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(129, 140, 248, 0.3);
        }

        .skill-row.proficient {
            background: rgba(129, 140, 248, 0.08);
            border-color: rgba(129, 140, 248, 0.3);
        }

        .skill-row.proficient:hover {
            background: rgba(129, 140, 248, 0.12);
        }

        .skill-prof {
            font-size: 14px;
            color: #818cf8;
        }

        .skill-modifier {
            font-size: 16px;
            font-weight: 700;
            color: #a5b4fc;
            text-align: center;
        }

        .skill-name {
            font-size: 13px;
            color: #c7d2fe;
        }

        .skill-ability {
            font-size: 11px;
            color: #94a3b8;
            font-style: italic;
        }

        /* Equipment */
        .equipment-section {
            margin-top: 10px;
        }

        .empty-equipment {
            text-align: center;
            color: #94a3b8;
            padding: 30px 20px;
            background: rgba(255, 255, 255, 0.03);
            border: 2px dashed rgba(129, 140, 248, 0.2);
            border-radius: 10px;
            font-size: 14px;
        }

        .equipment-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
        }

.equipment-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 15px;
    background: rgba(129, 140, 248, 0.1);
    border: 1px solid rgba(129, 140, 248, 0.3);
    border-radius: 8px;
    transition: all 0.3s ease;
}

.equipment-item:hover {
    background: rgba(129, 140, 248, 0.15);
    border-color: rgba(129, 140, 248, 0.5);
    transform: translateX(5px);
}

.equipment-item-name {
    font-size: 14px;
    color: #e0e6ff;
    font-weight: 600;
}

.equipment-item-qty {
    font-size: 12px;
    color: #94a3b8;
    background: rgba(0, 0, 0, 0.3);
    padding: 4px 8px;
    border-radius: 12px;
}
        .equipment-item.equipped {
            border-color: rgba(16, 185, 129, 0.6);
            background: rgba(16, 185, 129, 0.12);
            box-shadow: 0 0 12px rgba(16, 185, 129, 0.2);
        }

        .equipment-group {
            margin-bottom: 18px;
        }

        .equipment-group-title {
            font-size: 13px;
            font-weight: 700;
            color: #94a3b8;
            letter-spacing: 0.6px;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .equipment-meta {
            font-size: 12px;
            color: #cbd5f5;
            margin-top: 4px;
        }

        .equipment-chip {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 2px 6px;
            border-radius: 999px;
            background: rgba(16, 185, 129, 0.2);
            color: #6ee7b7;
            border: 1px solid rgba(16, 185, 129, 0.4);
            margin-left: 6px;
        }

        .equipment-icon {
            margin-right: 6px;
        }

        /* Combat Action System Styles */
        .action-economy {
            display: flex;
            gap: 8px;
            margin: 10px 0;
            flex-wrap: wrap;
        }

        .action-indicator {
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border: 1px solid;
        }

        .action-indicator.available {
            background: rgba(16, 185, 129, 0.2);
            border-color: rgba(16, 185, 129, 0.5);
            color: #10b981;
        }

        .action-indicator.used {
            background: rgba(107, 114, 128, 0.2);
            border-color: rgba(107, 114, 128, 0.5);
            color: #6b7280;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .action-btn {
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 600;
            border-radius: 6px;
            border: 1px solid;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .action-btn-attack {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            border-color: #dc2626;
            color: white;
        }

        .action-btn-attack:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }

        .action-btn-spell {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            border-color: #7c3aed;
            color: white;
        }

        .action-btn-spell:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
        }

        .action-btn-other {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-color: #2563eb;
            color: white;
        }

        .action-btn-other:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .action-btn-end-turn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border-color: #059669;
            color: white;
        }

        .action-btn-end-turn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        .action-btn-rage {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            border-color: #f59e0b;
            color: #1f1302;
        }

        .action-btn-rage:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
        }

        /* Combat Log Styles */
        .combat-log {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .combat-log-title {
            font-size: 18px;
            font-weight: 700;
            color: #c7d2fe;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(99, 102, 241, 0.3);
        }

        .combat-log-entry {
            padding: 10px 15px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-left: 3px solid #818cf8;
            border-radius: 6px;
            font-size: 13px;
            line-height: 1.6;
        }

        .combat-log-entry.attack {
            border-left-color: #ef4444;
        }

        .combat-log-entry.spell {
            border-left-color: #8b5cf6;
        }

        .combat-log-entry.other {
            border-left-color: #3b82f6;
        }

        .combat-log-entry.defeat {
            border-left-color: #f87171;
            background: rgba(248, 113, 113, 0.08);
        }

        .combat-log-round {
            color: #818cf8;
            font-weight: 700;
        }

        .combat-log-actor {
            color: #10b981;
            font-weight: 600;
        }

        .combat-log-target {
            color: #f59e0b;
            font-weight: 600;
        }

        .combat-log-damage {
            color: #ef4444;
            font-weight: 700;
        }

        .combat-log-resistance {
            display: block;
            color: #94a3b8;
            font-size: 12px;
            margin-top: 4px;
        }

        .combat-log-heal {
            color: #10b981;
            font-weight: 700;
        }

        .summary-overview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        .summary-stat-card {
            padding: 16px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(129, 140, 248, 0.2);
        }

        .summary-stat-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #94a3b8;
            margin-bottom: 6px;
        }

        .summary-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #e0e6ff;
        }

        .summary-highlights {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        .summary-highlight-card {
            padding: 16px;
            border-radius: 12px;
            background: linear-gradient(135deg, rgba(129, 140, 248, 0.18), rgba(167, 139, 250, 0.12));
            border: 1px solid rgba(129, 140, 248, 0.3);
        }

        .summary-highlight-label {
            font-size: 13px;
            color: #c7d2fe;
            margin-bottom: 6px;
        }

        .summary-highlight-value {
            font-size: 20px;
            font-weight: 700;
            color: #fff;
        }

        .summary-highlight-name {
            font-size: 13px;
            color: #f8fafc;
            margin-top: 4px;
        }

        .summary-table-wrapper {
            max-height: 320px;
            overflow-y: auto;
            border: 1px solid rgba(129, 140, 248, 0.25);
            border-radius: 10px;
        }

        .summary-table {
            width: 100%;
            border-collapse: collapse;
        }

        .summary-table thead {
            background: rgba(129, 140, 248, 0.15);
            position: sticky;
            top: 0;
        }

        .summary-table th,
        .summary-table td {
            padding: 10px 12px;
            text-align: left;
            font-size: 14px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
        }

        .summary-table th {
            font-weight: 600;
            color: #c7d2fe;
        }

        .summary-table td {
            color: #e0e6ff;
        }

        .summary-empty-state {
            padding: 20px;
            text-align: center;
            color: #94a3b8;
        }

        /* Roll Display */
        .roll-display {
            background: rgba(129, 140, 248, 0.1);
            border: 1px solid rgba(129, 140, 248, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .spell-select-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }

        .spell-card {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(129, 140, 248, 0.3);
            border-radius: 12px;
            padding: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }

        .spell-card:hover {
            border-color: rgba(129, 140, 248, 0.6);
            transform: translateY(-2px);
        }

        .spell-card.active {
            border-color: #818cf8;
            box-shadow: 0 4px 18px rgba(129, 140, 248, 0.25);
        }

        .spell-card-title {
            font-size: 15px;
            font-weight: 700;
            color: #e0e6ff;
            margin-bottom: 4px;
        }

        .spell-card-meta {
            font-size: 12px;
            color: #a5b4fc;
            margin-bottom: 6px;
        }

        .spell-card-detail {
            font-size: 12px;
            color: #c7d2fe;
            line-height: 1.4;
        }

        .spell-card-dice {
            margin-top: 8px;
            font-size: 12px;
            font-weight: 600;
            color: #fbbf24;
        }

        .spell-detail-panel {
            background: rgba(129, 140, 248, 0.08);
            border: 1px solid rgba(129, 140, 248, 0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .spell-detail-name {
            font-size: 18px;
            font-weight: 700;
            color: #e0e6ff;
        }

        .spell-detail-meta {
            font-size: 12px;
            color: #c7d2fe;
            margin: 6px 0;
        }

        .spell-detail-desc {
            font-size: 13px;
            color: #cbd5f5;
            line-height: 1.5;
        }

        .form-helper-text {
            font-size: 12px;
            color: #a5b4fc;
            margin-top: 6px;
        }

        .roll-result {
            font-size: 32px;
            font-weight: 800;
            color: #818cf8;
            margin: 10px 0;
        }

        .roll-breakdown {
            font-size: 14px;
            color: #a5b4fc;
            margin-top: 5px;
        }

        /* Action Type Selector */
        .action-type-selector {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }

        .action-type-option {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(129, 140, 248, 0.2);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .action-type-option:hover {
            background: rgba(129, 140, 248, 0.1);
        }

        .action-type-option.selected {
            background: rgba(129, 140, 248, 0.2);
            border-color: #818cf8;
        }

        .action-type-option input[type="radio"] {
            margin-right: 8px;
        }

        /* Target Selection */
        .target-list {
            max-height: 200px;
            overflow-y: auto;
            margin: 15px 0;
        }

        .target-option {
            padding: 12px 15px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .target-option:hover {
            background: rgba(129, 140, 248, 0.1);
            border-color: rgba(129, 140, 248, 0.4);
        }

        .target-option input[type="radio"],
        .target-option input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #818cf8;
        }

        .resistance-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .resistance-chip {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid rgba(129, 140, 248, 0.4);
            background: rgba(129, 140, 248, 0.12);
            font-size: 13px;
            color: #e0e6ff;
        }

        .resistance-chip input {
            accent-color: #a78bfa;
        }

        .resistance-pill-container {
            margin-top: 8px;
        }

        .resistance-pill {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            border-radius: 999px;
            border: 1px solid rgba(129, 140, 248, 0.3);
            background: rgba(99, 102, 241, 0.1);
            font-size: 12px;
            color: #c7d2fe;
            margin-right: 6px;
            margin-top: 4px;
        }

        .target-option-name {
            flex: 1;
            font-weight: 600;
            color: #e0e6ff;
        }

        .target-option-type {
            font-size: 12px;
            color: #888;
        }

        /* Dice Input with Roll Button */
        .dice-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .dice-input-group .form-input {
            flex: 1;
        }

        .dice-roll-btn {
            padding: 12px 20px;
            background: linear-gradient(135deg, #818cf8 0%, #a78bfa 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .dice-roll-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(129, 140, 248, 0.4);
        }
    </style>
</head>
<body>
<div id="levelUpToastContainer" class="levelup-toast-container"></div>
    <div class="container">
        <div class="header">
            <a href="/dashboard" class="back-btn">
                Back to Dashboard
            </a>
            <div class="campaign-title" id="campaignTitle">Loading...</div>
            <div class="role-badge" id="roleBadge">Loading...</div>
        </div>
        <div id="levelUpCalloutBar" class="levelup-callout-bar"></div>

        <div class="loading" id="loading">Loading campaign...</div>
        <div id="errorContainer"></div>

        <!-- DM View -->
        <div id="dmView" class="content">
            <div class="tabs">
                <button class="tab-btn active" onclick="switchTab(event, 'overview')">Overview</button>
                <button class="tab-btn" onclick="switchTab(event, 'npcs')">NPCs</button>
                <button class="tab-btn" onclick="switchTab(event, 'combat')">Combat</button>
            </div>

            <!-- Overview Tab -->
            <div id="overviewTab" class="tab-content active">
                <div class="section">
                    <div class="section-title">Campaign Information</div>
                    <div class="info-grid" id="campaignInfo"></div>
                </div>

                <div class="section">
                    <div class="section-title">Players & Characters</div>
                    <div class="players-grid" id="playersList"></div>
                </div>

                <div class="section">
                    <div class="section-title">
                        <span>Quest Board</span>
                        <button class="btn" onclick="openQuestModal()">Create Quest</button>
                    </div>
                    <div id="questBoardEmpty" class="quest-empty-state">No quests have been posted yet.</div>
                    <div id="questBoard" class="quest-grid"></div>
                </div>

                <div class="section">
                    <div class="section-title">Live Roll Log</div>
                    <div style="display:flex; gap:10px; margin-bottom:10px; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="toggleDiceLog()">Toggle</button>
                        <button class="btn btn-secondary" onclick="clearDiceLog()">Clear</button>
                    </div>
                    <div id="diceLogContainer" class="dice-log">
                        <div class="quest-empty-state">No rolls yet.</div>
                    </div>
                </div>
            </div>

            <!-- NPCs Tab -->
            <div id="npcsTab" class="tab-content">
                <div class="section">
                    <div class="section-title">
                        <span>Campaign NPCs</span>
                        <button class="btn" onclick="createNPC()">Create New NPC</button>
                    </div>
                    <div id="npcsList"></div>
                </div>
            </div>

            <!-- Combat Tab -->
            <div id="combatTab" class="tab-content">
                <div class="section">
                    <div class="section-title">Combat Encounter</div>

                    <div class="combat-status" id="combatStatus">
                        <div class="combat-indicator">
                            <div class="combat-pulse" id="combatPulse"></div>
                            <span id="combatStatusText">No Active Combat</span>
                        </div>
                        <div class="round-counter" id="roundCounter"></div>
                        <div>
                            <button class="btn btn-success" id="startCombatBtn" onclick="startCombat()">Start Combat</button>
                            <button class="btn btn-danger" id="endCombatBtn" onclick="endCombat()" style="display: none;">End Combat</button>
                        </div>
                    </div>

                    <div id="combatContent" class="combat-live-area" style="display: none;">
            <div class="combat-toolbar">
                <div class="live-sync" id="combatLiveSync">
                    <span class="live-dot" id="combatSyncDot"></span>
                                <div>
                                    <div class="live-sync-label">Live Link</div>
                                    <div class="live-sync-text" id="combatSyncText">Waiting for updates...</div>
                                </div>
                            </div>
                <div class="combat-toolbar-actions">
                    <button class="btn" onclick="nextTurn()">Next Turn</button>
                    <div class="dropdown" id="addNPCDropdown">
                        <button class="btn btn-secondary" onclick="toggleAddNPCDropdown()">Add NPC to Combat</button>
                        <div class="dropdown-content" id="addNPCDropdownContent"></div>
                    </div>
                    <div class="rage-control" id="combatRageControl" style="display: none;"></div>
                </div>
            </div>

                        <div class="combat-grid">
                            <div class="combat-column primary">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                    <div>
                                        <div class="summary-label">Initiative Order</div>
                                        <div class="summary-subtext" id="currentTurnLabel">Awaiting combatants...</div>
                                    </div>
                                    <div class="summary-subtext" id="nextTurnLabel"></div>
                                </div>
                                <div class="initiative-tracker" id="initiativeTracker"></div>
                            </div>
                            <div class="combat-column secondary">
                                <div class="combat-summary-grid">
                                    <div class="combat-summary-card">
                                        <div class="summary-label">Round</div>
                                        <div class="summary-value" id="summaryRoundValue">-</div>
                                        <div class="summary-subtext" id="summaryParticipantsValue">0 combatants</div>
                                    </div>
                                    <div class="combat-summary-card">
                                        <div class="summary-label">Current Turn</div>
                                        <div class="summary-value" id="summaryCurrentName"></div>
                                        <div class="summary-subtext" id="summaryCurrentType"></div>
                                    </div>
                                    <div class="combat-summary-card">
                                        <div class="summary-label">Next Up</div>
                                        <div class="summary-value" id="summaryNextName"></div>
                                        <div class="summary-subtext" id="summaryNextType"></div>
                                    </div>
                                </div>

                                <div class="combat-log" id="combatLog" style="display: none;">
                                    <div class="combat-log-title">Combat Log</div>
                                    <div id="combatLogEntries"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Player View -->
        <div id="playerView" class="content">
            <!-- Combat Alert -->
            <div id="combatAlertSection" style="display: none;">
                <div class="combat-alert">
                    <div class="combat-alert-header">
                        <div>
                            <div class="combat-alert-title">Combat in Progress!</div>
                            <div class="live-sync small">
                                <span class="live-dot" id="playerCombatSyncDot"></span>
                                <span class="live-sync-text" id="playerCombatSyncText">Waiting for DM...</span>
                            </div>
                        </div>
                        <div id="yourTurnIndicator" style="display: none;" class="your-turn-indicator">
                            IT'S YOUR TURN!
                        </div>
                    </div>

                    <div class="player-combat-hud" id="playerCombatHud" style="display: none;">
                        <div class="player-turn-card">
                            <div class="turn-label">Current Turn</div>
                            <div class="turn-value" id="playerCurrentTurnName"></div>
                            <div class="turn-sub" id="playerCurrentTurnType"></div>
                        </div>
                        <div class="player-turn-card">
                            <div class="turn-label">Next Up</div>
                            <div class="turn-value" id="playerNextTurnName"></div>
                            <div class="turn-sub" id="playerNextTurnType"></div>
                        </div>
                        <div class="player-turn-card">
                            <div class="turn-label">Round</div>
                            <div class="turn-value" id="playerRoundValue">-</div>
                            <div class="turn-sub" id="playerParticipantsCount">0 participants</div>
                        </div>
                    </div>

                    <div id="initiativeRollerSection" style="display: none;">
                        <div class="initiative-roller">
                            <h3 style="margin-bottom: 15px;">Roll Initiative</h3>
                            <div class="dice-container">
                                <div class="dice" id="playerDice">?</div>
                            </div>
                            <button class="btn" onclick="rollPlayerInitiative()" id="rollInitiativeBtn">Roll Initiative!</button>
                            <div class="form-group" style="margin-top: 15px;">
                                <label class="form-label">Additional Initiative Bonus</label>
                                <input type="number" class="form-input" id="initiativeBonusInput" value="0" oninput="handleInitiativeBonusInput(this.value)">
                                <div style="font-size: 12px; color: #94a3b8; margin-top: 4px;">Use this if feats, spells, or items add to your initiative.</div>
                            </div>
                            <div id="initiativeResult" style="margin-top: 15px; display: none;">
                                <div style="font-size: 18px; color: #a5b4fc; margin-bottom: 10px;">Your Initiative:</div>
                                <div style="font-size: 32px; font-weight: 700; color: #818cf8;" id="initiativeTotal"></div>
                                <button class="btn btn-success" onclick="submitPlayerInitiative()" style="margin-top: 15px;">Submit</button>
                            </div>
                        </div>
                    </div>

                    <div id="initiativeOrderSection" style="display: none;">
                        <h3 style="margin: 20px 0 15px;">Initiative Order</h3>
                        <div class="initiative-tracker" id="playerInitiativeTracker"></div>
                    </div>

                    <!-- Combat Log for Players -->
                    <div class="combat-log" id="playerCombatLog" style="display: none; margin-top: 20px;">
                        <div class="combat-log-title">Combat Log</div>
                        <div id="playerCombatLogEntries"></div>
                    </div>
                </div>
            </div>

            <!-- Game-Style HP Display (Always Visible) -->
            <div id="playerHPSection">
                <div class="section">
                    <div class="game-ui-container">
                        <!-- Health Bar -->
                        <div class="game-health-section">
                            <div class="game-health-label">HEALTH</div>
                            <div class="game-health-bar-container">
                                <div class="game-health-bar-bg">
                                    <div class="game-health-bar-fill" id="gameHealthBarFill"></div>
                                </div>
                                <div class="game-health-text">
                                    <span id="gameCurrentHP">0</span> / <span id="gameMaxHP">0</span>
                                </div>
                            </div>
                            <div class="game-hp-controls">
                                <button class="game-hp-btn game-hp-minus" onclick="adjustPlayerHP(-1)">-</button>
                                <input type="number" class="game-hp-input" id="playerHPInput" min="0">
                                <button class="game-hp-btn game-hp-plus" onclick="adjustPlayerHP(1)">+</button>
                                <button class="game-hp-save-btn" onclick="updatePlayerHP()"></button>
                            </div>
                        </div>

                        <!-- Stats Row -->
                        <div class="game-stats-row">
                            <div class="game-stat-box">
                                <div class="game-stat-icon"></div>
                                <div class="game-stat-info">
                                    <div class="game-stat-label">AC</div>
                                    <div class="game-stat-value" id="gameAC">0</div>
                                </div>
                            </div>
                            <div class="game-stat-box">
                                <div class="game-stat-icon"></div>
                                <div class="game-stat-info">
                                    <div class="game-stat-label">Speed</div>
                                    <div class="game-stat-value" id="gameSpeed">0</div>
                                </div>
                            </div>
                            <div class="game-stat-box">
                                <div class="game-stat-icon"></div>
                                <div class="game-stat-info">
                                    <div class="game-stat-label">Level</div>
                                    <div class="game-stat-value" id="gameLevel">0</div>
                                </div>
                            </div>
                            <div class="game-rest-box">
                                <div class="game-rest-label">Rest</div>
                                <div class="game-rest-buttons">
                                    <button class="rest-btn-inline rest-btn-short" id="shortRestBtn" onclick="takeRest('short')">Short (2)</button>
                                    <button class="rest-btn-inline rest-btn-long" onclick="takeRest('long')">Long</button>
                                </div>
                            <div class="game-rest-summary" id="restResultSummary">
                                <div id="restResultContent"></div>
                            </div>
                        </div>
                    </div>

                        <!-- Spell Slots -->
                        <div id="gameSpellSlotsSection" style="display: none;">
                            <div class="game-spell-slots-title">SPELL SLOTS</div>
                            <div id="gameSpellSlotsContainer"></div>
                        </div>
                    </div>
            </div>
        </div>

        <div class="popout-tools">
            <button class="btn" onclick="openToolsPopup()"> Pop-out Tools</button>
        </div>

        <!-- Draggable Collapsible Sections Container -->
        <div class="section" id="draggableSectionsContainer">
                <!-- Dice Roller -->
                <div class="collapsible-section draggable-section" draggable="true" data-section-id="diceRoller">
                    <div class="collapsible-header" onclick="toggleSection('diceRollerSection')">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span class="drag-handle" title="Drag to reorder"></span>
                            <span style="font-size: 24px;"></span>
                            <span style="font-size: 18px; font-weight: 700; color: #e0e6ff;">Dice Roller</span>
                        </div>
                        <span class="collapsible-arrow" id="diceRollerSectionArrow"></span>
                    </div>
                    <div class="collapsible-content collapsed" id="diceRollerSection">
                        <div class="dice-roller">
                            <div class="dice-options">
                                <button class="dice-btn" onclick="selectDice(4)">d4</button>
                                <button class="dice-btn" onclick="selectDice(6)">d6</button>
                                <button class="dice-btn" onclick="selectDice(8)">d8</button>
                                <button class="dice-btn" onclick="selectDice(10)">d10</button>
                                <button class="dice-btn" onclick="selectDice(12)">d12</button>
                                <button class="dice-btn active" onclick="selectDice(20)">d20</button>
                            </div>

                            <div class="form-group" style="max-width: 200px; margin: 20px auto;">
                                <label class="form-label">Modifier</label>
                                <input type="number" class="form-input" id="diceModifier" value="0" style="text-align: center;">
                            </div>

                            <div class="dice-container">
                                <div class="dice" id="diceDisplay" data-dice-display>?</div>
                            </div>

                            <div class="dice-result" id="diceResult" data-dice-result>Roll the dice!</div>

                            <button class="btn" onclick="rollDice()">Roll</button>

                            <div class="roll-history" id="rollHistory" style="display: none;">
                                <div class="roll-history-title">Recent Rolls</div>
                                <div id="rollHistoryList"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Character Sheet -->
                <div class="collapsible-section draggable-section" draggable="true" data-section-id="characterSheet">
                    <div class="collapsible-header" onclick="toggleSection('characterSheetSection')">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span class="drag-handle" title="Drag to reorder"></span>
                            <span style="font-size: 24px;"></span>
                            <span style="font-size: 18px; font-weight: 700; color: #e0e6ff;">Character Sheet</span>
                        </div>
                        <span class="collapsible-arrow" id="characterSheetArrow"></span>
                    </div>
                    <div class="collapsible-content collapsed" id="characterSheetSection">
                        <div class="character-sheet" id="characterSheet"></div>
                    </div>
                </div>

                <!-- Inventory -->
                <div class="collapsible-section draggable-section" draggable="true" data-section-id="inventory">
                    <div class="collapsible-header" onclick="toggleSection('inventorySection')">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span class="drag-handle" title="Drag to reorder"></span>
                            <span style="font-size: 24px;"></span>
                            <span style="font-size: 18px; font-weight: 700; color: #e0e6ff;">Inventory</span>
                        </div>
                        <span class="collapsible-arrow" id="inventorySectionArrow"></span>
                    </div>
                    <div class="collapsible-content collapsed" id="inventorySection">
                        <div style="margin-bottom: 15px;">
                            <button class="btn" onclick="addInventoryItem()" style="width: 100%;">+ Add Item</button>
                        </div>
                        <div class="inventory-grid" id="inventoryGrid">
                            <div style="grid-column: 1 / -1; text-align: center; color: #94a3b8; padding: 40px 20px;">
                                No items in inventory
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Notes -->
                <div class="collapsible-section draggable-section" draggable="true" data-section-id="notes">
                    <div class="collapsible-header" onclick="toggleSection('notesSection')">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span class="drag-handle" title="Drag to reorder"></span>
                            <span style="font-size: 24px;"></span>
                            <span style="font-size: 18px; font-weight: 700; color: #e0e6ff;">Notes</span>
                        </div>
                        <span class="collapsible-arrow" id="notesSectionArrow"></span>
                    </div>
                <div class="collapsible-content collapsed" id="notesSection">
                    <div class="note-card-actions" style="justify-content: flex-start; margin-bottom: 12px;">
                        <button class="btn" onclick="addPlayerNote()">+ Add Note</button>
                    </div>
                    <div id="playerNotesContainer" class="notes-container"></div>
                </div>
            </div>

                <!-- Quests -->
                <div class="collapsible-section draggable-section" draggable="true" data-section-id="quests">
                    <div class="collapsible-header" onclick="toggleSection('questsSection')">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span class="drag-handle" title="Drag to reorder"></span>
                            <span style="font-size: 24px;"></span>
                            <span style="font-size: 18px; font-weight: 700; color: #e0e6ff;">Quests</span>
                        </div>
                        <span class="collapsible-arrow" id="questsSectionArrow"></span>
                    </div>
                    <div class="collapsible-content collapsed" id="questsSection">
                        <div class="quest-empty-state" id="playerQuestEmpty">No quests assigned yet. Your DM will post objectives here.</div>
                        <div id="playerQuestList" class="quest-grid"></div>
                    </div>
                </div>

                <!-- Roll Log -->
                <div class="collapsible-section draggable-section" draggable="true" data-section-id="diceLog">
                    <div class="collapsible-header" onclick="toggleSection('diceLogSection')">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span class="drag-handle" title="Drag to reorder"></span>
                            <span style="font-size: 24px;"></span>
                            <span style="font-size: 18px; font-weight: 700; color: #e0e6ff;">Roll Log</span>
                        </div>
                        <span class="collapsible-arrow" id="diceLogSectionArrow"></span>
                    </div>
                    <div class="collapsible-content collapsed" id="diceLogSection">
                        <div class="dice-log" id="playerDiceLog">
                            <div class="quest-empty-state">No rolls yet.</div>
                        </div>
                    </div>
                </div>
        </div>
    </div>
</div>

    <!-- Quest Modal -->
    <div class="modal" id="questModal">
        <div class="modal-content" style="max-width: 520px;">
            <div class="modal-header">
                <div class="modal-title">Create Quest</div>
                <button class="close-btn" onclick="closeQuestModal()">&times;</button>
            </div>

            <div class="form-group">
                <label class="form-label">Quest Title</label>
                <input type="text" class="form-input" id="questTitleInput" placeholder="Rescue the Ember Prince">
            </div>

            <div class="form-group">
                <label class="form-label">Quest Brief</label>
                <textarea class="form-input" id="questDescriptionInput" rows="4" placeholder="Describe the objective, important NPCs, or narrative beats."></textarea>
            </div>

            <div class="form-group">
                <label class="form-label">Rewards</label>
                <textarea class="form-input" id="questRewardsInput" rows="3" placeholder="Gold amounts, items, downtime perks, or XP tiers."></textarea>
                <div class="form-helper-text">You can list multiple rewards on separate lines.</div>
            </div>

            <div class="form-group">
                <label class="form-label">Turn-In Location</label>
                <input type="text" class="form-input" id="questTurnInInput" placeholder="Where to claim the reward (NPC name, city, etc.)">
            </div>

            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeQuestModal()">Cancel</button>
                <button type="button" class="btn" onclick="submitQuest()">Save Quest</button>
            </div>
        </div>
    </div>

    <div class="quest-popup-overlay" id="questPopup">
        <div class="quest-scroll">
        <div class="quest-scroll-wrap">
            <div class="quest-scroll-roll top"></div>
            <div class="quest-scroll">
                <div class="quest-scroll-heading">Quest</div>
                <div class="quest-scroll-title" id="questPopupTitle">New Quest</div>
                <div class="quest-scroll-body" id="questPopupDescription"></div>
                <div class="quest-scroll-rewards">
                    <div style="font-size: 12px; text-transform: uppercase; letter-spacing: 3px; margin-bottom: 6px;">Rewards</div>
                    <div id="questPopupRewards"></div>
                </div>
                <div class="quest-scroll-rewards" id="questPopupTurnInWrap" style="margin-top: 14px; display: none;">
                    <div style="font-size: 12px; text-transform: uppercase; letter-spacing: 3px; margin-bottom: 6px;">Turn In</div>
                    <div id="questPopupTurnIn"></div>
                </div>
                <button class="quest-scroll-button" onclick="acknowledgeQuestPopup()">Accept</button>
                <div class="quest-scroll-seal"></div>
            </div>
            <div class="quest-scroll-roll bottom"></div>
        </div>
        </div>
    </div>

    <div class="modal" id="clearDiceLogModal">
        <div class="modal-content" style="max-width: 420px;">
            <div class="modal-header">
                <div class="modal-title">Clear Roll Log?</div>
                <button class="close-btn" onclick="closeClearDiceLogModal()">&times;</button>
            </div>
            <div style="padding: 10px 0; color: #d1d5db;">
                This will erase the live roll history for <strong>all players</strong> in this campaign. This action cannot be undone.
            </div>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeClearDiceLogModal()">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="confirmClearDiceLog()">Clear Log</button>
            </div>
        </div>
    </div>

    <!-- NPC Modal -->
    <div class="modal" id="npcModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="npcModalTitle">Create NPC</div>
                <button class="close-btn" onclick="closeNPCModal()">&times;</button>
            </div>

            <form id="npcForm" onsubmit="saveNPC(event)">
                <input type="hidden" id="npcId">

                <div class="form-group">
                    <label class="form-label">NPC Name</label>
                    <input type="text" class="form-input" id="npcName" required>
                </div>

                <div class="form-group">
                    <label class="form-label">Type</label>
                    <input type="text" class="form-input" id="npcType" placeholder="e.g., Goblin, Wizard, Guard">
                </div>

                <div class="form-row-3">
                    <div class="form-group">
                        <label class="form-label">Current HP</label>
                        <input type="number" class="form-input" id="npcHP" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Max HP</label>
                        <input type="number" class="form-input" id="npcMaxHP" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">AC</label>
                        <input type="number" class="form-input" id="npcAC" required>
                    </div>
                </div>

                <div class="form-label" style="margin-top: 20px; margin-bottom: 15px;">Ability Scores</div>
                <div class="stats-grid">
                    <div class="form-group">
                        <label class="form-label">STR</label>
                        <input type="number" class="form-input" id="npcSTR" value="10">
                    </div>
                    <div class="form-group">
                        <label class="form-label">DEX</label>
                        <input type="number" class="form-input" id="npcDEX" value="10">
                    </div>
                    <div class="form-group">
                        <label class="form-label">CON</label>
                        <input type="number" class="form-input" id="npcCON" value="10">
                    </div>
                    <div class="form-group">
                        <label class="form-label">INT</label>
                        <input type="number" class="form-input" id="npcINT" value="10">
                    </div>
                    <div class="form-group">
                        <label class="form-label">WIS</label>
                        <input type="number" class="form-input" id="npcWIS" value="10">
                    </div>
                    <div class="form-group">
                        <label class="form-label">CHA</label>
                        <input type="number" class="form-input" id="npcCHA" value="10">
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Damage Resistances</label>
                    <div class="resistance-grid" id="npcResistanceOptions"></div>
                    <div class="form-helper-text">Select all damage types this creature resists.</div>
                </div>
                <div class="form-group">
                    <label class="form-label">Damage Immunities</label>
                    <div class="resistance-grid" id="npcImmunityOptions"></div>
                    <div class="form-helper-text">Select damage types this creature is immune to.</div>
                </div>
                <div class="form-group">
                    <label class="form-label">Damage Vulnerabilities</label>
                    <div class="resistance-grid" id="npcVulnerabilityOptions"></div>
                    <div class="form-helper-text">Select damage types this creature is vulnerable to.</div>
                </div>

                <div class="form-label" style="margin-top: 20px; margin-bottom: 15px;">
                    Inventory & Equipment
                    <button type="button" class="btn btn-sm" onclick="addNPCItem()" style="float: right; margin-top: -5px;">Add Item</button>
                </div>

                <div style="background: rgba(100, 116, 139, 0.1); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <div style="font-size: 13px; color: #94a3b8; margin-bottom: 5px;"> Equipped Weapon</div>
                            <div id="npcEquippedWeapon" style="color: #fff; font-weight: 500;">None</div>
                        </div>
                        <div>
                            <div style="font-size: 13px; color: #94a3b8; margin-bottom: 5px;"> Equipped Armor</div>
                            <div id="npcEquippedArmor" style="color: #fff; font-weight: 500;">None</div>
                        </div>
                    </div>
                    <div id="npcInventoryList" style="max-height: 200px; overflow-y: auto;"></div>
                </div>

                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeNPCModal()">Cancel</button>
                    <button type="submit" class="btn">Save NPC</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Start Combat Modal -->
    <div class="modal" id="startCombatModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Start Combat Encounter</div>
                <button class="close-btn" onclick="closeStartCombatModal()">&times;</button>
            </div>

            <div style="margin-bottom: 25px;">
                <div class="form-label" style="margin-bottom: 15px;">Select Participants</div>

                <div style="margin-bottom: 20px;">
                    <div style="font-size: 16px; font-weight: 600; color: #a5b4fc; margin-bottom: 10px;">NPCs</div>
                    <div id="combatNPCList"></div>
                </div>

                <div>
                    <div style="font-size: 16px; font-weight: 600; color: #a5b4fc; margin-bottom: 10px;">Players</div>
                    <div id="combatPlayerList"></div>
                </div>
            </div>

            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeStartCombatModal()">Cancel</button>
                <button type="button" class="btn btn-success" onclick="confirmStartCombat()">Start Combat</button>
            </div>
        </div>
    </div>

    <!-- Attack Modal -->
    <div class="modal" id="attackModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Make an Attack</div>
                <button class="close-btn" onclick="closeAttackModal()">&times;</button>
            </div>

            <div class="form-group">
                <label class="form-label">Weapon Source</label>
                <div class="action-type-selector" style="margin-bottom: 10px;">
                    <label class="action-type-option selected" onclick="selectWeaponSource('inventory')">
                        <input type="radio" name="weaponSource" value="inventory" checked> From Inventory
                    </label>
                    <label class="action-type-option" onclick="selectWeaponSource('custom')">
                        <input type="radio" name="weaponSource" value="custom"> Custom
                    </label>
                </div>
            </div>

            <div class="form-group" id="weaponInventorySelect">
                <label class="form-label">Select Weapon</label>
                <select class="form-input" id="weaponFromInventory" onchange="handleWeaponSelection()">
                    <option value="">-- Select a weapon --</option>
                </select>
            </div>

            <div class="form-group" id="weaponCustomInput" style="display: none;">
                <label class="form-label">Weapon/Attack Name</label>
                <input type="text" class="form-input" id="attackName" placeholder="Longsword, Firebolt, etc.">
            </div>

            <div class="form-group">
                <label class="form-label">Target</label>
                <div class="target-list" id="attackTargetList"></div>
            </div>

            <div class="form-group rage-control" id="rageControl" style="display: none;"></div>

            <div class="form-group">
                <label class="form-label">Attack Bonus</label>
                <input type="number" class="form-input" id="attackBonus" value="0">
            </div>

            <div class="form-group">
                <button class="dice-roll-btn" style="width: 100%;" onclick="rollAttack()">Roll Attack (d20)</button>
            </div>

            <div id="attackRollResult" style="display: none;">
                <div class="roll-display">
                    <div style="font-size: 14px; color: #a5b4fc; margin-bottom: 5px;">Attack Roll</div>
                    <div class="roll-result" id="attackRollTotal">-</div>
                    <div class="roll-breakdown" id="attackRollBreakdown">-</div>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Damage Dice (e.g., 1d8+3, 2d6)</label>
                <div class="dice-input-group">
                    <input type="text" class="form-input" id="attackDamage" placeholder="1d8+3">
                    <button class="dice-roll-btn" onclick="rollDamage()">Roll</button>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Damage Type</label>
                <select class="form-input" id="attackDamageType"></select>
            </div>

            <div id="damageRollResult" style="display: none;">
                <div class="roll-display">
                    <div style="font-size: 14px; color: #a5b4fc; margin-bottom: 5px;">Damage</div>
                    <div class="roll-result combat-log-damage" id="damageRollTotal">-</div>
                    <div class="roll-breakdown" id="damageRollBreakdown">-</div>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Action Type</label>
                <div class="action-type-selector">
                    <label class="action-type-option selected" onclick="selectActionType('action')">
                        <input type="radio" name="attackActionType" value="action" checked> Action
                    </label>
                    <label class="action-type-option" onclick="selectActionType('bonus')">
                        <input type="radio" name="attackActionType" value="bonus"> Bonus Action
                    </label>
                </div>
            </div>

            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeAttackModal()">Cancel</button>
                <button type="button" class="btn btn-success" onclick="submitAttack()">Submit Attack</button>
            </div>
        </div>
    </div>

    <!-- Spell Modal -->
    <div class="modal" id="spellModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Cast a Spell</div>
                <button class="close-btn" onclick="closeSpellModal()">&times;</button>
            </div>

            <div class="form-group" id="spellSelectionSection" style="display: none;">
                <label class="form-label">Your Known & Prepared Spells</label>
                <div class="spell-select-grid" id="spellSelectionList"></div>
                <div class="form-helper-text" id="spellSelectionHelper"></div>
            </div>

            <div class="spell-detail-panel" id="spellDetailPanel" style="display: none;">
                <div class="spell-detail-name" id="spellDetailName">Spell</div>
                <div class="spell-detail-meta" id="spellDetailMeta"></div>
                <div class="spell-detail-desc" id="spellDetailDescription"></div>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label class="form-label">Spell Name</label>
                    <input type="text" class="form-input" id="spellName" placeholder="Magic Missile, Cure Wounds, etc." required>
                </div>
                <div class="form-group">
                    <label class="form-label">Spell Level</label>
                    <input type="number" class="form-input" id="spellLevel" min="0" max="9" value="1">
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Target(s)</label>
                <div style="margin-bottom: 10px;">
                    <label style="font-size: 12px; color: #a5b4fc;">
                        <input type="checkbox" id="spellMultiTarget" style="margin-right: 6px;">
                        Multiple targets
                    </label>
                </div>
                <div class="target-list" id="spellTargetList"></div>
            </div>

            <div class="form-group">
                <label class="form-label">Effect Type</label>
                <div class="action-type-selector">
                    <label class="action-type-option selected" onclick="selectSpellType('damage')">
                        <input type="radio" name="spellType" value="damage" checked> Damage
                    </label>
                    <label class="action-type-option" onclick="selectSpellType('healing')">
                        <input type="radio" name="spellType" value="healing"> Healing
                    </label>
                    <label class="action-type-option" onclick="selectSpellType('other')">
                        <input type="radio" name="spellType" value="other"> Other
                    </label>
                </div>
            </div>

            <div class="form-group" id="spellDiceGroup">
                <label class="form-label">Damage/Healing Dice (e.g., 3d6, 2d8+4)</label>
                <div class="dice-input-group">
                    <input type="text" class="form-input" id="spellDice" placeholder="3d6">
                    <button class="dice-roll-btn" onclick="rollSpellEffect()">Roll</button>
                </div>
            </div>

            <div class="form-group" id="spellDamageTypeGroup" style="display: none;">
                <label class="form-label">Damage Type</label>
                <select class="form-input" id="spellDamageType"></select>
            </div>

            <div id="spellEffectResult" style="display: none;">
                <div class="roll-display">
                    <div style="font-size: 14px; color: #a5b4fc; margin-bottom: 5px;" id="spellEffectLabel">Effect</div>
                    <div class="roll-result" id="spellEffectTotal">-</div>
                    <div class="roll-breakdown" id="spellEffectBreakdown">-</div>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Action Type</label>
                <div class="action-type-selector">
                    <label class="action-type-option selected" onclick="selectActionType('action')">
                        <input type="radio" name="spellActionType" value="action" checked> Action
                    </label>
                    <label class="action-type-option" onclick="selectActionType('bonus')">
                        <input type="radio" name="spellActionType" value="bonus"> Bonus Action
                    </label>
                </div>
            </div>

            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeSpellModal()">Cancel</button>
                <button type="button" class="btn btn-success" onclick="submitSpell()">Cast Spell</button>
            </div>
        </div>
    </div>

    <!-- Other Action Modal -->
    <div class="modal" id="otherActionModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Perform Action</div>
                <button class="close-btn" onclick="closeOtherActionModal()">&times;</button>
            </div>

            <div class="form-group">
                <label class="form-label">Action</label>
                <select class="form-input" id="otherActionName">
                    <option value="Dash">Dash</option>
                    <option value="Disengage">Disengage</option>
                    <option value="Dodge">Dodge</option>
                    <option value="Help">Help</option>
                    <option value="Hide">Hide</option>
                    <option value="Ready">Ready</option>
                    <option value="Search">Search</option>
                    <option value="Use Object">Use Object</option>
                    <option value="Custom">Custom</option>
                </select>
            </div>

            <div class="form-group" id="customActionGroup" style="display: none;">
                <label class="form-label">Custom Action Name</label>
                <input type="text" class="form-input" id="customActionName" placeholder="Enter custom action">
            </div>

            <div class="form-group">
                <label class="form-label">Description</label>
                <textarea class="form-input" id="otherActionDescription" rows="3" placeholder="Describe what you're doing..."></textarea>
            </div>

            <div class="form-group">
                <label class="form-label">Action Type</label>
                <div class="action-type-selector">
                    <label class="action-type-option selected" onclick="selectActionType('action')">
                        <input type="radio" name="otherActionType" value="action" checked> Action
                    </label>
                    <label class="action-type-option" onclick="selectActionType('bonus')">
                        <input type="radio" name="otherActionType" value="bonus"> Bonus Action
                    </label>
                    <label class="action-type-option" onclick="selectActionType('reaction')">
                        <input type="radio" name="otherActionType" value="reaction"> Reaction
                    </label>
                </div>
            </div>

            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeOtherActionModal()">Cancel</button>
                <button type="button" class="btn btn-success" onclick="submitOtherAction()">Perform Action</button>
            </div>
        </div>
    </div>

    <!-- Add Item Modal -->
    <div class="modal" id="addItemModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Add Item to Inventory</div>
                <button class="close-btn" onclick="closeAddItemModal()">&times;</button>
            </div>

            <form id="addItemForm" onsubmit="event.preventDefault(); submitAddItem();">
                <div class="form-group">
                    <label class="form-label">Item Type</label>
                    <select class="form-input" id="itemType" onchange="handleItemTypeChange()">
                        <option value="weapon">Weapon</option>
                        <option value="armor">Armor</option>
                        <option value="shield">Shield</option>
                        <option value="potion">Potion</option>
                        <option value="consumable">Consumable (Acid, Oil, etc.)</option>
                        <option value="tool">Tools & Kits</option>
                        <option value="gear">Gear & Miscellaneous</option>
                        <option value="pack">Packs</option>
                        <option value="focus">Focus / Holy Symbol</option>
                        <option value="ammo">Ammunition</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label">Select Item</label>
                    <select class="form-input" id="itemNameSelect" onchange="handleItemSelection()">
                        <!-- Populated by JavaScript -->
                    </select>
                </div>

                <div class="form-group" id="customItemNameGroup" style="display: none;">
                    <label class="form-label">Custom Item Name</label>
                    <input type="text" class="form-input" id="itemCustomName" placeholder="Enter custom item name">
                </div>

                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea class="form-input" id="itemDescription" rows="2" placeholder="Optional description"></textarea>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Quantity</label>
                        <input type="number" class="form-input" id="itemQuantity" value="1" min="1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" id="itemEquipped" style="margin-right: 8px;">
                            Equip this item
                        </label>
                    </div>
                </div>

                <!-- Weapon-specific fields -->
                <div id="weaponFields" style="display: none;">
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Damage Dice (e.g., 1d8+2)</label>
                            <input type="text" class="form-input" id="weaponDamage" placeholder="1d8">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Attack Bonus</label>
                            <input type="number" class="form-input" id="weaponBonus" value="0">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Damage Type</label>
                        <select class="form-input" id="weaponDamageType">
                            <option value="physical">Physical</option>
                            <option value="slashing">Slashing</option>
                            <option value="piercing">Piercing</option>
                            <option value="bludgeoning">Bludgeoning</option>
                            <option value="fire">Fire</option>
                            <option value="cold">Cold</option>
                            <option value="lightning">Lightning</option>
                            <option value="poison">Poison</option>
                            <option value="acid">Acid</option>
                            <option value="psychic">Psychic</option>
                            <option value="necrotic">Necrotic</option>
                            <option value="radiant">Radiant</option>
                        </select>
                    </div>
                </div>

                <!-- Potion-specific fields -->
                <div id="potionFields" style="display: none;">
                    <div class="form-group">
                        <label class="form-label">Effect</label>
                        <select class="form-input" id="potionEffect">
                            <option value="healing">Healing</option>
                            <option value="mana">Restore Mana</option>
                            <option value="buff">Buff</option>
                            <option value="cure">Cure Condition</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Heal Amount (e.g., 2d4+2)</label>
                        <input type="text" class="form-input" id="potionHealAmount" placeholder="2d4+2">
                    </div>
                </div>

                <!-- Vial-specific fields -->
                <div id="vialFields" style="display: none;">
                    <div class="form-group">
                        <label class="form-label">Damage Amount (e.g., 2d6)</label>
                        <input type="text" class="form-input" id="vialDamageAmount" placeholder="2d6">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Damage Type</label>
                        <select class="form-input" id="vialDamageType">
                            <option value="acid">Acid</option>
                            <option value="fire">Fire</option>
                            <option value="cold">Cold</option>
                            <option value="poison">Poison</option>
                            <option value="radiant">Radiant</option>
                            <option value="necrotic">Necrotic</option>
                            <option value="force">Force</option>
                            <option value="thunder">Thunder</option>
                        </select>
                    </div>
                </div>

                <!-- Armor-specific fields -->
                <div id="armorFields" style="display: none;">
                    <div class="form-group">
                        <label class="form-label">AC Bonus</label>
                        <input type="number" class="form-input" id="armorBonus" value="0">
                    </div>
                </div>

                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeAddItemModal()">Cancel</button>
                    <button type="submit" class="btn btn-success">Add Item</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Use Item Modal -->
    <div class="modal" id="useItemModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Use Item</div>
                <button class="close-btn" onclick="closeUseItemModal()">&times;</button>
            </div>

            <div class="form-group">
                <label class="form-label">Select Item</label>
                <div id="usableItemsList" style="max-height: 300px; overflow-y: auto;">
                    <!-- Will be populated by JS -->
                </div>
            </div>

            <div class="form-group" id="useItemTargetGroup" style="display: none;">
                <label class="form-label">Target</label>
                <div class="target-list" id="useItemTargetList"></div>
            </div>

            <div id="useItemRollSection" style="display: none; margin: 20px 0;">
                <div style="text-align: center;">
                    <div style="font-size: 14px; color: #a5b4fc; margin-bottom: 10px;">
                        <span id="useItemRollLabel">Effect</span>: <span id="useItemDiceNotation">-</span>
                    </div>
                    <button type="button" class="btn" id="useItemRollButton" onclick="rollItemEffect()" style="margin-bottom: 15px;">
                         Roll Effect
                    </button>
                </div>
            </div>

            <div id="useItemResult" style="display: none;">
                <div class="roll-display">
                    <div style="font-size: 14px; color: #a5b4fc; margin-bottom: 5px;"><span id="useItemResultLabel">Effect</span> Rolled</div>
                    <div class="roll-result" id="useItemEffectTotal">-</div>
                    <div class="roll-breakdown" id="useItemEffectBreakdown">-</div>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Action Type</label>
                <div class="action-type-selector">
                    <label class="action-type-option selected" onclick="selectActionType('action')">
                        <input type="radio" name="useItemActionType" value="action" checked> Action
                    </label>
                    <label class="action-type-option" onclick="selectActionType('bonus')">
                        <input type="radio" name="useItemActionType" value="bonus"> Bonus Action
                    </label>
                </div>
            </div>

            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeUseItemModal()">Cancel</button>
                <button type="button" class="btn btn-success" onclick="submitUseItem()">Use Item</button>
            </div>
        </div>
    </div>

    <!-- Add NPC Item Modal -->
    <div class="modal" id="addNPCItemModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <div class="modal-title">Add Item to NPC</div>
                <button class="close-btn" onclick="closeAddNPCItemModal()">&times;</button>
            </div>

            <form id="addNPCItemForm" onsubmit="event.preventDefault(); submitAddNPCItem();">
                <div class="form-group">
                    <label class="form-label">Item Type</label>
                    <select class="form-input" id="npcItemType" onchange="handleNPCItemTypeChange()">
                        <option value="weapon">Weapon</option>
                        <option value="armor">Armor</option>
                        <option value="shield">Shield</option>
                        <option value="potion">Potion</option>
                        <option value="consumable">Consumable</option>
                        <option value="tool">Tools & Kits</option>
                        <option value="gear">Gear</option>
                        <option value="pack">Pack</option>
                        <option value="focus">Focus / Holy Symbol</option>
                        <option value="ammo">Ammunition</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label">Select Item</label>
                    <select class="form-input" id="npcItemNameSelect" onchange="handleNPCItemSelection()">
                        <!-- Populated by JavaScript -->
                    </select>
                </div>

                <div class="form-group" id="npcCustomItemNameGroup" style="display: none;">
                    <label class="form-label">Custom Item Name</label>
                    <input type="text" class="form-input" id="npcItemCustomName" placeholder="Enter custom item name">
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Quantity</label>
                        <input type="number" class="form-input" id="npcItemQuantity" value="1" min="1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" id="npcItemEquipped" style="margin-right: 8px;">
                            Equip this item
                        </label>
                    </div>
                </div>

                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeAddNPCItemModal()">Cancel</button>
                    <button type="submit" class="btn">Add Item</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Combat Result Modal -->
    <div class="modal" id="combatResultModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header" id="combatResultHeader" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                <div class="modal-title" id="combatResultTitle">Attack Result</div>
            </div>

            <div style="padding: 30px; text-align: center;">
                <div id="combatResultIcon" style="font-size: 72px; margin-bottom: 20px;"></div>
                <div id="combatResultMessage" style="font-size: 24px; font-weight: 700; margin-bottom: 20px; color: #fff;"></div>
                <div id="combatResultDetails" style="font-size: 16px; color: #94a3b8; line-height: 1.8;"></div>
            </div>

            <div class="modal-actions">
                <button type="button" class="btn" onclick="closeCombatResultModal()">Continue</button>
            </div>
        </div>
    </div>

    <!-- Themed Alert Modal -->
    <div class="modal" id="themedAlertModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <div class="modal-title" id="themedAlertTitle">Notice</div>
            </div>

            <div style="padding: 20px 0;">
                <div id="themedAlertMessage" style="font-size: 16px; color: #e0e6ff; line-height: 1.6;"></div>
            </div>

            <div class="modal-actions">
                <button type="button" class="btn" onclick="closeThemedAlert()">OK</button>
            </div>
        </div>
    </div>

    <!-- Rest Modal -->
    <div class="modal" id="restModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <div class="modal-title">Take a Rest</div>
                <button class="close-btn" onclick="closeRestModal()">&times;</button>
            </div>

            <div style="padding: 20px 0;">
                <div style="margin-bottom: 20px; color: #94a3b8; font-size: 14px; line-height: 1.6;">
                    Choose the type of rest to take. Resting will restore health and resources.
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <!-- Short Rest Card -->
                    <div onclick="selectRestType('short')" style="cursor: pointer; padding: 20px; background: rgba(59, 130, 246, 0.1); border: 2px solid #3b82f6; border-radius: 8px; transition: all 0.2s;" onmouseover="this.style.background='rgba(59, 130, 246, 0.2)'" onmouseout="this.style.background='rgba(59, 130, 246, 0.1)'">
                        <div style="font-size: 24px; margin-bottom: 10px;"></div>
                        <div style="font-weight: 600; color: #3b82f6; margin-bottom: 8px; font-size: 16px;">Short Rest</div>
                        <div style="font-size: 12px; color: #94a3b8; line-height: 1.5;">
                             Restore 50% HP<br>
                             Brief respite<br>
                             ~1 hour rest
                        </div>
                    </div>

                    <!-- Long Rest Card -->
                    <div onclick="selectRestType('long')" style="cursor: pointer; padding: 20px; background: rgba(16, 185, 129, 0.1); border: 2px solid #10b981; border-radius: 8px; transition: all 0.2s;" onmouseover="this.style.background='rgba(16, 185, 129, 0.2)'" onmouseout="this.style.background='rgba(16, 185, 129, 0.1)'">
                        <div style="font-size: 24px; margin-bottom: 10px;"></div>
                        <div style="font-weight: 600; color: #10b981; margin-bottom: 8px; font-size: 16px;">Long Rest</div>
                        <div style="font-size: 12px; color: #94a3b8; line-height: 1.5;">
                             Restore 100% HP<br>
                             Full recovery<br>
                             ~8 hours rest
                        </div>
                    </div>
                </div>

                <div id="restSummary" style="display: none; margin-top: 20px; padding: 15px; background: rgba(168, 85, 247, 0.1); border-left: 3px solid #a855f7; border-radius: 4px;">
                    <div style="font-weight: 600; color: #a855f7; margin-bottom: 8px;">Rest Results:</div>
                    <div id="restSummaryContent" style="font-size: 14px; color: #e0e6ff;"></div>
                </div>
            </div>

            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeRestModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Combat Summary Modal -->
    <div class="modal" id="combatSummaryModal">
        <div class="modal-content" style="max-width: 860px;">
            <div class="modal-header">
                <div class="modal-title">Combat Summary</div>
                <button class="close-btn" onclick="closeCombatSummaryModal()">&times;</button>
            </div>
            <div style="padding: 20px 0;">
                <div class="summary-overview">
                    <div class="summary-stat-card">
                        <div class="summary-stat-label">Rounds</div>
                        <div class="summary-stat-value" id="combatSummaryRounds">-</div>
                    </div>
                    <div class="summary-stat-card">
                        <div class="summary-stat-label">Duration</div>
                        <div class="summary-stat-value" id="combatSummaryDuration">-</div>
                    </div>
                    <div class="summary-stat-card">
                        <div class="summary-stat-label">Participants</div>
                        <div class="summary-stat-value" id="combatSummaryParticipants">-</div>
                    </div>
                    <div class="summary-stat-card">
                        <div class="summary-stat-label">Enemies Defeated</div>
                        <div class="summary-stat-value" id="combatSummaryDefeated">-</div>
                    </div>
                </div>

                <div class="summary-highlights" id="combatSummaryHighlights"></div>

                <div class="summary-table-wrapper">
                    <table class="summary-table">
                        <thead>
                            <tr>
                                <th>Player</th>
                                <th>Damage</th>
                                <th>Healing</th>
                                <th>Hits</th>
                                <th>Misses</th>
                                <th>Accuracy</th>
                                <th>Defeats</th>
                            </tr>
                        </thead>
                        <tbody id="combatSummaryTableBody">
                            <tr>
                                <td colspan="7" class="summary-empty-state">No combat data recorded.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="modal-actions">
                <button type="button" class="btn" onclick="closeCombatSummaryModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Conditions Modal -->
    <div class="modal" id="conditionsModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <div class="modal-title">Manage Conditions</div>
                <button class="close-btn" onclick="closeConditionsModal()">&times;</button>
            </div>

            <div style="padding: 20px 0;">
                <div style="margin-bottom: 20px; color: #94a3b8; font-size: 14px;">
                    Click to toggle conditions. Active conditions appear on the character card.
                </div>

                <div id="conditionsList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                    <!-- Conditions will be populated here -->
                </div>

                <div id="activeConditionsSummary" style="margin-top: 20px; padding: 15px; background: rgba(168, 85, 247, 0.1); border-left: 3px solid #a855f7; border-radius: 4px; display: none;">
                    <div style="font-weight: 600; color: #a855f7; margin-bottom: 8px;">Active Conditions:</div>
                    <div id="activeConditionsContent" style="font-size: 14px; color: #e0e6ff;"></div>
                </div>
            </div>

        <div class="modal-actions">
            <button type="button" class="btn" onclick="closeConditionsModal()">Done</button>
        </div>
    </div>
</div>

<div class="dice-modal" id="diceRollerModal" aria-hidden="true">
    <div class="dice-modal-content">
        <div class="dice-modal-header">
            <div>
                <div class="dice-modal-title" id="diceModalTitle">Roll</div>
                <div class="dice-modal-subtitle" id="diceModalSubtitle">Modifier +0</div>
            </div>
            <button class="dice-modal-close" onclick="closeDiceRollerModal()" aria-label="Close">&times;</button>
        </div>
        <div class="dice-container">
            <div class="dice" id="modalDiceDisplay" data-dice-display>?</div>
        </div>
        <div class="dice-result" id="modalDiceResult" data-dice-result>Waiting for a roll...</div>
        <div class="dice-modal-info">
            <div>
                <div class="dice-modal-label">Roll</div>
                <div class="dice-modal-value" id="diceModalRollValue"></div>
            </div>
            <div>
                <div class="dice-modal-label">Modifier</div>
                <div class="dice-modal-value" id="diceModalModifierValue"></div>
            </div>
            <div>
                <div class="dice-modal-label">Total</div>
                <div class="dice-modal-value" id="diceModalTotalValue"></div>
            </div>
        </div>
        <div class="modal-actions" style="margin-top: 12px;">
            <button type="button" class="btn btn-primary" onclick="closeDiceRollerModal()">Apply</button>
        </div>
    </div>
</div>

<div class="critical-effect" id="criticalEffect">
    <div class="critical-icon" id="criticalEffectIcon"></div>
    <div class="critical-text" id="criticalEffectText">Critical Success!</div>
</div>

    <div id="levelUpModal" class="levelup-modal">
        <div class="levelup-modal-card">
            <div class="levelup-modal-header">
                <div class="levelup-modal-title">Level Up</div>
                <button class="levelup-modal-close" onclick="closeLevelUpModal()">&times;</button>
            </div>
            <div id="levelUpModalBody"></div>
            <div class="levelup-actions">
                <button class="btn btn-secondary" onclick="closeLevelUpModal()">Cancel</button>
                <button class="btn btn-primary" id="levelUpApplyBtn" onclick="applyLevelUp()">Apply Level Up</button>
            </div>
        </div>
    </div>

    <script src="damage-types.js"></script>
    <script src="spell-data.js"></script>
    <script src="equipment-catalog.js"></script>
<script>
        let currentUser = null;
        let campaignId = null;
        let campaign = null;
        let userRole = null;
        let npcs = [];
        let campaignPlayers = [];
        let activeEncounter = null;
        let pollInterval = null;
        let editingNPCId = null;
        let playerCharacter = null;
        let levelUpContext = null;
        let selectedDiceSides = 20;
        let rollHistory = [];
        let playerInitiativeRoll = null;
        let playerInitiativeMod = 0;
        let initiativeBonusOverride = 0;
        let criticalEffectTimeout = null;
        let lastCombatSync = 0;
        let liveSyncInterval = null;
        let lastSummaryEncounterId = null;
        let summarySeenStorageKey = null;
        let campaignQuests = [];
        let questEventsSource = null;
        let questStreamConnected = false;
        let questPopupQueue = [];
        let questPopupVisible = false;
        let seenQuestIds = new Set();
        let diceLogEntries = [];
        let diceLogInterval = null;
        const classLevelInfoCache = {};
        const spellcastingConfigCache = {};
        const rageTrackerState = {};
        const barbarianHelperConfig = {};
        const deathSaveStateCache = {};
        let lastTurnActorKey = null;
        let deathSaveRolledThisTurn = false;

        // Combat action modal state
        let currentActorId = null;
        let currentActorType = null;
        let currentActorName = null;
        let currentAttackActorData = null;
        let attackRollResult = null;
        let damageRollResult = null;
        let spellEffectRollResult = null;
        let selectedSpellId = null;
        let selectedSpellEffect = null;
        let forcePlayerSpellSelection = false;
        let selectedTargetId = null;
        let selectedTargetType = null;
        let toolsPopupWindow = null;

        const SPELL_INDEX = (() => {
            if (typeof SPELL_LIST === 'undefined') {
                return {};
            }
            const map = {};
            SPELL_LIST.forEach(spell => {
                if (spell?.id) {
                    map[spell.id] = spell;
                }
            });
            return map;
        })();
        const SPELL_NAME_INDEX = (() => {
            if (typeof SPELL_LIST === 'undefined') {
                return {};
            }
            const map = {};
            SPELL_LIST.forEach(spell => {
                if (spell?.name) {
                    map[spell.name.toLowerCase()] = spell;
                }
            });
            return map;
        })();
        const SPELL_EFFECT_OVERRIDES = {
            'magic-missile': {
                type: 'damage',
                dice: '1d4+1',
                damageType: 'force',
                instances: 3,
                perInstanceRoll: true,
                instanceLabel: 'Dart',
                autoMultiTarget: true
            }
        };

        function getSpellDataByName(name) {
            if (!name) return null;
            return SPELL_NAME_INDEX[name.trim().toLowerCase()] || null;
        }

        const FALLBACK_DAMAGE_TYPES = [
            { id: 'acid', label: 'Acid' },
            { id: 'bludgeoning', label: 'Bludgeoning' },
            { id: 'cold', label: 'Cold' },
            { id: 'fire', label: 'Fire' },
            { id: 'force', label: 'Force' },
            { id: 'lightning', label: 'Lightning' },
            { id: 'necrotic', label: 'Necrotic' },
            { id: 'piercing', label: 'Piercing' },
            { id: 'poison', label: 'Poison' },
            { id: 'psychic', label: 'Psychic' },
            { id: 'radiant', label: 'Radiant' },
            { id: 'slashing', label: 'Slashing' },
            { id: 'thunder', label: 'Thunder' }
        ];
        const DAMAGE_TYPE_CHOICES = Array.isArray(window.DAMAGE_TYPES) && window.DAMAGE_TYPES.length
            ? window.DAMAGE_TYPES
            : FALLBACK_DAMAGE_TYPES;

        function normalizeDamageTypeClient(value) {
            if (typeof window.normalizeDamageTypeId === 'function') {
                return window.normalizeDamageTypeId(value);
            }
            if (!value && value !== 0) return '';
            return String(value).trim().toLowerCase();
        }

        function getDamageTypeDisplayLabel(value) {
            if (typeof window.getDamageTypeLabel === 'function') {
                return window.getDamageTypeLabel(value);
            }
            const normalized = normalizeDamageTypeClient(value);
            const match = DAMAGE_TYPE_CHOICES.find(type => type.id === normalized);
            if (match) return match.label;
            if (!normalized) return '';
            return normalized.charAt(0).toUpperCase() + normalized.slice(1);
        }

        function renderDamageTypeChips(containerId, selectedValues = []) {
            const container = document.getElementById(containerId);
            if (!container) return;
            const normalizedSelected = (selectedValues || []).map(value => normalizeDamageTypeClient(value));
            const chips = DAMAGE_TYPE_CHOICES.map(type => {
                const isChecked = normalizedSelected.includes(type.id) ? 'checked' : '';
                return `
                    <label class="resistance-chip">
                        <input type="checkbox" value="${type.id}" ${isChecked}>
                        ${type.label}
                    </label>
                `;
            }).join('');
            container.innerHTML = chips || '<div style="color: #94a3b8;">No damage types configured.</div>';
        }

        function getSelectedDamageTypes(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return [];
            return Array.from(container.querySelectorAll('input[type="checkbox"]:checked'))
                .map(input => normalizeDamageTypeClient(input.value))
                .filter(Boolean);
        }

        function renderDamageTypePills(values, heading) {
            const list = Array.isArray(values)
                ? values
                : (typeof values === 'string' && values.trim()
                    ? values.split(/[,;]+/).map(token => token.trim())
                    : []);
            const normalized = [...new Set(list.map(value => normalizeDamageTypeClient(value)).filter(Boolean))];
            if (!normalized.length) return '';
            const title = heading
                ? `<div style="font-size: 12px; color: #94a3b8; margin-bottom: 4px;">${escapeHtml(heading)}</div>`
                : '';
            return `
                <div class="resistance-pill-container">
                    ${title}
                    ${normalized.map(type => `<span class="resistance-pill">${getDamageTypeDisplayLabel(type)}</span>`).join('')}
                </div>
            `;
        }

        function populateDamageTypeSelect(selectId, { includeBlank = true } = {}) {
            const select = document.getElementById(selectId);
            if (!select) return;
            const options = DAMAGE_TYPE_CHOICES
                .map(type => `<option value="${type.id}">${type.label}</option>`)
                .join('');
            select.innerHTML = includeBlank
                ? `<option value="">Select damage type...</option>${options}`
                : options;
        }

        function setDamageTypeSelectValue(selectId, value) {
            const select = document.getElementById(selectId);
            if (!select) return;
            const normalized = normalizeDamageTypeClient(value);
            const hasValue = !!DAMAGE_TYPE_CHOICES.find(type => type.id === normalized);
            select.value = hasValue ? normalized : '';
        }

        const EQUIPMENT_GROUPS = window.getEquipmentCatalogGroups ? window.getEquipmentCatalogGroups() : {};
        const BASE_CATALOG_GROUP_ORDER = ['weapon', 'armor', 'shield', 'potion', 'consumable', 'tool', 'gear', 'pack', 'focus', 'ammo', 'mount', 'vehicle'];
        const CATALOG_GROUP_ORDER = [...BASE_CATALOG_GROUP_ORDER, ...Object.keys(EQUIPMENT_GROUPS)
            .filter(group => !BASE_CATALOG_GROUP_ORDER.includes(group))
            .sort()];
        const CUSTOM_OPTION_VALUE = '__custom__';
        const SKILL_LABELS = {
            acrobatics: 'Acrobatics',
            animalhandling: 'Animal Handling',
            arcana: 'Arcana',
            athletics: 'Athletics',
            deception: 'Deception',
            history: 'History',
            insight: 'Insight',
            intimidation: 'Intimidation',
            investigation: 'Investigation',
            medicine: 'Medicine',
            nature: 'Nature',
            perception: 'Perception',
            performance: 'Performance',
            persuasion: 'Persuasion',
            religion: 'Religion',
            sleightofhand: 'Sleight of Hand',
            stealth: 'Stealth',
            survival: 'Survival'
        };
        const CLASS_HIT_DICE = {
            barbarian: 12,
            bard: 8,
            cleric: 8,
            druid: 8,
            fighter: 10,
            monk: 8,
            paladin: 10,
            ranger: 10,
            rogue: 8,
            sorcerer: 6,
            warlock: 8,
            wizard: 6
        };

        const RACE_LEVEL_NOTES = {
            'tiefling': {
                3: 'Infernal Legacy lets you cast hellish rebuke (2nd level) once per long rest.',
                5: 'Infernal Legacy unlocks the darkness spell once per long rest.'
            },
            'dragonborn': {
                6: 'Breath weapon damage increases to 3d6 (DNDOPEN dragonborn traits).',
                11: 'Breath weapon damage increases to 4d6.',
                16: 'Breath weapon damage increases to 5d6.'
            },
            'hill dwarf': {
                every: 'Hill Dwarf  Dwarven Toughness adds +1 HP whenever you gain a level.'
            }
        };

        const ABILITY_LABELS = {
            strength: 'Strength',
            dexterity: 'Dexterity',
            constitution: 'Constitution',
            intelligence: 'Intelligence',
            wisdom: 'Wisdom',
            charisma: 'Charisma'
        };

        // Check authentication
        function checkAuth() {
            const userStr = localStorage.getItem('user');
            if (!userStr) {
                window.location.href = '/login.html';
                return null;
            }
            return JSON.parse(userStr);
        }

        // Get campaign ID from URL
        const urlParams = new URLSearchParams(window.location.search);
        campaignId = parseInt(urlParams.get('id'));
        const isToolsPopup = urlParams.get('toolsPopup') === '1';

        if (!campaignId) {
            showError('No campaign ID provided');
        }
        summarySeenStorageKey = campaignId ? `campaign_${campaignId}_lastSummary` : null;
        if (summarySeenStorageKey) {
            lastSummaryEncounterId = localStorage.getItem(summarySeenStorageKey);
        }

        // Load campaign data
        async function loadCampaign() {
            try {
                const response = await fetch(`/campaigns/${campaignId}`);
                const data = await response.json();

                if (data.success) {
                    campaign = data.campaign;
                    determineRole();
                    renderCampaign();
                } else {
                    showError(data.error || 'Campaign not found');
                }
            } catch (error) {
                console.error('Error loading campaign:', error);
                showError('Failed to load campaign');
            }
        }

        // Determine user role in campaign
        function determineRole() {
            if (campaign.dmUserId === currentUser.id) {
                userRole = 'dm';
            } else if (campaign.players.includes(currentUser.id)) {
                userRole = 'player';
            } else {
                showError('You are not part of this campaign');
            }
        }

        // Render campaign based on role
        async function renderCampaign() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('campaignTitle').textContent = campaign.name;

            const roleBadge = document.getElementById('roleBadge');
            roleBadge.textContent = userRole === 'dm' ? 'Dungeon Master' : 'Player';
            roleBadge.className = `role-badge ${userRole}`;

            if (userRole === 'dm') {
                await renderDMView();
                connectQuestStream();
                startPolling();
            } else {
                loadSeenQuests();
                await renderPlayerView();
                connectQuestStream();
                startPolling();
            }
        }

        // Render DM View
        async function renderDMView() {
            document.getElementById('dmView').classList.add('active');

            // Campaign Info
            const infoHtml = `
                <div class="info-card">
                    <div class="info-label">Campaign Code</div>
                    <div class="info-value">${campaign.code || 'N/A'}</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Total Players</div>
                    <div class="info-value">${campaign.players.length}</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Created</div>
                    <div class="info-value">${new Date(campaign.created).toLocaleDateString()}</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Max Players</div>
                    <div class="info-value">${campaign.maxPlayers || 'Unlimited'}</div>
                </div>
            `;
            document.getElementById('campaignInfo').innerHTML = infoHtml;

            // Load players and their characters
            await loadPlayers();
            await loadNPCs();
            await fetchQuests();
            startDiceLogPolling();
        }

        // Load all players in the campaign
        async function loadPlayers() {
            try {
                campaignPlayers = [];
                const playersHtml = await Promise.all(campaign.players.map(async (playerId) => {
                    try {
                        const charResponse = await fetch(`/player/campaign/${campaignId}/user/${playerId}`);
                        const charData = await charResponse.json();

                        if (charData.success && charData.player) {
                            const char = charData.player;
                            char.userId = playerId;
                            char.maxHp = char.maxHp || char.hp || 0;
                            char.currentHp = char.currentHp ?? char.hp ?? 0;
                            await ensureBarbarianConfig(char);
                            campaignPlayers.push(char);
                            const currentHP = char.currentHp ?? char.hp ?? 0;
                            const resistanceHtml = [
                                renderDamageTypePills(char.resistances || [], 'Resistances'),
                                renderDamageTypePills(char.immunities || [], 'Immunities'),
                                renderDamageTypePills(char.vulnerabilities || [], 'Vulnerabilities')
                            ].filter(Boolean).join('');
                            const maxHP = char.maxHp ?? char.hp ?? 0;
                            const pendingLevel = char.pendingLevelUp && char.pendingLevelUp.targetLevel > char.level;
                            const levelBadge = pendingLevel
                                ? `<div class="player-status-badge">Level ${char.pendingLevelUp.targetLevel} pending</div>`
                                : '';
                            const disableLevelButton = pendingLevel || (char.level >= 20);
                            return `
                                <div class="player-card">
                                    <div class="player-header">
                                        <div class="player-avatar">
                                            ${char.profileImage ?
                                                `<img src="${char.profileImage}" alt="${char.name}">` :
                                                `<div class="player-avatar-placeholder"></div>`
                                            }
                                        </div>
                                        <div>
                                            <div class="player-name">${char.name}</div>
                                            <div class="player-class">${char.class} - Level ${char.level}</div>
                                        </div>
                                    </div>
                                    <div class="player-stats">
                                        <div class="stat-item">
                                            <div class="stat-label">HP</div>
                                            <div class="stat-value" id="playerHp-${char.id}">${currentHP} / ${maxHP}</div>
                                        </div>
                                        <div class="stat-item">
                                            <div class="stat-label">AC</div>
                                            <div class="stat-value">${char.ac || 0}</div>
                                        </div>
                                        <div class="stat-item">
                                            <div class="stat-label">Speed</div>
                                            <div class="stat-value">${char.speed || 0}</div>
                                        </div>
                                    </div>
                                    <div class="player-actions">
                                        <button class="btn btn-small btn-warning" onclick="requestLevelUp(${char.id}, ${playerId}, ${char.level})" ${disableLevelButton ? 'disabled' : ''}>Request Level Up</button>
                                        <button class="btn btn-small btn-secondary" onclick="triggerPlayerRest(${char.id}, 'short')">Short Rest</button>
                                        <button class="btn btn-small btn-success" onclick="triggerPlayerRest(${char.id}, 'long')">Long Rest</button>
                                    </div>
                                    ${levelBadge}
                                    <div class="player-rest-summary" id="playerRestSummary-${char.id}"></div>
                                    ${resistanceHtml || ''}
                                </div>
                            `;
                        } else {
                            return `
                                <div class="player-card">
                                    <div class="player-name">Player ${playerId}</div>
                                    <div class="player-class">No character created yet</div>
                                </div>
                            `;
                        }
                    } catch (error) {
                        console.error('Error loading player:', playerId, error);
                        return '';
                    }
                }));

                document.getElementById('playersList').innerHTML = playersHtml.join('');
            } catch (error) {
                console.error('Error loading players:', error);
            }
        }

        async function requestLevelUp(characterId, playerId, currentLevel) {
            if (!campaign || !currentUser) return;
            const nextLevel = (currentLevel || 0) + 1;
            if (nextLevel > 20) {
                return showThemedAlert('Characters cannot advance beyond level 20.');
            }
            const confirmText = `Request level ${nextLevel} for Player ${playerId}?`;
            if (!confirm(confirmText)) return;

            try {
                const response = await fetch(`/player/${characterId}/request-level`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        campaignId,
                        dmUserId: currentUser.id
                    })
                });

                const data = await response.json();
                if (!data.success) {
                    return showThemedAlert(data.error || 'Unable to request level-up.');
                }

                showLevelToast(`Level ${nextLevel} request sent to Player ${playerId}.`, 'info');
                await loadPlayers();
            } catch (error) {
                console.error('Failed to request level up', error);
                showThemedAlert('Failed to request level-up.');
            }
        }

        // Load NPCs
        async function loadNPCs() {
            try {
                const response = await fetch(`/npc/campaign/${campaignId}`);
                const data = await response.json();

                if (data.success) {
                    npcs = data.npcs || [];
                    renderNPCsList();
                } else {
                    console.error('Failed to load NPCs:', data.error);
                }
            } catch (error) {
                console.error('Error loading NPCs:', error);
            }
        }

        // Render NPCs list
        function renderNPCsList() {
            const npcsList = document.getElementById('npcsList');

            if (npcs.length === 0) {
                npcsList.innerHTML = '<div class="empty-state">No NPCs created yet. Click "Create New NPC" to add one.</div>';
                return;
            }

            const npcsHtml = npcs.map(npc => {
                const stats = npc.stats || {};
                const traitHtml = [
                    renderDamageTypePills(npc.resistances, 'Resistances'),
                    renderDamageTypePills(npc.immunities, 'Immunities'),
                    renderDamageTypePills(npc.vulnerabilities, 'Vulnerabilities')
                ].filter(Boolean).join('');
                return `
                    <div class="npc-card">
                        <div class="npc-header">
                            <div>
                                <div class="npc-name">${npc.name}</div>
                                <div class="npc-type">${npc.type || 'Unknown Type'}</div>
                            </div>
                            <div class="npc-actions">
                                <button class="btn btn-small btn-secondary" onclick="editNPC(${npc.id})">Edit</button>
                                <button class="btn btn-small btn-danger" onclick="deleteNPC(${npc.id})">Delete</button>
                            </div>
                        </div>
                        <div class="npc-stats-grid">
                            <div class="npc-stat">
                                <div class="npc-stat-label">HP</div>
                                <div class="npc-stat-value">${npc.currentHp ?? npc.hp}/${npc.maxHp ?? npc.maxHP ?? npc.hp}</div>
                            </div>
                            <div class="npc-stat">
                                <div class="npc-stat-label">AC</div>
                                <div class="npc-stat-value">${npc.ac}</div>
                            </div>
                            <div class="npc-stat">
                                <div class="npc-stat-label">STR</div>
                                <div class="npc-stat-value">${stats.strength || 10}</div>
                            </div>
                            <div class="npc-stat">
                                <div class="npc-stat-label">DEX</div>
                                <div class="npc-stat-value">${stats.dexterity || 10}</div>
                            </div>
                            <div class="npc-stat">
                                <div class="npc-stat-label">CON</div>
                                <div class="npc-stat-value">${stats.constitution || 10}</div>
                            </div>
                            <div class="npc-stat">
                                <div class="npc-stat-label">INT</div>
                                <div class="npc-stat-value">${stats.intelligence || 10}</div>
                            </div>
                            <div class="npc-stat">
                                <div class="npc-stat-label">WIS</div>
                                <div class="npc-stat-value">${stats.wisdom || 10}</div>
                            </div>
                            <div class="npc-stat">
                                <div class="npc-stat-label">CHA</div>
                                <div class="npc-stat-value">${stats.charisma || 10}</div>
                            </div>
                        </div>
                        ${traitHtml || ''}
                    </div>
                `;
            }).join('');

            npcsList.innerHTML = npcsHtml;
        }

        // Create NPC
        function createNPC() {
            editingNPCId = null;
            currentNPCInventory = [];
            document.getElementById('npcModalTitle').textContent = 'Create NPC';
            document.getElementById('npcForm').reset();
            document.getElementById('npcId').value = '';
            renderDamageTypeChips('npcResistanceOptions', []);
            renderDamageTypeChips('npcImmunityOptions', []);
            renderDamageTypeChips('npcVulnerabilityOptions', []);
            renderNPCInventory();
            document.getElementById('npcModal').classList.add('active');
        }

        // Edit NPC
        function editNPC(id) {
            const npc = npcs.find(n => n.id === id);
            if (!npc) return;

            editingNPCId = id;
            currentNPCInventory = npc.inventory || [];
            document.getElementById('npcModalTitle').textContent = 'Edit NPC';
            document.getElementById('npcId').value = id;
            document.getElementById('npcName').value = npc.name;
            document.getElementById('npcType').value = npc.type || '';
            document.getElementById('npcHP').value = npc.hp;
            document.getElementById('npcMaxHP').value = npc.maxHp || npc.maxHP || npc.hp; // Handle both cases, fallback to hp
            document.getElementById('npcAC').value = npc.ac;

            const stats = npc.stats || {};
            document.getElementById('npcSTR').value = stats.strength || 10;
            document.getElementById('npcDEX').value = stats.dexterity || 10;
            document.getElementById('npcCON').value = stats.constitution || 10;
            document.getElementById('npcINT').value = stats.intelligence || 10;
            document.getElementById('npcWIS').value = stats.wisdom || 10;
            document.getElementById('npcCHA').value = stats.charisma || 10;
            renderDamageTypeChips('npcResistanceOptions', npc.resistances || []);
            renderDamageTypeChips('npcImmunityOptions', npc.immunities || []);
            renderDamageTypeChips('npcVulnerabilityOptions', npc.vulnerabilities || []);

            renderNPCInventory();
            document.getElementById('npcModal').classList.add('active');
        }

        // Save NPC
        async function saveNPC(event) {
            event.preventDefault();

            const npcData = {
                name: document.getElementById('npcName').value,
                type: document.getElementById('npcType').value,
                hp: parseInt(document.getElementById('npcHP').value),
                maxHp: parseInt(document.getElementById('npcMaxHP').value), // Use lowercase maxHp
                ac: parseInt(document.getElementById('npcAC').value),
                stats: {
                    strength: parseInt(document.getElementById('npcSTR').value),
                    dexterity: parseInt(document.getElementById('npcDEX').value),
                    constitution: parseInt(document.getElementById('npcCON').value),
                    intelligence: parseInt(document.getElementById('npcINT').value),
                    wisdom: parseInt(document.getElementById('npcWIS').value),
                    charisma: parseInt(document.getElementById('npcCHA').value)
                },
                resistances: getSelectedDamageTypes('npcResistanceOptions'),
                immunities: getSelectedDamageTypes('npcImmunityOptions'),
                vulnerabilities: getSelectedDamageTypes('npcVulnerabilityOptions'),
                inventory: currentNPCInventory,
                campaignId: campaignId
            };

            try {
                const url = editingNPCId ? `/npc/${editingNPCId}` : '/npc';
                const method = editingNPCId ? 'PUT' : 'POST';

                const response = await fetch(url, {
                    method: method,
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(npcData)
                });

                const data = await response.json();

                if (data.success) {
                    closeNPCModal();
                    await loadNPCs();
                } else {
                    showThemedAlert('Failed to save NPC: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error saving NPC:', error);
                showThemedAlert('Failed to save NPC');
            }
        }

        // Delete NPC
        async function deleteNPC(id) {
            if (!confirm('Are you sure you want to delete this NPC?')) return;

            try {
                const response = await fetch(`/npc/${id}`, { method: 'DELETE' });
                const data = await response.json();

                if (data.success) {
                    await loadNPCs();
                } else {
                    showThemedAlert('Failed to delete NPC: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error deleting NPC:', error);
                showThemedAlert('Failed to delete NPC');
            }
        }

        // Close NPC Modal
        function closeNPCModal() {
            document.getElementById('npcModal').classList.remove('active');
            editingNPCId = null;
        }

        // NPC Inventory Management
        let currentNPCInventory = [];

        function addNPCItem() {
            document.getElementById('addNPCItemModal').classList.add('active');
            handleNPCItemTypeChange();
        }

        function closeAddNPCItemModal() {
            document.getElementById('addNPCItemModal').classList.remove('active');
        }

        function handleNPCItemTypeChange() {
            const type = document.getElementById('npcItemType').value;
            const itemNameSelect = document.getElementById('npcItemNameSelect');
            itemNameSelect.innerHTML = buildCatalogOptionsForType(type);
            document.getElementById('npcCustomItemNameGroup').style.display = 'none';
        }

        function handleNPCItemSelection() {
            const selectedValue = document.getElementById('npcItemNameSelect').value;
            document.getElementById('npcCustomItemNameGroup').style.display = selectedValue === CUSTOM_OPTION_VALUE ? 'block' : 'none';
        }

        function submitAddNPCItem() {
            const type = document.getElementById('npcItemType').value;
            const selectedValue = document.getElementById('npcItemNameSelect').value;
            const quantity = parseInt(document.getElementById('npcItemQuantity').value) || 1;
            const equipped = document.getElementById('npcItemEquipped').checked;
            let item;

            if (selectedValue === CUSTOM_OPTION_VALUE) {
                const name = document.getElementById('npcItemCustomName').value.trim();
                if (!name) return showThemedAlert('Please enter a custom item name');
                item = { name, type, category: type, quantity, equipped, description: '' };
            } else {
                const definition = window.getEquipmentCatalogItem ? window.getEquipmentCatalogItem(selectedValue) : null;
                if (!definition) {
                    showThemedAlert('Unable to load selected item from the catalog.');
                    return;
                }
                item = {
                    catalogId: definition.id,
                    mode: 'catalog',
                    name: definition.name,
                    category: definition.category,
                    subcategory: definition.subcategory || '',
                    type: definition.category,
                    quantity,
                    equipped,
                    description: definition.description || ''
                };
            }

            currentNPCInventory.push(normalizeInventoryEntry(item));
            renderNPCInventory();
            closeAddNPCItemModal();
            document.getElementById('addNPCItemForm').reset();
        }

        function renderNPCInventory() {
            const list = document.getElementById('npcInventoryList');
            const equippedWeapon = currentNPCInventory.find(item => item.type === 'weapon' && item.equipped);
            const equippedArmor = currentNPCInventory.find(item => item.type === 'armor' && item.equipped);

            const weaponDamage = formatDamageString(equippedWeapon);
            const armorValue = equippedArmor
                ? (equippedArmor.acBase || (typeof equippedArmor.acBonus === 'number' ? `+${equippedArmor.acBonus}` : '') || '')
                : '';

            document.getElementById('npcEquippedWeapon').textContent = equippedWeapon
                ? `${equippedWeapon.name}${weaponDamage ? ` (${weaponDamage})` : ''}`
                : 'None';
            document.getElementById('npcEquippedArmor').textContent = equippedArmor
                ? `${equippedArmor.name}${armorValue ? ` (AC ${armorValue})` : ''}`
                : 'None';

            if (currentNPCInventory.length === 0) {
                list.innerHTML = '<div style="color: #94a3b8; text-align: center; padding: 20px;">No items</div>';
                return;
            }

            list.innerHTML = currentNPCInventory.map((item, index) => {
                const category = item.category || item.type || 'gear';
                let icon = '';
                if (category === 'weapon') {
                    icon = '';
                } else if (category === 'armor' || category === 'shield') {
                    icon = '';
                } else if (category === 'potion') {
                    icon = '';
                } else if (category === 'consumable') {
                    icon = '';
                }
                const equippedBadge = item.equipped ? '<span style="background: #10b981; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; margin-left: 6px;">EQUIPPED</span>' : '';
                const equipBtn = (item.type === 'weapon' || item.type === 'armor') ?
                    `<button onclick="toggleNPCItemEquip(${index})" style="background: ${item.equipped ? '#64748b' : '#3b82f6'}; color: white; border: none; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 11px;">${item.equipped ? 'Unequip' : 'Equip'}</button>` : '';
                return `
                    <div style="padding: 8px; border-bottom: 1px solid rgba(148, 163, 184, 0.1); display: flex; align-items: center; justify-content: space-between;">
                        <div><span style="margin-right: 6px;">${icon}</span><span style="color: #fff;">${item.name}</span>${equippedBadge}<span style="color: #94a3b8; font-size: 12px; margin-left: 6px;">x${item.quantity}</span></div>
                        <div style="display: flex; gap: 6px;">${equipBtn}<button onclick="removeNPCItem(${index})" style="background: #ef4444; color: white; border: none; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 11px;">Remove</button></div>
                    </div>
                `;
            }).join('');
        }

        function toggleNPCItemEquip(index) {
            const item = currentNPCInventory[index];
            if (!item.equipped) {
                currentNPCInventory.forEach((itm, idx) => {
                    if (itm.type === item.type && idx !== index) itm.equipped = false;
                });
            }
            item.equipped = !item.equipped;
            renderNPCInventory();
        }

        function removeNPCItem(index) {
            if (confirm('Remove this item?')) {
                currentNPCInventory.splice(index, 1);
                renderNPCInventory();
            }
        }

        // Start Combat - Open Modal
        function startCombat() {
            // Populate the modal with NPCs and Players
            populateStartCombatModal();
            document.getElementById('startCombatModal').classList.add('active');
        }

        // Populate Start Combat Modal
        function populateStartCombatModal() {
            const npcList = document.getElementById('combatNPCList');
            const playerList = document.getElementById('combatPlayerList');

            // Populate NPCs
            if (npcs.length === 0) {
                npcList.innerHTML = '<div style="color: #888; padding: 10px;">No NPCs available</div>';
            } else {
                const npcHtml = npcs.map(npc => {
                    const currentHp = typeof npc.hp === 'number'
                        ? npc.hp
                        : (typeof npc.maxHp === 'number' ? npc.maxHp : 0);
                    const maxHp = typeof npc.maxHp === 'number' ? npc.maxHp : currentHp;
                    const armorClass = typeof npc.ac === 'number' ? npc.ac : 10;

                    return `
                        <div class="participant-checkbox-item">
                            <input type="checkbox" id="npc-${npc.id}" value="${npc.id}" onclick="event.stopPropagation()">
                            <div class="participant-checkbox-label" onclick="toggleCheckbox('npc-${npc.id}')">
                                ${npc.name}
                                <div class="participant-checkbox-details">${npc.type || 'NPC'} - HP: ${currentHp}/${maxHp}, AC: ${armorClass}</div>
                            </div>
                            <div class="hide-toggle" onclick="event.stopPropagation()">
                                <input type="checkbox" id="npc-hide-${npc.id}">
                                <span> Hide</span>
                            </div>
                        </div>
                    `;
                }).join('');
                npcList.innerHTML = npcHtml;
            }

            // Populate Players
            if (campaignPlayers.length === 0) {
                playerList.innerHTML = '<div style="color: #888; padding: 10px;">No players have created characters yet</div>';
            } else {
                const playerHtml = campaignPlayers.map(player => `
                    <div class="participant-checkbox-item">
                        <input type="checkbox" id="player-${player.userId}" value="${player.userId}" checked onclick="event.stopPropagation()">
                        <div class="participant-checkbox-label" onclick="toggleCheckbox('player-${player.userId}')">
                            ${player.name}
                            <div class="participant-checkbox-details">${player.class} Level ${player.level} - HP: ${player.hp}, AC: ${player.ac}</div>
                        </div>
                    </div>
                `).join('');
                playerList.innerHTML = playerHtml;
            }
        }

        // Toggle checkbox helper
        function toggleCheckbox(id) {
            const checkbox = document.getElementById(id);
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
            }
        }

        // Close Start Combat Modal
        function closeStartCombatModal() {
            document.getElementById('startCombatModal').classList.remove('active');
        }

        // Confirm Start Combat
        async function confirmStartCombat() {
            try {
                // Get selected NPCs with hidden status
                const selectedNPCs = npcs.filter(npc => {
                    const checkbox = document.getElementById(`npc-${npc.id}`);
                    return checkbox && checkbox.checked;
                }).map(npc => {
                    const hideCheckbox = document.getElementById(`npc-hide-${npc.id}`);
                    return {
                        ...npc,
                        hidden: hideCheckbox && hideCheckbox.checked
                    };
                });

                // Get selected Players
                const selectedPlayers = campaignPlayers.filter(player => {
                    const checkbox = document.getElementById(`player-${player.userId}`);
                    return checkbox && checkbox.checked;
                });

                // Start the encounter
                const response = await fetch('/encounter/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        campaignId: campaignId,
                        dmUserId: currentUser.id
                    })
                });

                const data = await response.json();

                if (data.success) {
                    const encounterId = data.encounter.id;

                    // Add selected NPCs to combat
                    for (const npc of selectedNPCs) {
                        const dexMod = Math.floor(((npc.stats?.dexterity || 10) - 10) / 2);
                        const initiative = Math.floor(Math.random() * 20) + 1 + dexMod;

                        await fetch(`/encounter/${encounterId}/participant`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                npcId: npc.id,
                                initiative: initiative,
                                hidden: npc.hidden
                            })
                        });
                    }

                    // Close modal and refresh
                    closeStartCombatModal();
                    await pollCombatStatus();
                } else {
                    showThemedAlert('Failed to start combat: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error starting combat:', error);
                showThemedAlert('Failed to start combat');
            }
        }

        // End Combat
        async function endCombat() {
            if (!activeEncounter) return;
            if (!confirm('Are you sure you want to end combat?')) return;

            try {
                const response = await fetch(`/encounter/${activeEncounter.id}/end`, {
                    method: 'POST'
                });

                const data = await response.json();

                if (data.success) {
                    if (data.summary) {
                        showCombatSummary(data.summary);
                    }
                    activeEncounter = null;
                    await pollCombatStatus();
                } else {
                    showThemedAlert('Failed to end combat: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error ending combat:', error);
                showThemedAlert('Failed to end combat');
            }
        }

        // Next Turn
        async function nextTurn() {
            if (!activeEncounter) return;

            try {
                const response = await fetch(`/encounter/${activeEncounter.id}/next-turn`, {
                    method: 'POST'
                });

                const data = await response.json();

                if (data.success) {
                    await pollCombatStatus();
                } else {
                    showThemedAlert('Failed to advance turn: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error advancing turn:', error);
                showThemedAlert('Failed to advance turn');
            }
        }

        // Add NPC to Combat
        async function addNPCToCombat(npcId) {
            if (!activeEncounter) return;

            try {
                const response = await fetch(`/encounter/${activeEncounter.id}/participant`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ npcId: npcId })
                });

                const data = await response.json();

                if (data.success) {
                    document.getElementById('addNPCDropdown').classList.remove('active');
                    await pollCombatStatus();
                } else {
                    showThemedAlert('Failed to add NPC to combat: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error adding NPC to combat:', error);
                showThemedAlert('Failed to add NPC to combat');
            }
        }

        // Toggle Add NPC Dropdown
        function toggleAddNPCDropdown() {
            const dropdown = document.getElementById('addNPCDropdown');
            dropdown.classList.toggle('active');

            if (dropdown.classList.contains('active')) {
                renderAddNPCDropdown();
            }
        }

        // Render Add NPC Dropdown
        function renderAddNPCDropdown() {
            const content = document.getElementById('addNPCDropdownContent');

            if (npcs.length === 0) {
                content.innerHTML = '<div class="dropdown-item" style="color: #888;">No NPCs available</div>';
                return;
            }

            const html = npcs.map(npc => `
                <div class="dropdown-item" onclick="addNPCToCombat(${npc.id})">
                    ${npc.name} (${npc.type || 'NPC'})
                </div>
            `).join('');

            content.innerHTML = html;
        }

        // Update HP Direct (with +/- buttons)
        async function updateHPDirect(participantId, type, change) {
            console.log('updateHPDirect called:', participantId, type, change);

            const inputId = `hp-${type}-${participantId}`;
            console.log('Looking for input with ID:', inputId);

            const input = document.getElementById(inputId);
            if (!input) {
                console.error('Input not found!');
                return;
            }

            const currentHP = parseInt(input.value) || 0;
            const newHP = Math.max(0, currentHP + change);

            console.log('Current HP:', currentHP, 'New HP:', newHP);

            input.value = newHP;

            // Trigger flash animation
            const participantCard = document.querySelector(`.participant-hp[data-actor-id="${participantId}"][data-actor-type="${type}"]`);
            if (participantCard) {
                const flashClass = change < 0 ? 'damage-flash' : 'heal-flash';
                participantCard.classList.add(flashClass);
                setTimeout(() => {
                    participantCard.classList.remove(flashClass);
                }, 500);
            }

            await saveHPChange(participantId, type);
        }

        // Save HP Change
        async function saveHPChange(participantId, type) {
            const input = document.getElementById(`hp-${type}-${participantId}`);
            if (!input || !activeEncounter) return;

            const newHP = parseInt(input.value) || 0;

            console.log('Saving HP change:', participantId, type, newHP);

            try {
                const response = await fetch(`/encounter/${activeEncounter.id}/participant/${participantId}/hp`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ hp: newHP, type: type })
                });

                const data = await response.json();

                if (data.success) {
                    console.log('HP update successful');
                    if (data.encounter) {
                        activeEncounter = data.encounter;
                        syncParticipantsWithPlayers(activeEncounter);
                        updateCombatUI();
                    } else {
                        await pollCombatStatus();
                    }
                    if (type === 'npc') {
                        await loadNPCs();
                    } else {
                        await loadPlayers();
                    }
                } else {
                    console.error('HP update failed:', data.error);
                    showThemedAlert('Failed to update HP: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error updating HP:', error);
                showThemedAlert('Failed to update HP');
            }
        }

        // Poll Combat Status
        async function pollCombatStatus() {
            try {
                const response = await fetch(`/encounter/campaign/${campaignId}/active`);
                const data = await response.json();

                if (data.success && data.encounter) {
                    activeEncounter = data.encounter;
                    const roundValue = activeEncounter.round || activeEncounter.currentRound || 1;
                    activeEncounter.currentRound = roundValue;
                    activeEncounter.round = roundValue;
                    syncParticipantsWithPlayers(activeEncounter);
                    updateCombatUI();
                } else {
                    activeEncounter = null;
                    updateCombatUI();
                    if (data.lastSummary) {
                        maybeShowCombatSummary(data.lastSummary);
                    }
                }
                markCombatSynced();
            } catch (error) {
                console.error('Error polling combat status:', error);
            }
        }

        function markCombatSynced() {
            lastCombatSync = Date.now();
            updateLiveSyncIndicators();
        }

        function updateLiveSyncIndicators() {
            const elapsed = lastCombatSync ? Math.floor((Date.now() - lastCombatSync) / 1000) : null;
            const message = elapsed === null ? 'Waiting for first update...' : (elapsed <= 1 ? 'Live now' : `Updated ${elapsed}s ago`);
            const isStale = elapsed !== null && elapsed > 6;

            const dmText = document.getElementById('combatSyncText');
            const dmDot = document.getElementById('combatSyncDot');
            const playerText = document.getElementById('playerCombatSyncText');
            const playerDot = document.getElementById('playerCombatSyncDot');

            if (dmText) dmText.textContent = message;
            if (playerText) playerText.textContent = message;
            if (dmDot) dmDot.classList.toggle('stale', isStale);
            if (playerDot) playerDot.classList.toggle('stale', isStale);
        }

        function syncParticipantsWithPlayers(encounter) {
            if (!encounter || !Array.isArray(encounter.participants)) return;

            encounter.participants.forEach(participant => {
                if (participant.type === 'player') {
                    const match = campaignPlayers.find(p =>
                        (p.userId && p.userId === participant.id) || p.id === participant.characterId
                    );
                    const updatedHP = participant.currentHp ?? match?.currentHp ?? match?.hp ?? 0;
                    const updatedMax = participant.maxHp ?? match?.maxHp ?? match?.hp ?? 0;

                    if (match) {
                        match.currentHp = updatedHP;
                        match.maxHp = updatedMax || match.maxHp || match.hp || 0;
                        const hpEl = document.getElementById(`playerHp-${match.id}`);
                        if (hpEl) {
                            hpEl.textContent = `${updatedHP} / ${match.maxHp || match.hp || 0}`;
                        }
                    }

                    if (playerCharacter && (playerCharacter.userId === participant.id || playerCharacter.id === participant.characterId)) {
                        const previousHP = playerCharacter.currentHp;
                        playerCharacter.currentHp = updatedHP;
                        playerCharacter.maxHp = updatedMax || playerCharacter.maxHp || playerCharacter.hp;
                        if (previousHP !== updatedHP) {
                            updateGameUI(playerCharacter);
                        }
                    }
                }
            });
        }

        // Update Combat UI
        function updateCombatUI() {
            if (userRole === 'dm') {
                updateDMCombatUI();
            } else {
                updatePlayerCombatUI();
            }
            renderCombatLog();
        }

        // Update DM Combat UI
        function updateDMCombatUI() {
            const status = document.getElementById('combatStatus');
            const pulse = document.getElementById('combatPulse');
            const statusText = document.getElementById('combatStatusText');
            const roundCounter = document.getElementById('roundCounter');
            const startBtn = document.getElementById('startCombatBtn');
            const endBtn = document.getElementById('endCombatBtn');
            const combatContent = document.getElementById('combatContent');

            if (activeEncounter) {
                status.classList.add('active');
                pulse.classList.add('active');
                statusText.textContent = 'Combat Active';
                roundCounter.textContent = `Round ${activeEncounter.currentRound || 1}`;
                startBtn.style.display = 'none';
                endBtn.style.display = 'inline-block';
                combatContent.style.display = 'block';

                renderInitiativeTracker();
                updateEncounterSummaries();
            } else {
                status.classList.remove('active');
                pulse.classList.remove('active');
                statusText.textContent = 'No Active Combat';
                roundCounter.textContent = '';
                startBtn.style.display = 'inline-block';
                endBtn.style.display = 'none';
                combatContent.style.display = 'none';

                updateEncounterSummaries();
            }
        }

        function normalizeId(value) {
            return value === undefined || value === null ? null : String(value);
        }

        function normalizeNpcId(value) {
            const str = normalizeId(value);
            if (!str) return '';
            return str.replace(/^npc[-_]?/i, '');
        }

        function shouldUsePlayerSpellListForActor(actorId, actorType) {
            if (!playerCharacter) return false;
            const actorIdStr = normalizeId(actorId);
            const playerUserId = normalizeId(playerCharacter.userId);
            const playerCharId = normalizeId(playerCharacter.id);
            return actorType === 'player' && (actorIdStr === playerUserId || actorIdStr === playerCharId);
        }

        function getPlayerSpellOptions() {
            if (!playerCharacter?.spells) return [];
            const spellIds = [];
            const order = ['prepared', 'known', 'spellbook', 'cantrips'];
            order.forEach(key => {
                const list = playerCharacter.spells[key];
                if (Array.isArray(list)) {
                    list.forEach(id => {
                        if (id && !spellIds.includes(id)) {
                            spellIds.push(id);
                        }
                    });
                }
            });
            return spellIds
                .map(id => SPELL_INDEX[id])
                .filter(Boolean)
                .sort((a, b) => {
                    if (a.level !== b.level) return a.level - b.level;
                    return a.name.localeCompare(b.name);
                });
        }

        function deriveSpellEffect(spell) {
            if (!spell) return {};

            const effect = {
                type: 'other',
                dice: '',
                damageType: null,
                addAbilityMod: false,
                instances: 1,
                perInstanceRoll: false,
                instanceLabel: null,
                autoMultiTarget: false
            };

            const descRaw = spell.shortDescription || '';
            const desc = descRaw.toLowerCase();
            const customDice = typeof spell.damageDice === 'string' ? spell.damageDice : '';
            const normalizedCustomDice = customDice ? customDice.replace(/\s+/g, '') : '';
            let diceFound = '';
            if (normalizedCustomDice) {
                const customMatch = normalizedCustomDice.match(/(\d+d\d+(?:[+\-]\d+)?)/i);
                diceFound = customMatch ? customMatch[1] : normalizedCustomDice;
            }
            if (!diceFound) {
                const diceMatch = descRaw.match(/(\d+d\d+(?:\s*[+\-]\s*\d+)?)/i);
                diceFound = diceMatch ? diceMatch[1].replace(/\s+/g, '') : '';
            }
            effect.dice = diceFound;

            if (/heal|healing|hit points|restore/.test(desc)) {
                effect.type = 'healing';
            } else if (/damage/.test(desc)) {
                effect.type = 'damage';
            }

            let damageType = null;
            if (typeof spell.damageType === 'string' && spell.damageType) {
                damageType = spell.damageType.toLowerCase();
            } else {
                const typeMatch = descRaw.match(/\b(acid|cold|fire|force|lightning|necrotic|psychic|radiant|thunder|poison)\b/i);
                if (typeMatch) {
                    damageType = typeMatch[1].toLowerCase();
                }
            }
            effect.damageType = damageType;
            effect.addAbilityMod = /modifier|spellcasting ability/i.test(descRaw);

            if (spell.id && SPELL_EFFECT_OVERRIDES[spell.id]) {
                return { ...effect, ...SPELL_EFFECT_OVERRIDES[spell.id] };
            }
            return effect;
        }

        function resolveCurrentSpellEffect(spellNameOverride) {
            if (forcePlayerSpellSelection && selectedSpellEffect) {
                return selectedSpellEffect;
            }
            const lookupName = typeof spellNameOverride === 'string'
                ? spellNameOverride
                : (document.getElementById('spellName')?.value.trim() || '');
            if (!lookupName) return null;
            const spell = getSpellDataByName(lookupName);
            return spell ? deriveSpellEffect(spell) : null;
        }

        function applySpellTargetingDefaults(effect) {
            if (!effect) return;
            const multiTargetCheckbox = document.getElementById('spellMultiTarget');
            if (multiTargetCheckbox && effect.autoMultiTarget && !multiTargetCheckbox.checked) {
                multiTargetCheckbox.checked = true;
                populateTargetList('spellTargetList', true);
            }
            if (effect.damageType) {
                setDamageTypeSelectValue('spellDamageType', effect.damageType);
            }
        }

        function distributeInstanceTotals(targetCount, totals) {
            const allocations = new Array(targetCount).fill(0);
            if (!Array.isArray(totals) || totals.length === 0 || targetCount === 0) {
                return allocations;
            }
            for (let i = 0; i < totals.length; i++) {
                const index = targetCount === 1 ? 0 : i % targetCount;
                allocations[index] += totals[i];
            }
            return allocations;
        }

        function getSpellcastingAbilityModifier() {
            const abilityKey = playerCharacter?.spells?.ability;
            if (!abilityKey || !playerCharacter?.abilities) return 0;
            const score = playerCharacter.abilities[abilityKey.toLowerCase()] ?? playerCharacter.abilities[abilityKey.toUpperCase()];
            if (!score && score !== 0) return 0;
            return Math.floor((score - 10) / 2);
        }

        function setSpellFormLocked(lock) {
            const nameInput = document.getElementById('spellName');
            const levelInput = document.getElementById('spellLevel');
            if (nameInput) {
                nameInput.readOnly = lock;
                nameInput.classList.toggle('readonly', lock);
            }
            if (levelInput) {
                levelInput.readOnly = lock;
                levelInput.classList.toggle('readonly', lock);
            }
        }

        function clearSpellSelection() {
            selectedSpellId = null;
            selectedSpellEffect = null;
            const detailPanel = document.getElementById('spellDetailPanel');
            if (detailPanel) {
                detailPanel.style.display = 'none';
            }
            const helper = document.getElementById('spellSelectionHelper');
            if (helper) helper.textContent = '';
            const list = document.getElementById('spellSelectionList');
            if (list) list.innerHTML = '';
        }

        function renderSpellSelectionList() {
            const section = document.getElementById('spellSelectionSection');
            if (!section) return;

            if (!forcePlayerSpellSelection) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            const container = document.getElementById('spellSelectionList');
            const helper = document.getElementById('spellSelectionHelper');
            if (!container) return;

            const spells = getPlayerSpellOptions();
            if (!spells.length) {
                container.innerHTML = '<div class="empty-state" style="padding: 12px;">No spells recorded for this character.</div>';
                if (helper) helper.textContent = 'Prepare or learn spells on your character sheet to cast them here.';
                selectedSpellId = null;
                selectedSpellEffect = null;
                const detailPanel = document.getElementById('spellDetailPanel');
                if (detailPanel) detailPanel.style.display = 'none';
                return;
            }

            if (helper) helper.textContent = 'Select a spell to auto-fill its damage, healing, and roll.';

            const cards = spells.map(spell => {
                const effect = deriveSpellEffect(spell);
                const safeId = spell.id.replace(/'/g, "\\'");
                const diceLabel = effect.type === 'healing' ? 'Healing' : 'Damage';
                const damageTypeLabel = effect.damageType
                    ? `  ${escapeHtml(effect.damageType.charAt(0).toUpperCase() + effect.damageType.slice(1))}`
                    : '';
                const instanceSuffix = effect.instances && effect.instances > 1
                    ? ` x${effect.instances}`
                    : '';
                const diceInfo = effect.dice
                    ? `<div class="spell-card-dice">${diceLabel} ${escapeHtml(effect.dice)}${instanceSuffix}${damageTypeLabel}</div>`
                    : '';
                return `
                    <div class="spell-card${spell.id === selectedSpellId ? ' active' : ''}" onclick="selectSpellForCasting('${safeId}')">
                        <div class="spell-card-title">${escapeHtml(spell.name)}</div>
                        <div class="spell-card-meta">Level ${spell.level}  ${spell.school}</div>
                        <div class="spell-card-detail">${escapeHtml(spell.shortDescription || 'No description')}</div>
                        ${diceInfo}
                    </div>
                `;
            }).join('');

            container.innerHTML = cards;

            if (!selectedSpellId && spells.length) {
                selectSpellForCasting(spells[0].id, { silent: true });
            }
        }

        function updateSpellDetailPanel(spell, effect) {
            const panel = document.getElementById('spellDetailPanel');
            if (!panel) return;
            if (!spell) {
                panel.style.display = 'none';
                return;
            }

            const meta = `Level ${spell.level}  ${spell.school}  ${spell.castingTime}  ${spell.range}`;
            document.getElementById('spellDetailName').textContent = spell.name;
            document.getElementById('spellDetailMeta').textContent = meta;
            document.getElementById('spellDetailDescription').textContent = spell.shortDescription || '';
            panel.style.display = 'block';

            const diceInput = document.getElementById('spellDice');
            if (diceInput) {
                diceInput.value = effect?.dice || '';
            }

            const spellType = effect?.type || 'other';
            selectSpellType(spellType);
        }

        function selectSpellForCasting(spellId, options = {}) {
            const spell = SPELL_INDEX[spellId];
            if (!spell) return;

            selectedSpellId = spellId;
            selectedSpellEffect = deriveSpellEffect(spell);

            const nameInput = document.getElementById('spellName');
            const levelInput = document.getElementById('spellLevel');
            if (nameInput) nameInput.value = spell.name;
            if (levelInput) levelInput.value = spell.level;

            updateSpellDetailPanel(spell, selectedSpellEffect);
            setDamageTypeSelectValue('spellDamageType', selectedSpellEffect?.damageType || '');
            applySpellTargetingDefaults(selectedSpellEffect);

            if (!options.silent) {
                renderSpellSelectionList();
            }
        }

        function getParticipantDisplay(participant) {
            if (!participant) {
                return { name: '', typeLabel: '', entity: null, hp: 0, maxHp: 0, isDefeated: false };
            }

            let name = participant.displayName || participant.characterName || participant.playerName || 'Unknown';
            let typeLabel = participant.type === 'npc' ? 'NPC' : 'Adventurer';
            let entity = null;
            let hp = typeof participant.currentHp === 'number' ? participant.currentHp : Number(participant.currentHp);
            if (Number.isNaN(hp)) hp = null;
            let maxHp = typeof participant.maxHp === 'number' ? participant.maxHp : Number(participant.maxHp);
            if (Number.isNaN(maxHp)) maxHp = undefined;

            if (participant.type === 'npc') {
                const targetId = normalizeNpcId(participant.id ?? participant.npcId);
                entity = npcs.find(npc => normalizeNpcId(npc.id) === targetId);
                if (entity) {
                    name = entity.name || name;
                    typeLabel = entity.type || typeLabel;
                    if (hp === null) {
                        hp = typeof participant.currentHp === 'number'
                            ? participant.currentHp
                            : (entity.currentHp ?? entity.hp ?? 0);
                    }
                    if (maxHp === undefined) {
                        maxHp = entity.maxHp || entity.maxHP || entity.hp || hp || 0;
                    }
                }
            } else if (participant.type === 'player') {
                const participantUserId = normalizeId(participant.id ?? participant.userId);
                const participantCharacterId = normalizeId(participant.characterId);

                entity = campaignPlayers.find(pl => {
                    const matchesUser = participantUserId && normalizeId(pl.userId) === participantUserId;
                    const matchesCharacter = participantCharacterId && normalizeId(pl.id) === participantCharacterId;
                    return matchesUser || matchesCharacter;
                });

                if (entity) {
                    name = entity.name || name;
                    typeLabel = entity.class || typeLabel;
                    if (hp === null) {
                        hp = typeof participant.currentHp === 'number'
                            ? participant.currentHp
                            : (entity.currentHp ?? entity.hp ?? 0);
                    }
                    if (maxHp === undefined) {
                        maxHp = entity.maxHp || entity.maxHP || entity.hp || hp || 0;
                    }
                } else if (isCurrentPlayerParticipant(participant) && playerCharacter) {
                    entity = playerCharacter;
                    name = playerCharacter.name || name;
                    typeLabel = playerCharacter.class || typeLabel;
                    if (hp === null) {
                        hp = typeof participant.currentHp === 'number'
                            ? participant.currentHp
                            : (playerCharacter.currentHp ?? playerCharacter.hp ?? 0);
                    }
                    if (maxHp === undefined) {
                        maxHp = playerCharacter.maxHp || playerCharacter.hp || hp || 0;
                    }
                }
            }

            if (hp === null || Number.isNaN(hp)) hp = 0;
            if (maxHp === undefined || maxHp === null || Number.isNaN(maxHp)) maxHp = hp;
            const isPlayer = participant.type === 'player';
            const charId = entity?.id || normalizeId(participant.characterId) || normalizeId(participant.id);
            let deathState = { successes: 0, fails: 0 };
            if (isPlayer) {
                const localState = getDeathSaveState(charId);
                deathState = { ...localState };
                if (typeof participant.deathFails === 'number') {
                    const serverFails = clamp(parseInt(participant.deathFails, 10) || 0, 0, 3);
                    deathState.fails = serverFails;
                }
                if (typeof participant.deathSuccesses === 'number') {
                    const serverSucc = clamp(parseInt(participant.deathSuccesses, 10) || 0, 0, 3);
                    deathState.successes = serverSucc;
                }
                deathSaveStateCache[charId] = deathState;
                try {
                    localStorage.setItem(getDeathSaveKey(charId), JSON.stringify(deathState));
                } catch {
                    // ignore storage errors
                }
            }
            const isDefeated = isPlayer
                ? (hp <= 0 && deathState.fails >= 3)
                : (participant.defeated || hp <= 0);

            return { name: name || 'Unknown', typeLabel, entity, hp, maxHp, isDefeated, deathState };
        }

        function isCurrentPlayerParticipant(participant) {
            if (!participant || participant.type !== 'player') return false;
            const participantUserId = normalizeId(participant.id ?? participant.userId);
            const participantCharacterId = normalizeId(participant.characterId);
            const currentUserId = normalizeId(currentUser?.id);
            const playerCharacterId = normalizeId(playerCharacter?.id);
            return (participantUserId && participantUserId === currentUserId) ||
                (participantCharacterId && playerCharacterId && participantCharacterId === playerCharacterId);
        }

        function getSortedParticipants({ includeHidden = true } = {}) {
            if (!activeEncounter || !Array.isArray(activeEncounter.participants)) return [];
            return activeEncounter.participants
                .filter(p => includeHidden || !p.hidden)
                .sort((a, b) => (b.initiative || 0) - (a.initiative || 0));
        }

        function updateEncounterSummaries() {
            const sortedAll = getSortedParticipants({ includeHidden: true });
            const sortedVisible = getSortedParticipants({ includeHidden: false });
            const hasEncounter = !!activeEncounter && sortedAll.length > 0;
            const currentIndex = hasEncounter ? Math.min(activeEncounter.currentTurn || 0, sortedAll.length - 1) : 0;
            const current = hasEncounter ? sortedAll[currentIndex] : null;
            const next = hasEncounter ? sortedAll[(currentIndex + 1) % sortedAll.length] : null;
            const currentVisible = current && !current.hidden;
            const nextVisible = next && !next.hidden;

            const currentInfo = getParticipantDisplay(current);
            const nextInfo = getParticipantDisplay(next);

            const currentKey = current ? `${current.type}:${current.id}` : null;
            if (currentKey !== lastTurnActorKey) {
                deathSaveRolledThisTurn = false;
                lastTurnActorKey = currentKey;
            }

            const summaryRoundValue = document.getElementById('summaryRoundValue');
            const summaryParticipantsValue = document.getElementById('summaryParticipantsValue');
            const summaryCurrentName = document.getElementById('summaryCurrentName');
            const summaryCurrentType = document.getElementById('summaryCurrentType');
            const summaryNextName = document.getElementById('summaryNextName');
            const summaryNextType = document.getElementById('summaryNextType');
            const currentTurnLabel = document.getElementById('currentTurnLabel');
            const nextTurnLabel = document.getElementById('nextTurnLabel');

            if (summaryRoundValue) {
                summaryRoundValue.textContent = hasEncounter ? (activeEncounter.currentRound || 1) : '-';
            }
            if (summaryParticipantsValue) {
                const participantCount = sortedAll.length;
                summaryParticipantsValue.textContent = hasEncounter
                    ? `${participantCount} participant${participantCount === 1 ? '' : 's'}`
                    : '0 combatants';
            }
            if (summaryCurrentName) {
                summaryCurrentName.textContent = hasEncounter ? currentInfo.name : '';
            }
            if (summaryCurrentType) {
                summaryCurrentType.textContent = hasEncounter ? currentInfo.typeLabel : '';
            }
            if (summaryNextName) {
                summaryNextName.textContent = hasEncounter ? nextInfo.name : '';
            }
            if (summaryNextType) {
                summaryNextType.textContent = hasEncounter ? nextInfo.typeLabel : '';
            }
            if (currentTurnLabel) {
                currentTurnLabel.textContent = hasEncounter ? `Acting now: ${currentInfo.name}` : 'Awaiting combatants...';
            }
            if (nextTurnLabel) {
                nextTurnLabel.textContent = hasEncounter ? `Next: ${nextInfo.name}` : '';
            }

            const playerRoundValue = document.getElementById('playerRoundValue');
            const playerParticipantsCount = document.getElementById('playerParticipantsCount');
            const playerCurrentTurnName = document.getElementById('playerCurrentTurnName');
            const playerCurrentTurnType = document.getElementById('playerCurrentTurnType');
            const playerNextTurnName = document.getElementById('playerNextTurnName');
            const playerNextTurnType = document.getElementById('playerNextTurnType');
            const playerCombatHud = document.getElementById('playerCombatHud');

            if (playerCombatHud) {
                playerCombatHud.style.display = hasEncounter ? 'grid' : 'none';
            }
            if (playerRoundValue) {
                playerRoundValue.textContent = hasEncounter ? (activeEncounter.currentRound || 1) : '-';
            }
            if (playerParticipantsCount) {
                const visibleCount = sortedVisible.length;
                playerParticipantsCount.textContent = hasEncounter
                    ? `${visibleCount} visible participant${visibleCount === 1 ? '' : 's'}`
                    : '0 participants';
            }
            if (playerCurrentTurnName) {
                playerCurrentTurnName.textContent = hasEncounter
                    ? (currentVisible ? currentInfo.name : 'Unknown foe')
                    : '';
            }
            if (playerCurrentTurnType) {
                playerCurrentTurnType.textContent = hasEncounter
                    ? (currentVisible ? currentInfo.typeLabel : '')
                    : '';
            }
            if (playerNextTurnName) {
                playerNextTurnName.textContent = hasEncounter
                    ? (nextVisible ? nextInfo.name : 'Unknown foe')
                    : '';
            }
            if (playerNextTurnType) {
                playerNextTurnType.textContent = hasEncounter
                    ? (nextVisible ? nextInfo.typeLabel : '')
                    : '';
            }
        }

        // Render Initiative Tracker
        function renderInitiativeTracker() {
            const tracker = document.getElementById('initiativeTracker');

            if (!activeEncounter || !activeEncounter.participants || activeEncounter.participants.length === 0) {
                tracker.innerHTML = '<div class="empty-state">No participants in combat yet. Add NPCs or wait for players to roll initiative.</div>';
                document.getElementById('combatLog').style.display = 'none';
                return;
            }

            const sorted = getSortedParticipants({ includeHidden: true });

            const html = sorted.map((p, index) => {
                const display = getParticipantDisplay(p);
                const actor = display.entity;
                const isHidden = p.hidden || false;
                const hp = display.hp;
                const maxHP = display.maxHp || hp || 0;
                const hpPercent = maxHP > 0 ? (hp / maxHP) * 100 : 0;
                const isCurrent = index === activeEncounter.currentTurn;
                const isDefeated = display.isDefeated;
                const needsDeathSave = p.type === 'player' && isCurrent && hp <= 0 && (display.deathState?.fails ?? 0) < 3 && (display.deathState?.successes ?? 0) < 3;
                const hiddenBadge = isHidden ? '<span style="font-size: 12px; color: #f59e0b; margin-left: 5px;"> Hidden</span>' : '';
                const conditionBadges = getConditionBadges(actor || p);
                const deathDots = (p.type === 'player' && hp <= 0) ? buildDeathSaveDots(display.deathState || { successes: 0, fails: 0 }) : '';
                const statusBadge = isDefeated ? '<span class="participant-tag defeated"> Defeated</span>' : deathDots;

                // Determine HP bar color based on percentage
                let hpColorClass = 'hp-high';
                if (hpPercent <= 10) {
                    hpColorClass = 'hp-critical';
                } else if (hpPercent <= 33) {
                    hpColorClass = 'hp-low';
                } else if (hpPercent <= 66) {
                    hpColorClass = 'hp-medium';
                }

                // Action Economy Indicators
                const actionUsed = p.actionUsed || false;
                const bonusActionUsed = p.bonusActionUsed || false;
                const reactionUsed = p.reactionUsed || false;

                const actionEconomy = (isCurrent && !isDefeated) ? `
                    <div class="action-economy">
                        <span class="action-indicator ${actionUsed ? 'used' : 'available'}">Action</span>
                        <span class="action-indicator ${bonusActionUsed ? 'used' : 'available'}">Bonus</span>
                        <span class="action-indicator ${reactionUsed ? 'used' : 'available'}">Reaction</span>
                    </div>
                ` : '';

                // Action Buttons (only for current turn)
                const safeName = display.name.replace(/'/g, "\\'");
                const rageButtonEntity = display.entity || (isCurrent && isCurrentPlayerParticipant(p) ? playerCharacter : null);
                const rageButton = (isCurrent && !isDefeated && !needsDeathSave) ? getRageActionButton(rageButtonEntity) : '';
                const deathSaveActions = needsDeathSave ? `
                    <div class="action-buttons">
                        <div class="death-save-label">Death Saves (DC 10)</div>
                        <div class="death-save-tracker">${deathDots}</div>
                        ${isCurrentPlayerParticipant(p) ? `<button class="action-btn" style="background:#ef4444;" onclick="rollDeathSave()">Roll Death Save</button>` : '<div class="player-status-badge">Waiting for player death save...</div>'}
                    </div>
                ` : '';
                const actionButtons = (isCurrent && !isDefeated && !needsDeathSave) ? `
                    <div class="action-buttons">
                        <button class="action-btn action-btn-attack" onclick="openAttackModal(${p.id}, '${p.type}', '${safeName}')">Attack</button>
                        <button class="action-btn action-btn-spell" onclick="openSpellModal(${p.id}, '${p.type}', '${safeName}')">Cast Spell</button>
                        <button class="action-btn action-btn-other" onclick="openOtherActionModal(${p.id}, '${p.type}', '${safeName}')">Other Action</button>
                        ${rageButton}
                        <button class="action-btn" style="background: #10b981;" onclick="openUseItemModal(${p.id}, '${p.type}', '${safeName}')">Use Item</button>
                        <button class="action-btn" style="background: #f59e0b;" onclick="openConditionsModal(${p.id}, '${p.type}')"> Conditions</button>
                        <button class="action-btn action-btn-end-turn" onclick="endParticipantTurn()">End Turn</button>
                    </div>
                ` : deathSaveActions;

                const classes = ['initiative-item'];
                if (isCurrent) classes.push('current-turn');
                if (isDefeated) classes.push('defeated');

                return `
                    <div class="${classes.join(' ')}">
                        <div style="flex: 1;">
                            <div class="initiative-participant">
                                <div class="initiative-order">${p.initiative || 0}</div>
                                <div class="participant-info" style="flex: 1;">
                                    <div class="participant-name">${display.name}${hiddenBadge}${statusBadge}${conditionBadges}</div>
                                    <div class="participant-type">${display.typeLabel}</div>
                                    ${actionEconomy}
                                </div>
                                <div class="participant-hp" data-actor-id="${p.id}" data-actor-type="${p.type}">
                                    <div class="hp-bar">
                                        <div class="hp-fill ${hpColorClass}" style="width: ${hpPercent}%"></div>
                                    </div>
                                    <div class="hp-input-group">
                                        <button class="hp-arrow-btn" onclick="updateHPDirect(${p.id}, '${p.type}', -1)">-</button>
                                        <input type="number" class="hp-input-field" id="hp-${p.type}-${p.id}" value="${hp}"
                                            onchange="saveHPChange(${p.id}, '${p.type}')" min="0" max="${maxHP}">
                                        <span style="color: #888;">/${maxHP}</span>
                                        <button class="hp-arrow-btn" onclick="updateHPDirect(${p.id}, '${p.type}', 1)">+</button>
                                    </div>
                                </div>
                            </div>
                            ${actionButtons}
                        </div>
                    </div>
                `;
            }).join('');

            tracker.innerHTML = html;
        }

        // Update Player Combat UI
        function updatePlayerCombatUI() {
            console.log('Updating player combat UI, activeEncounter:', activeEncounter);

            const combatAlert = document.getElementById('combatAlertSection');
            const initiativeRollerSection = document.getElementById('initiativeRollerSection');
            const initiativeOrderSection = document.getElementById('initiativeOrderSection');
            const yourTurnIndicator = document.getElementById('yourTurnIndicator');
            const hpSection = document.getElementById('playerHPSection');
            const playerCombatLog = document.getElementById('playerCombatLog');

            if (activeEncounter) {
                console.log('Combat is active!');
                combatAlert.style.display = 'block';
                if (hpSection) {
                    hpSection.style.display = 'block';
                }

                // Check if player has rolled initiative
                const playerParticipant = activeEncounter.participants?.find(p => isCurrentPlayerParticipant(p));

                console.log('Player participant:', playerParticipant);
                console.log('Current user ID:', currentUser.id);
                console.log('All participants:', activeEncounter.participants);

                if (!playerParticipant) {
                    console.log('Player has not rolled yet, showing roller');
                    initiativeRollerSection.style.display = 'block';
                    initiativeOrderSection.style.display = 'none';
                    yourTurnIndicator.style.display = 'none';
                } else {
                    console.log('Player has rolled, showing order');
                    initiativeRollerSection.style.display = 'none';
                    initiativeOrderSection.style.display = 'block';
                    renderPlayerInitiativeTracker();

                    // Check if it's player's turn (using index comparison)
                    const sortedParticipants = getSortedParticipants({ includeHidden: true });
                    const playerIndex = sortedParticipants.findIndex(p => isCurrentPlayerParticipant(p));

                    if (playerIndex !== -1 && playerIndex === activeEncounter.currentTurn) {
                        yourTurnIndicator.style.display = 'block';
                    } else {
                        yourTurnIndicator.style.display = 'none';
                    }

                    if (playerCombatLog) {
                        playerCombatLog.style.display = activeEncounter.combatLog?.length ? 'block' : 'none';
                    }
                }
                updateEncounterSummaries();
            } else {
                console.log('No active combat');
                combatAlert.style.display = 'none';
                // Keep health bar always visible (removed hpSection.style.display = 'none')
                if (playerCombatLog) {
                    playerCombatLog.style.display = 'none';
                }
                if (hpSection) {
                    hpSection.style.display = 'block';
                }
                updateEncounterSummaries();
            }
        }

        // Render Player Initiative Tracker
        function renderPlayerInitiativeTracker() {
            const tracker = document.getElementById('playerInitiativeTracker');

            if (!activeEncounter || !activeEncounter.participants || activeEncounter.participants.length === 0) {
                tracker.innerHTML = '<div class="empty-state">Waiting for initiative rolls...</div>';
                return;
            }

            const sorted = getSortedParticipants({ includeHidden: false });

            if (!sorted.length) {
                tracker.innerHTML = '<div class="empty-state">Waiting for initiative rolls...</div>';
                return;
            }

            const html = sorted.map((p, index) => {
                const display = getParticipantDisplay(p);
                const isCurrent = index === activeEncounter.currentTurn;
                const isYou = isCurrentPlayerParticipant(p);
                const turnArrow = isCurrent ? '<span style="font-size: 32px; margin-right: 10px;"></span>' : '';
                const isDefeated = display.isDefeated;
                const deathDots = (p.type === 'player' && display.hp <= 0) ? buildDeathSaveDots(display.deathState || { successes: 0, fails: 0 }) : '';
                const statusBadge = isDefeated ? '<span class="participant-tag defeated"> Defeated</span>' : deathDots;

                // Action Economy Indicators (only show for yourself)
                const actionUsed = p.actionUsed || false;
                const bonusActionUsed = p.bonusActionUsed || false;
                const reactionUsed = p.reactionUsed || false;

                const needsDeathSave = isYou && isCurrent && display.hp <= 0 && (display.deathState?.fails ?? 0) < 3 && (display.deathState?.successes ?? 0) < 3 && !deathSaveRolledThisTurn;

                const actionEconomy = (isCurrent && isYou && !isDefeated && !needsDeathSave) ? `
                    <div class="action-economy" style="margin-top: 10px;">
                        <span class="action-indicator ${actionUsed ? 'used' : 'available'}">Action</span>
                        <span class="action-indicator ${bonusActionUsed ? 'used' : 'available'}">Bonus</span>
                        <span class="action-indicator ${reactionUsed ? 'used' : 'available'}">Reaction</span>
                    </div>
                ` : '';

                // Action Buttons (only for current player when it's their turn)
                const safeName = display.name.replace(/'/g, "\\'");
                const rageButtonEntity = display.entity || (isYou ? playerCharacter : null);
                const rageButton = (isCurrent && isYou && !isDefeated && !needsDeathSave) ? getRageActionButton(rageButtonEntity) : '';
                const deathSaveActions = needsDeathSave ? `
                    <div class="action-buttons" style="margin-top: 10px;">
                        <div class="death-save-label">Death Saves (DC 10)</div>
                        <div class="death-save-tracker">${deathDots}</div>
                        <button class="action-btn" style="background:#ef4444;" onclick="rollDeathSave()">Roll Death Save</button>
                    </div>
                ` : '';
                const actionButtons = (isCurrent && isYou && !isDefeated && !needsDeathSave) ? `
                    <div class="action-buttons" style="margin-top: 10px;">
                        <button class="action-btn action-btn-attack" onclick="openAttackModal(${p.id}, '${p.type}', '${safeName}')">Attack</button>
                        <button class="action-btn action-btn-spell" onclick="openSpellModal(${p.id}, '${p.type}', '${safeName}')">Cast Spell</button>
                        <button class="action-btn action-btn-other" onclick="openOtherActionModal(${p.id}, '${p.type}', '${safeName}')">Other Action</button>
                        ${rageButton}
                        <button class="action-btn" style="background: #10b981;" onclick="openUseItemModal(${p.id}, '${p.type}', '${safeName}')">Use Item</button>
                        <button class="action-btn" style="background: #f59e0b;" onclick="openConditionsModal(${p.id}, '${p.type}')"> Conditions</button>
                        <button class="action-btn action-btn-end-turn" onclick="endParticipantTurn()">End Turn</button>
                    </div>
                ` : deathSaveActions;

                return `
                    <div class="initiative-item ${isCurrent ? 'current-turn' : ''} ${isDefeated ? 'defeated' : ''}">
                        <div style="flex: 1;">
                            <div class="initiative-participant">
                                <div class="initiative-order">${p.initiative || 0}</div>
                                <div class="participant-info">
                                    <div class="participant-name">${turnArrow}${display.name}${isYou ? ' (You)' : ''}${statusBadge}</div>
                                    <div class="participant-type">${display.typeLabel}</div>
                                    ${actionEconomy}
                                </div>
                            </div>
                            ${actionButtons}
                        </div>
                    </div>
                `;
            }).join('');

            tracker.innerHTML = html;
        }

        // Roll Player Initiative
        function rollPlayerInitiative() {
            if (!playerCharacter) {
                showThemedAlert('Character data is still loading. Please wait a moment and try again.');
                return;
            }

            console.log('Rolling initiative...');
            console.log('Player character:', playerCharacter);

            const dice = document.getElementById('playerDice');
            if (!dice) {
                console.error('Dice element not found!');
                return;
            }

            dice.classList.add('rolling');

            // Animate
            let count = 0;
            const interval = setInterval(() => {
                dice.textContent = Math.floor(Math.random() * 20) + 1;
                count++;
                if (count > 10) {
                    clearInterval(interval);
                    const roll = Math.floor(Math.random() * 20) + 1;
                    dice.textContent = roll;
                    dice.classList.remove('rolling');

                    // Calculate total
                    const dexMod = getInitiativeModifier();
                    const total = roll + dexMod;

                    console.log('Roll:', roll, 'Dex Mod:', dexMod, 'Total:', total);

                    playerInitiativeRoll = roll;
                    playerInitiativeMod = dexMod;

                    const modDisplay = dexMod >= 0 ? `+${dexMod}` : dexMod;
                    document.getElementById('initiativeTotal').textContent = `${roll} ${modDisplay} = ${total}`;
                    document.getElementById('initiativeResult').style.display = 'block';
                    document.getElementById('rollInitiativeBtn').style.display = 'none';

                    postDiceLog({ label: 'Initiative', sides: 20, roll, modifier: dexMod, total });
                }
            }, 100);
        }

        // Submit Player Initiative
        async function submitPlayerInitiative() {
            if (!activeEncounter || playerInitiativeRoll === null) return;

            const total = playerInitiativeRoll + playerInitiativeMod;

            try {
                const response = await fetch(`/encounter/${activeEncounter.id}/initiative`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        userId: currentUser.id,
                        roll: playerInitiativeRoll,
                        modifier: playerInitiativeMod,
                        total: total
                    })
                });

                const data = await response.json();

                if (data.success) {
                    await pollCombatStatus();
                } else {
                    showThemedAlert('Failed to submit initiative: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error submitting initiative:', error);
                showThemedAlert('Failed to submit initiative');
            }
        }

        // ===== COMBAT ACTIONS =====

        // Render Combat Log
        function renderCombatLog() {
            const combatLogDiv = document.getElementById('combatLog');
            const playerLogWrapper = document.getElementById('playerCombatLog');
            const playerLogEntries = document.getElementById('playerCombatLogEntries');

            if (!combatLogDiv && !playerLogWrapper) return;

            if (!activeEncounter || !activeEncounter.combatLog || activeEncounter.combatLog.length === 0) {
                if (combatLogDiv) combatLogDiv.style.display = 'none';
                if (playerLogWrapper) playerLogWrapper.style.display = 'none';
                if (playerLogEntries) playerLogEntries.innerHTML = '';
                return;
            }

            const logHtml = activeEncounter.combatLog.map(entry => {
                let message = '';
                let className = 'combat-log-entry';

                if (entry.type === 'attack') {
                    const hit = entry.totalAttack || (entry.attackRoll + entry.attackBonus);
                    const critText = entry.isCrit ? ' <span style="color: #fbbf24;">(CRITICAL!)</span>' : '';

                    if (entry.isHit === false) {
                        message = `<div class="combat-log-actor">${entry.actorName}</div> attacks <strong>${entry.targetName}</strong> with <em>${entry.weaponName}</em>: Rolled <span class="combat-log-roll">${hit}</span> vs AC ${entry.targetAC} - <span style="color: #ef4444; font-weight: 700;">MISSED!!</span>`;
                    } else {
                        const damageTypeLabel = getDamageTypeDisplayLabel(entry.damageType) || entry.damageType || 'damage';
                        message = `<div class="combat-log-actor">${entry.actorName}</div> attacks <strong>${entry.targetName}</strong> with <em>${entry.weaponName}</em>: Rolled <span class="combat-log-roll">${hit}</span> vs AC ${entry.targetAC}${critText} for <span class="combat-log-damage">${entry.damage}</span> ${damageTypeLabel} damage`;
                        const adjustments = getEntryAdjustments(entry);
                        if (adjustments.length) {
                            message += `<span class="combat-log-resistance">${formatDamageAdjustmentMessage(adjustments[0])}.</span>`;
                        }
                    }
                } else if (entry.type === 'spell') {
                    const targetNames = entry.targetNames ? entry.targetNames.join(', ') : entry.targetName;
                    if (Array.isArray(entry.damage) && entry.damage.length > 0) {
                        const totalDamage = entry.damage.reduce((sum, d) => sum + (Number(d) || 0), 0);
                        const damageTypeLabel = getDamageTypeDisplayLabel(entry.damageType) || entry.damageType || 'damage';
                        message = `<div class="combat-log-actor">${entry.actorName}</div> casts <em>${entry.spellName}</em> (Level ${entry.spellLevel}) on <strong>${targetNames}</strong> for <span class="combat-log-damage">${totalDamage}</span> ${damageTypeLabel} damage`;
                        const adjustments = getEntryAdjustments(entry);
                        if (adjustments.length) {
                            const detailText = adjustments
                                .map(detail => formatDamageAdjustmentMessage(detail))
                                .join('; ');
                            message += `<span class="combat-log-resistance">${detailText}</span>`;
                        }
                    } else if (entry.healing && entry.healing.length > 0) {
                        const totalHealing = entry.healing.reduce((sum, h) => sum + h, 0);
                        message = `<div class="combat-log-actor">${entry.actorName}</div> casts <em>${entry.spellName}</em> (Level ${entry.spellLevel}) on <strong>${targetNames}</strong> for <span class="combat-log-healing">${totalHealing}</span> healing`;
                    } else {
                        message = `<div class="combat-log-actor">${entry.actorName}</div> casts <em>${entry.spellName}</em> (Level ${entry.spellLevel})`;
                    }
                } else if (entry.type === 'item') {
                    if (entry.itemEffect === 'healing') {
                        let healingText = `<span class="combat-log-healing">${entry.healAmount}</span>`;
                        if (entry.healBreakdown) {
                            healingText += ` <span style="color: #94a3b8; font-size: 12px;">(${entry.healDice}: ${entry.healBreakdown})</span>`;
                        }
                        message = `<div class="combat-log-actor">${entry.actorName}</div> uses <em>${entry.itemName}</em> on <strong>${entry.targetName}</strong> for ${healingText} healing`;
                    } else if (entry.itemEffect === 'damage') {
                        const typeLabel = getDamageTypeDisplayLabel(entry.effectDamageType) || entry.effectDamageType || 'damage';
                        const rawValue = typeof entry.rawDamageAmount === 'number' && entry.rawDamageAmount > 0 ? entry.rawDamageAmount : entry.damageAmount;
                        message = `<div class="combat-log-actor">${entry.actorName}</div> uses <em>${entry.itemName}</em> on <strong>${entry.targetName || 'a target'}</strong> for <span class="combat-log-damage">${entry.damageAmount || 0}</span> ${typeLabel} damage`;
                        const adjustments = getEntryAdjustments(entry);
                        if (adjustments.length) {
                            message += `<span class="combat-log-resistance">${formatDamageAdjustmentMessage(adjustments[0])}.</span>`;
                        }
                    } else {
                        message = `<div class="combat-log-actor">${entry.actorName}</div> uses <em>${entry.itemName}</em>`;
                    }
                } else if (entry.type === 'defeat') {
                    className += ' defeat';
                    const killer = escapeHtml(entry.actorName || 'Unknown hero');
                    const victim = escapeHtml(entry.targetName || 'their foe');
                    const customMessage = entry.message ? escapeHtml(entry.message) : `defeats <strong>${victim}</strong>!`;
                    message = `<div class="combat-log-actor">${killer}</div> ${customMessage}`;
                } else {
                    message = `<div class="combat-log-actor">${entry.actorName}</div> uses <em>${entry.actionName}</em>${entry.description ? ': ' + entry.description : ''}`;
                }

                return `<div class="${className}"><span class="combat-log-round">Round ${entry.round}</span> ${message}</div>`;
            }).reverse().join('');

            if (combatLogDiv) {
                combatLogDiv.style.display = 'block';
                combatLogDiv.innerHTML = `<div class="combat-log-title">Combat Log</div>${logHtml}`;
                combatLogDiv.scrollTop = 0;
            }

            if (playerLogWrapper && playerLogEntries) {
                playerLogWrapper.style.display = 'block';
                playerLogEntries.innerHTML = logHtml;
                playerLogEntries.parentElement.scrollTop = 0;
            }
        }

        function getEntryAdjustments(entry) {
            if (!entry) return [];
            if (Array.isArray(entry.damageAdjustments) && entry.damageAdjustments.length) {
                return entry.damageAdjustments;
            }
            if (Array.isArray(entry.resistanceDetails) && entry.resistanceDetails.length) {
                return entry.resistanceDetails.map(detail => ({
                    targetName: detail.targetName || 'Target',
                    raw: detail.raw,
                    adjusted: detail.adjusted,
                    damageType: detail.damageType,
                    immunity: !!detail.immunity,
                    vulnerability: !!detail.vulnerability,
                    resistance: detail.resistance !== false
                }));
            }
            return [];
        }

        function formatDamageAdjustmentMessage(detail) {
            const name = escapeHtml(detail.targetName || 'Target');
            const typeLabel = getDamageTypeDisplayLabel(detail.damageType) || detail.damageType || 'that damage';
            const rawAmount = detail.raw ?? detail.amount ?? 0;
            const adjustedAmount = detail.adjusted ?? detail.amount ?? rawAmount;
            if (detail.immunity) {
                return `${name} is immune to ${typeLabel}: ${rawAmount}  ${adjustedAmount}`;
            }
            if (detail.vulnerability) {
                return `${name} is vulnerable to ${typeLabel}: ${rawAmount}  ${adjustedAmount}`;
            }
            if (detail.resistance) {
                return `${name} resists ${typeLabel}: ${rawAmount}  ${adjustedAmount}`;
            }
            return `${name}: ${rawAmount}  ${adjustedAmount}`;
        }

        function formatDurationLabel(seconds) {
            if (typeof seconds !== 'number' || Number.isNaN(seconds)) {
                return '';
            }
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            if (mins > 0) {
                return `${mins}m ${secs}s`;
            }
            return `${secs}s`;
        }

        function renderCombatSummaryHighlights(summary) {
            const container = document.getElementById('combatSummaryHighlights');
            if (!container) return;
            const performers = summary?.topPerformers || {};
            const config = [
                { key: 'mostDamage', label: 'Most Damage Dealt', suffix: ' dmg' },
                { key: 'mostHealing', label: 'Most Healing', suffix: ' hp' },
                { key: 'mostHits', label: 'Most Hits', suffix: ' hits' },
                { key: 'leastMisses', label: 'Least Misses', suffix: ' misses' },
                { key: 'mostDefeats', label: 'Most Defeats', suffix: '' },
                { key: 'bestAccuracy', label: 'Best Accuracy', format: value => `${Math.round((value || 0) * 100)}%` }
            ];

            const cards = config
                .map(item => {
                    const stat = performers[item.key];
                    if (!stat || (stat.value === 0 && item.key !== 'leastMisses')) return '';
                    const value = item.format
                        ? item.format(stat.value || 0)
                        : `${stat.value || 0}${item.suffix || ''}`;
                    return `
                        <div class="summary-highlight-card">
                            <div class="summary-highlight-label">${item.label}</div>
                            <div class="summary-highlight-value">${value}</div>
                            <div class="summary-highlight-name">${escapeHtml(stat.name || 'Unknown')}</div>
                        </div>
                    `;
                })
                .filter(Boolean)
                .join('');

            container.innerHTML = cards || '<div class="summary-empty-state">No standout performances recorded.</div>';
        }

        function renderCombatSummaryTable(summary) {
            const body = document.getElementById('combatSummaryTableBody');
            if (!body) return;
            const stats = Array.isArray(summary?.playerStats) ? summary.playerStats.slice() : [];
            if (!stats.length) {
                body.innerHTML = `<tr><td colspan="7" class="summary-empty-state">No player data recorded.</td></tr>`;
                return;
            }
            stats.sort((a, b) => (b.totalDamage || 0) - (a.totalDamage || 0));
            const rows = stats.map(stat => {
                const accuracy = typeof stat.accuracy === 'number'
                    ? `${Math.round(stat.accuracy * 100)}%`
                    : '';
                return `
                    <tr>
                        <td>${escapeHtml(stat.name || 'Unknown')}</td>
                        <td>${stat.totalDamage || 0}</td>
                        <td>${stat.totalHealing || 0}</td>
                        <td>${stat.hits || 0}</td>
                        <td>${stat.misses || 0}</td>
                        <td>${accuracy}</td>
                        <td>${stat.defeats || 0}</td>
                    </tr>
                `;
            }).join('');
            body.innerHTML = rows;
        }

        function showCombatSummary(summary) {
            if (!summary) return;
            const modal = document.getElementById('combatSummaryModal');
            if (!modal) return;
            const summaryId = summary.encounterId ? String(summary.encounterId) : null;
            if (summaryId) {
                lastSummaryEncounterId = summaryId;
                if (summarySeenStorageKey) {
                    localStorage.setItem(summarySeenStorageKey, summaryId);
                }
            }
            const rounds = document.getElementById('combatSummaryRounds');
            if (rounds) rounds.textContent = summary.rounds ?? '';
            const duration = document.getElementById('combatSummaryDuration');
            if (duration) duration.textContent = formatDurationLabel(summary.durationSeconds);
            const participants = document.getElementById('combatSummaryParticipants');
            if (participants) participants.textContent = summary.totalParticipants ?? '';
            const defeated = document.getElementById('combatSummaryDefeated');
            if (defeated) defeated.textContent = summary.enemiesDefeated ?? 0;

            renderCombatSummaryHighlights(summary);
            renderCombatSummaryTable(summary);

            modal.classList.add('active');
        }

        function closeCombatSummaryModal() {
            const modal = document.getElementById('combatSummaryModal');
            if (modal) modal.classList.remove('active');
        }

        function maybeShowCombatSummary(summaryWrapper) {
            if (!summaryWrapper || !summaryWrapper.summary) return;
            const summaryData = {
                ...summaryWrapper.summary,
                encounterId: summaryWrapper.summary.encounterId || summaryWrapper.encounterId
            };
            const summaryId = summaryData.encounterId ? String(summaryData.encounterId) : null;
            if (summaryId) {
                const seenId = summarySeenStorageKey ? localStorage.getItem(summarySeenStorageKey) : null;
                if (summaryId === String(lastSummaryEncounterId) || (seenId && seenId === summaryId)) {
                    lastSummaryEncounterId = summaryId;
                    return;
                }
            }
            showCombatSummary(summaryData);
        }

        // Populate target list for modals
        function populateTargetList(containerId, allowMultiple = false) {
            const container = document.getElementById(containerId);
            if (!activeEncounter || !activeEncounter.participants) {
                container.innerHTML = '<div style="color: #888;">No targets available</div>';
                return;
            }

            const targets = activeEncounter.participants
                .map(p => ({ participant: p, display: getParticipantDisplay(p) }))
                .filter(({ participant, display }) => {
                    if (userRole === 'player' && participant.hidden) return false;
                    if (participant.type === 'npc' && display.hp <= 0) return false;
                    return true;
                });

            if (targets.length === 0) {
                container.innerHTML = '<div style="color: #888;">No targets available</div>';
                return;
            }

            const inputType = allowMultiple ? 'checkbox' : 'radio';
            const inputName = containerId + 'Target';

            const html = targets.map(({ participant, display }) => {
                const name = display.name || 'Unknown';
                const hp = display.hp;
                const maxHP = display.maxHp || hp;

                return `
                    <label class="target-option">
                        <input type="${inputType}" name="${inputName}" value="${participant.id}" data-type="${participant.type}">
                        <span>${escapeHtml(name)} (${hp}/${maxHP} HP)</span>
                    </label>
                `;
            }).join('');

            container.innerHTML = html;
        }

        // Action type selector helper
        function selectActionType(type) {
            // Find which modal is open
            const attackModal = document.getElementById('attackModal');
            const spellModal = document.getElementById('spellModal');
            const otherModal = document.getElementById('otherActionModal');

            let activeModal = null;
            if (attackModal.classList.contains('active')) activeModal = attackModal;
            if (spellModal.classList.contains('active')) activeModal = spellModal;
            if (otherModal.classList.contains('active')) activeModal = otherModal;

            if (!activeModal) return;

            // Update radio buttons and visual selection
            const options = activeModal.querySelectorAll('.action-type-option');
            options.forEach(opt => {
                const radio = opt.querySelector('input[type="radio"]');
                if (radio.value === type) {
                    radio.checked = true;
                    opt.classList.add('selected');
                } else {
                    opt.classList.remove('selected');
                }
            });
        }

        // Spell type selector
        function selectSpellType(type) {
            const options = document.querySelectorAll('#spellModal .action-type-option');
            options.forEach(opt => {
                const radio = opt.querySelector('input[type="radio"]');
                if (radio && radio.value === type) {
                    radio.checked = true;
                    opt.classList.add('selected');
                } else {
                    opt.classList.remove('selected');
                }
            });

            // Show/hide dice input for damage/healing
            const diceGroup = document.getElementById('spellDiceGroup');
            if (type === 'other') {
                diceGroup.style.display = 'none';
            } else {
                diceGroup.style.display = 'block';
                const label = type === 'healing' ? 'Healing Dice (e.g., 2d8+4)' : 'Damage Dice (e.g., 3d6)';
                diceGroup.querySelector('label').textContent = label;
            }
            const damageTypeGroup = document.getElementById('spellDamageTypeGroup');
            if (damageTypeGroup) {
                damageTypeGroup.style.display = type === 'damage' ? 'block' : 'none';
            }
        }

        // === ATTACK MODAL ===

        function openAttackModal(actorId, actorType, actorName) {
            currentActorId = actorId;
            currentActorType = actorType;
            currentActorName = actorName;
            currentAttackActorData = getCharacterDataForActor(actorId, actorType);
            attackRollResult = null;
            damageRollResult = null;
            populateDamageTypeSelect('attackDamageType');
            setDamageTypeSelectValue('attackDamageType', '');

            // Reset form
            document.getElementById('attackName').value = '';
            document.getElementById('attackBonus').value = '0';
            document.getElementById('attackDamage').value = '';
            document.getElementById('attackRollResult').style.display = 'none';
            document.getElementById('damageRollResult').style.display = 'none';
            updateAttackModalRageControl(currentAttackActorData);

            // Reset weapon source to inventory
            document.querySelector('input[name="weaponSource"][value="inventory"]').checked = true;
            selectWeaponSource('inventory');

            // Populate weapon inventory
            populateWeaponInventory();

            // Populate targets
            populateTargetList('attackTargetList', false);

            document.getElementById('attackModal').classList.add('active');
        }

        // Helper function to get NPC weapon ability modifier
        function getNPCWeaponAbilityModifier(weapon, npcStats) {
            if (!npcStats) return 0;

            const str = npcStats.strength || 10;
            const dex = npcStats.dexterity || 10;
            const strMod = getAbilityModifier(str);
            const dexMod = getAbilityModifier(dex);

            const weaponType = weapon.weaponType || 'melee';

            if (weaponType === 'finesse') {
                return Math.max(strMod, dexMod);
            } else if (weaponType === 'ranged') {
                return dexMod;
            } else if (weaponType === 'thrown') {
                return strMod;
            } else {
                return strMod;
            }
        }

        // Populate weapon dropdown from inventory
        function populateWeaponInventory() {
            const select = document.getElementById('weaponFromInventory');
            let weapons = [];
            let inventory = [];

            // Check if actor is NPC or player
            if (currentActorType === 'npc') {
                // Find NPC and use their inventory
                const npc = npcs.find(n => n.id === currentActorId);
                if (npc && npc.inventory && Array.isArray(npc.inventory)) {
                    inventory = npc.inventory;
                    weapons = inventory.filter(item => item.type === 'weapon');
                }
            } else {
                // Use player inventory
                inventory = playerInventory;
                weapons = inventory.filter(item => item.type === 'weapon');
            }

            if (weapons.length === 0) {
                select.innerHTML = '<option value="">-- No weapons in inventory --</option>';
                return;
            }

            // Separate equipped and unequipped weapons
            const equippedWeapons = weapons.filter(w => w.equipped);
            const unequippedWeapons = weapons.filter(w => !w.equipped);

            let html = '<option value="">-- Select a weapon --</option>';

            // Add equipped weapons first (with EQUIPPED label)
            equippedWeapons.forEach((weapon, index) => {
                const realIndex = inventory.indexOf(weapon);
                const bonuses = computeWeaponBonuses(weapon);
                const damageFormula = buildDamageFormula(weapon, bonuses.damageBonus);
                html += `<option value="${realIndex}"> ${weapon.name} (${damageFormula}, ${formatBonusValue(bonuses.attackBonus)}) [EQUIPPED]</option>`;
            });

            // Add unequipped weapons
            unequippedWeapons.forEach((weapon, index) => {
                const realIndex = inventory.indexOf(weapon);
                const bonuses = computeWeaponBonuses(weapon);
                const damageFormula = buildDamageFormula(weapon, bonuses.damageBonus);
                html += `<option value="${realIndex}">${weapon.name} (${damageFormula}, ${formatBonusValue(bonuses.attackBonus)})</option>`;
            });

            select.innerHTML = html;

            // Auto-select the first equipped weapon if available
            if (equippedWeapons.length > 0) {
                const firstEquippedIndex = inventory.indexOf(equippedWeapons[0]);
                select.value = firstEquippedIndex;
                handleWeaponSelection();
            }
        }

        // Handle weapon selection from inventory
        function handleWeaponSelection() {
            const select = document.getElementById('weaponFromInventory');
            const index = parseInt(select.value);

            if (isNaN(index)) return;

            let weapon = null;
            let bonuses = null;

            // Get weapon and calculate ability mod based on actor type
            if (currentActorType === 'npc') {
                const npc = npcs.find(n => n.id === currentActorId);
                if (npc && npc.inventory && Array.isArray(npc.inventory)) {
                    weapon = npc.inventory[index];
                    bonuses = computeWeaponBonuses(weapon, 'npc', currentActorId);
                }
            } else {
                weapon = playerInventory[index];
                bonuses = computeWeaponBonuses(weapon, 'player', currentActorId);
            }

            if (!weapon) return;
            if (!bonuses) bonuses = computeWeaponBonuses(weapon);

            // Auto-fill weapon stats with calculated bonuses
            document.getElementById('attackBonus').value = bonuses.attackBonus;
            document.getElementById('attackDamage').value = buildDamageFormula(weapon, bonuses.damageBonus);
            setDamageTypeSelectValue('attackDamageType', getItemDamageType(weapon));
        }

        // Toggle between inventory and custom weapon
        function selectWeaponSource(source) {
            const inventoryDiv = document.getElementById('weaponInventorySelect');
            const customDiv = document.getElementById('weaponCustomInput');

            if (source === 'inventory') {
                inventoryDiv.style.display = 'block';
                customDiv.style.display = 'none';
            } else {
                inventoryDiv.style.display = 'none';
                customDiv.style.display = 'block';
            }

            // Update radio button selection
            const options = document.querySelectorAll('input[name="weaponSource"]').forEach(radio => {
                const label = radio.closest('.action-type-option');
                if (radio.value === source) {
                    radio.checked = true;
                    label.classList.add('selected');
                } else {
                    label.classList.remove('selected');
                }
            });
        }

        function closeAttackModal() {
            document.getElementById('attackModal').classList.remove('active');
            attackRollResult = null;
            damageRollResult = null;
            currentAttackActorData = null;
            const rageContainer = document.getElementById('rageControl');
            if (rageContainer) {
                rageContainer.style.display = 'none';
                rageContainer.innerHTML = '';
            }
        }

        function showCombatResult(logEntry) {
            const modal = document.getElementById('combatResultModal');
            const header = document.getElementById('combatResultHeader');
            const icon = document.getElementById('combatResultIcon');
            const message = document.getElementById('combatResultMessage');
            const details = document.getElementById('combatResultDetails');

            if (logEntry.isHit === false) {
                // MISS
                header.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
                icon.textContent = '';
                message.textContent = 'MISSED!!';
                message.style.color = '#ef4444';
                details.innerHTML = `
                    Attack Roll: <span style="color: #fff; font-weight: 600;">${logEntry.totalAttack}</span><br>
                    Target AC: <span style="color: #fff; font-weight: 600;">${logEntry.targetAC}</span><br>
                    <span style="color: #ef4444;">Your attack did not hit!</span>
                `;
            } else {
                // HIT
                const isCrit = logEntry.isCrit;
                const damageTypeLabel = getDamageTypeDisplayLabel(logEntry.damageType) || logEntry.damageType || 'damage';
                const adjustments = getEntryAdjustments(logEntry);
                const resistanceDetail = adjustments.length ? adjustments[0] : null;
                header.style.background = isCrit ?
                    'linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%)' :
                    'linear-gradient(135deg, #10b981 0%, #059669 100%)';
                icon.textContent = isCrit ? '' : '';
                message.textContent = isCrit ? 'CRITICAL HIT!' : 'HIT!';
                message.style.color = isCrit ? '#fbbf24' : '#10b981';

                let detailsHtml = `
                    Attack Roll: <span style="color: #fff; font-weight: 600;">${logEntry.totalAttack}</span><br>
                    Target AC: <span style="color: #fff; font-weight: 600;">${logEntry.targetAC}</span><br>
                    ${isCrit ? '<span style="color: #fbbf24; font-weight: 600;">CRITICAL HIT!</span><br>' : ''}
                    <div style="margin-top: 12px; padding: 12px; background: rgba(16, 185, 129, 0.1); border-radius: 8px; border: 1px solid rgba(16, 185, 129, 0.3);">
                        <span style="color: #10b981; font-size: 20px; font-weight: 700;">${logEntry.damage}</span>
                        <span style="color: #94a3b8;"> ${damageTypeLabel} damage dealt!</span>
                    </div>
                `;
                if (resistanceDetail) {
                    detailsHtml += `<div class="combat-log-resistance">${formatDamageAdjustmentMessage(resistanceDetail)}.</div>`;
                }

                details.innerHTML = detailsHtml;
            }

            modal.classList.add('active');
        }

        function closeCombatResultModal() {
            document.getElementById('combatResultModal').classList.remove('active');
        }

        function showLevelToast(message, type = 'info') {
            const container = document.getElementById('levelUpToastContainer');
            if (!container) return;

            const iconMap = {
                success: '',
                warning: '',
                info: ''
            };
            const icon = iconMap[type] || iconMap.info;

            const toast = document.createElement('div');
            toast.className = `levelup-toast levelup-toast-${type}`;
            toast.innerHTML = `
                <div class="levelup-toast-content">
                    <span class="levelup-toast-icon">${icon}</span>
                    <span>${message}</span>
                </div>
            `;

            container.appendChild(toast);
            requestAnimationFrame(() => toast.classList.add('visible'));

            setTimeout(() => {
                toast.classList.remove('visible');
            }, 4500);

            setTimeout(() => {
                toast.remove();
            }, 5200);
        }

        // Themed Alert Functions
        function showThemedAlert(message, title = 'Notice') {
            document.getElementById('themedAlertTitle').textContent = title;
            document.getElementById('themedAlertMessage').textContent = message;
            document.getElementById('themedAlertModal').classList.add('active');
        }

        function closeThemedAlert() {
            document.getElementById('themedAlertModal').classList.remove('active');
        }

        // Rest System Functions
        let restActorId = null;
        let restActorType = null;

        function openRestModal(actorId, actorType) {
            restActorId = actorId;
            restActorType = actorType;
            document.getElementById('restSummary').style.display = 'none';
            document.getElementById('restModal').classList.add('active');
        }

        function closeRestModal() {
            document.getElementById('restModal').classList.remove('active');
            restActorId = null;
            restActorType = null;
        }

        async function resetSpellResources(restType = 'long') {
            if (!playerCharacter) return;
            const config = await ensureSpellcastingConfig(playerCharacter);
            if (!config) return;

            const freshState = buildSpellSlotState(config);
            if (!freshState) return;

            if (config.type === 'warlock') {
                if (restType === 'short' || restType === 'long') {
                    persistSpellSlotState(playerCharacter.id, freshState);
                    renderSpellSlots(playerCharacter).catch(err => console.error('Failed to render pact slots after rest', err));
                }
            } else if (restType === 'long') {
                persistSpellSlotState(playerCharacter.id, freshState);
                renderSpellSlots(playerCharacter).catch(err => console.error('Failed to render spell slots after rest', err));
            }
        }

        function resetClassResourcesForRest(restType = 'long') {
            if (restType === 'long' && playerCharacter && normalizeClassKey(playerCharacter.class || '') === 'barbarian') {
                resetRages(playerCharacter.id);
            }
        }

        async function selectRestType(restType) {
            if (!restActorId || !restActorType) return;

            let actor = null;
            let currentHP = 0;
            let maxHP = 0;
            let actorName = '';

            // Get actor data
            if (restActorType === 'npc') {
                actor = npcs.find(n => n.id === restActorId);
                if (!actor) return;
                currentHP = actor.currentHp || actor.hp || 0;
                maxHP = actor.hp || 0;
                actorName = actor.name;
            } else {
                actor = playerCharacter;
                if (!actor) return;
                currentHP = actor.currentHp || actor.hp || 0;
                maxHP = actor.hp || 0;
                actorName = actor.name || 'Player';
            }

            // Calculate healing
            let hpRestored = 0;
            if (restType === 'short') {
                // Short rest: restore 50% of missing HP
                const missingHP = maxHP - currentHP;
                hpRestored = Math.floor(missingHP * 0.5);
            } else {
                // Long rest: restore to full HP
                hpRestored = maxHP - currentHP;
            }

            const newHP = Math.min(currentHP + hpRestored, maxHP);

            // Update HP based on actor type
            if (restActorType === 'npc') {
                actor.currentHp = newHP;

                // Save to backend
                try {
                    await fetch(`/npc/${restActorId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(actor)
                    });
                } catch (error) {
                    console.error('Error saving NPC rest:', error);
                }

                renderNPCList();
            } else {
                actor.currentHp = newHP;
                localStorage.setItem(`playerCharacter_${currentUser}`, JSON.stringify(actor));
                renderPlayerCharacter();
                renderDeathSaveTracker(actor, newHP, maxHP);
            }

            // Show summary
            const restTypeLabel = restType === 'short' ? 'Short Rest' : 'Long Rest';
            const restIcon = restType === 'short' ? '' : '';

            let summaryHTML = `
                <div style="margin-bottom: 10px;">
                    ${restIcon} <strong>${actorName}</strong> took a <strong>${restTypeLabel}</strong>
                </div>
                <div style="color: #10b981;">
                     HP Restored: <strong>+${hpRestored}</strong> (${currentHP}  ${newHP} / ${maxHP})
                </div>
            `;

            document.getElementById('restSummaryContent').innerHTML = summaryHTML;
            document.getElementById('restSummary').style.display = 'block';

            // Close modal after 2 seconds
            setTimeout(() => {
                closeRestModal();
            }, 2000);

            if (restActorType !== 'npc') {
                resetSpellResources(restType).catch(err => console.error('Failed to reset spell resources after rest', err));
                resetClassResourcesForRest(restType);
            }

            // Add to combat log if in combat
            if (activeEncounter) {
                addToCombatLog(`${actorName} took a ${restTypeLabel} and restored ${hpRestored} HP`);
            }
        }

        // Player Rest Function (for Rest Tab)
        function takeRest(restType) {
            if (!playerCharacter) {
                showThemedAlert('No character loaded!', 'Error');
                return;
            }

            playerCharacter.shortRestCharges = playerCharacter.shortRestCharges ?? 2;
            const currentHP = playerCharacter.currentHp || playerCharacter.hp || 0;
            const maxHP = playerCharacter.hp || 0;
            const actorName = playerCharacter.name || 'Player';

            if (restType === 'short') {
                if (playerCharacter.shortRestCharges <= 0) {
                    showThemedAlert('No short rests remaining.');
                    return;
                }
                playerCharacter.shortRestCharges -= 1;
            } else {
                playerCharacter.shortRestCharges = 2;
            }
            updateRestButtons();

            // Calculate healing
            let hpRestored = 0;
            if (restType === 'short') {
                const missingHP = maxHP - currentHP;
                hpRestored = Math.floor(missingHP * 0.5);
            } else {
                hpRestored = maxHP - currentHP;
            }

            const newHP = Math.min(currentHP + hpRestored, maxHP);

            // Update player HP
            playerCharacter.currentHp = newHP;
            localStorage.setItem(`playerCharacter_${currentUser}`, JSON.stringify(playerCharacter));
            if (typeof renderPlayerCharacter === 'function') {
                renderPlayerCharacter();
            } else {
                renderCharacterSheet(playerCharacter, { skipGameUpdate: false });
                updateRestButtons();
            }
            renderDeathSaveTracker(playerCharacter, newHP, maxHP);

            // Show summary
            const restTypeLabel = restType === 'short' ? 'Short Rest' : 'Long Rest';
            const restIcon = restType === 'short' ? '' : '';

            let summaryHTML = `
                <div style="margin-bottom: 10px;">
                    ${restIcon} <strong>${actorName}</strong> took a <strong>${restTypeLabel}</strong>
                </div>
                <div style="color: #10b981;">
                     HP Restored: <strong>+${hpRestored}</strong> (${currentHP}  ${newHP} / ${maxHP})
                </div>
            `;

            document.getElementById('restResultContent').innerHTML = summaryHTML;
            document.getElementById('restResultSummary').style.display = 'block';

            // Hide summary after 3 seconds
            setTimeout(() => {
                document.getElementById('restResultSummary').style.display = 'none';
            }, 3000);

            resetSpellResources(restType).catch(err => console.error('Failed to reset spell resources', err));
            resetClassResourcesForRest(restType);
        }
        function updateRestButtons() {
            const shortBtn = document.getElementById('shortRestBtn');
            const charges = playerCharacter?.shortRestCharges ?? 2;
            if (shortBtn) {
                shortBtn.textContent = `Short (${charges})`;
                shortBtn.disabled = charges <= 0;
                shortBtn.style.opacity = charges <= 0 ? 0.5 : 1;
            }
        }

        function renderPlayerCharacter() {
            if (!playerCharacter) return;
            renderCharacterSheet(playerCharacter, { skipGameUpdate: false });
            updateRestButtons();
        }

        function showPlayerRestSummary(charId, message, isError = false) {
            const summary = document.getElementById(`playerRestSummary-${charId}`);
            if (!summary) return;
            summary.style.display = 'block';
            summary.style.color = isError ? '#f97316' : '#c084fc';
            summary.style.borderLeftColor = isError ? '#f97316' : 'rgba(192, 132, 252, 0.6)';
            summary.textContent = message;
            clearTimeout(summary._timeout);
            summary._timeout = setTimeout(() => {
                summary.style.display = 'none';
            }, 4000);
        }

        async function triggerPlayerRest(characterId, restType) {
            const character = campaignPlayers.find(c => c.id === characterId);
            if (!character) {
                showPlayerRestSummary(characterId, 'Character not found.', true);
                return;
            }

            const maxHP = character.maxHp ?? character.hp ?? 0;
            const currentHP = character.currentHp ?? character.hp ?? 0;
            if (!maxHP) {
                showPlayerRestSummary(characterId, 'Max HP unknown, cannot apply rest.', true);
                return;
            }

            const missingHP = Math.max(maxHP - currentHP, 0);
            if (missingHP === 0) {
                showPlayerRestSummary(characterId, 'Already at full health.');
                return;
            }

            let hpRestored = restType === 'long'
                ? missingHP
                : Math.max(1, Math.floor(missingHP * 0.5));
            const newHP = Math.min(currentHP + hpRestored, maxHP);

            const restLabel = restType === 'long' ? 'Long Rest' : 'Short Rest';
            const previousHP = character.currentHp ?? character.hp ?? 0;
            character.currentHp = newHP;
            character.hp = newHP;

            try {
                const response = await fetch(`/player/${character.id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(character)
                });
                const data = await response.json();
                if (!data.success) {
                    throw new Error(data.error || 'Failed to save rest results.');
                }

                const hpLabel = document.getElementById(`playerHp-${character.id}`);
                if (hpLabel) {
                    hpLabel.textContent = `${newHP} / ${maxHP}`;
                }
                showPlayerRestSummary(
                    character.id,
                    `${restLabel}: Restored ${hpRestored} HP (${previousHP}  ${newHP}).`
                );
            } catch (error) {
                console.error('Failed to apply rest:', error);
                character.currentHp = previousHP;
                character.hp = previousHP;
                showPlayerRestSummary(
                    character.id,
                    'Unable to save rest results. Please try again.',
                    true
                );
            }
        }

        // Conditions System Functions
        let conditionsActorId = null;
        let conditionsActorType = null;

        const D5E_CONDITIONS = [
            { name: 'Blinded', icon: '', color: '#64748b', description: 'Cannot see, attacks have disadvantage' },
            { name: 'Charmed', icon: '', color: '#ec4899', description: 'Cannot attack charmer, charmer has advantage on social checks' },
            { name: 'Deafened', icon: '', color: '#6b7280', description: 'Cannot hear, auto-fail ability checks requiring hearing' },
            { name: 'Frightened', icon: '', color: '#f59e0b', description: 'Disadvantage on checks while source is in sight' },
            { name: 'Grappled', icon: '', color: '#8b5cf6', description: 'Speed becomes 0' },
            { name: 'Incapacitated', icon: '', color: '#ef4444', description: 'Cannot take actions or reactions' },
            { name: 'Invisible', icon: '', color: '#a3e635', description: 'Impossible to see, attacks have advantage' },
            { name: 'Paralyzed', icon: '', color: '#06b6d4', description: 'Incapacitated, auto-fail STR/DEX saves, attacks have advantage' },
            { name: 'Petrified', icon: '', color: '#78716c', description: 'Transformed into solid substance, incapacitated' },
            { name: 'Poisoned', icon: '', color: '#22c55e', description: 'Disadvantage on attack rolls and ability checks' },
            { name: 'Prone', icon: '', color: '#f97316', description: 'Disadvantage on attacks, melee attacks have advantage' },
            { name: 'Restrained', icon: '', color: '#64748b', description: 'Speed 0, disadvantage on DEX saves' },
            { name: 'Stunned', icon: '', color: '#fbbf24', description: 'Incapacitated, auto-fail STR/DEX saves' },
            { name: 'Unconscious', icon: '', color: '#1e293b', description: 'Incapacitated, prone, auto-fail STR/DEX saves' }
        ];

        function openConditionsModal(actorId, actorType) {
            conditionsActorId = actorId;
            conditionsActorType = actorType;

            // Get actor's current conditions
            let actor = null;
            if (actorType === 'npc') {
                actor = npcs.find(n => n.id === actorId);
            } else {
                actor = playerCharacter;
            }

            const currentConditions = actor?.conditions || [];

            // Populate conditions list
            let html = '';
            D5E_CONDITIONS.forEach(condition => {
                const isActive = currentConditions.includes(condition.name);
                const bgColor = isActive ? condition.color : 'rgba(71, 85, 105, 0.3)';
                const borderColor = isActive ? condition.color : '#475569';
                const opacity = isActive ? '1' : '0.6';

                html += `
                    <div onclick="toggleCondition('${condition.name}')" style="
                        cursor: pointer;
                        padding: 12px;
                        background: ${bgColor};
                        border: 2px solid ${borderColor};
                        border-radius: 6px;
                        opacity: ${opacity};
                        transition: all 0.2s;
                    " onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='${opacity}'">
                        <div style="font-size: 20px; margin-bottom: 4px;">${condition.icon}</div>
                        <div style="font-weight: 600; font-size: 13px; color: white;">${condition.name}</div>
                        <div style="font-size: 10px; color: rgba(255,255,255,0.8); margin-top: 4px; line-height: 1.3;">${condition.description}</div>
                    </div>
                `;
            });

            document.getElementById('conditionsList').innerHTML = html;
            updateActiveConditionsSummary();
            document.getElementById('conditionsModal').classList.add('active');
        }

        function closeConditionsModal() {
            document.getElementById('conditionsModal').classList.remove('active');
            conditionsActorId = null;
            conditionsActorType = null;
        }

        async function toggleCondition(conditionName) {
            if (!conditionsActorId || !conditionsActorType) return;

            let actor = null;
            if (conditionsActorType === 'npc') {
                actor = npcs.find(n => n.id === conditionsActorId);
            } else {
                actor = playerCharacter;
            }

            if (!actor) return;

            // Initialize conditions array if it doesn't exist
            if (!actor.conditions) {
                actor.conditions = [];
            }

            // Toggle condition
            const index = actor.conditions.indexOf(conditionName);
            if (index > -1) {
                actor.conditions.splice(index, 1);
            } else {
                actor.conditions.push(conditionName);
            }

            // Save based on actor type
            if (conditionsActorType === 'npc') {
                try {
                    await fetch(`/npc/${conditionsActorId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(actor)
                    });
                } catch (error) {
                    console.error('Error saving NPC conditions:', error);
                }
                renderNPCList();
            } else {
                localStorage.setItem(`playerCharacter_${currentUser}`, JSON.stringify(actor));
                renderPlayerCharacter();
            }

            // Refresh the modal
            openConditionsModal(conditionsActorId, conditionsActorType);
        }

        function updateActiveConditionsSummary() {
            let actor = null;
            if (conditionsActorType === 'npc') {
                actor = npcs.find(n => n.id === conditionsActorId);
            } else {
                actor = playerCharacter;
            }

            const activeConditions = actor?.conditions || [];

            if (activeConditions.length > 0) {
                const conditionLabels = activeConditions.map(name => {
                    const condition = D5E_CONDITIONS.find(c => c.name === name);
                    return `${condition.icon} ${name}`;
                }).join(', ');

                document.getElementById('activeConditionsContent').innerHTML = conditionLabels;
                document.getElementById('activeConditionsSummary').style.display = 'block';
            } else {
                document.getElementById('activeConditionsSummary').style.display = 'none';
            }
        }

        function getConditionBadges(actor) {
            if (!actor || !actor.conditions || actor.conditions.length === 0) {
                return '';
            }

            return actor.conditions.map(conditionName => {
                const condition = D5E_CONDITIONS.find(c => c.name === conditionName);
                if (!condition) return '';
                return `<span style="background: ${condition.color}; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; margin-left: 4px; display: inline-block;">${condition.icon} ${conditionName}</span>`;
            }).join('');
        }

        function rollAttack() {
            const bonus = parseInt(document.getElementById('attackBonus').value) || 0;
            const roll = Math.floor(Math.random() * 20) + 1;
            const total = roll + bonus;

            attackRollResult = { roll, bonus, total, isCrit: roll === 20 };

            document.getElementById('attackRollTotal').textContent = total;
            document.getElementById('attackRollBreakdown').textContent = `d20: ${roll} + ${bonus}`;
            document.getElementById('attackRollResult').style.display = 'block';

            if (roll === 20) {
                document.getElementById('attackRollTotal').style.color = '#fbbf24';
                document.getElementById('attackRollBreakdown').textContent += ' (CRITICAL HIT!)';
            } else if (roll === 1) {
                document.getElementById('attackRollTotal').style.color = '#ef4444';
                document.getElementById('attackRollBreakdown').textContent += ' (Critical Miss)';
            } else {
                document.getElementById('attackRollTotal').style.color = '#fff';
            }

            postDiceLog({ label: 'Attack Roll', sides: 20, roll, modifier: bonus, total });
        }

        function rollDamage() {
            const diceStr = document.getElementById('attackDamage').value.trim();
            if (!diceStr) {
                showThemedAlert('Please enter damage dice (e.g., 1d8+3)');
                return;
            }

            const result = rollDiceString(diceStr);
            damageRollResult = result;

            document.getElementById('damageRollTotal').textContent = result.total;
            document.getElementById('damageRollBreakdown').textContent = result.breakdown;
            document.getElementById('damageRollResult').style.display = 'block';

            postDiceLog({
                label: 'Damage Roll',
                expression: diceStr,
                sides: null,
                roll: result.total - (result.modifier || 0),
                modifier: result.modifier || 0,
                total: result.total
            });
        }

        async function submitAttack() {
            if (!attackRollResult) {
                showThemedAlert('Please roll attack first');
                return;
            }

            // Get weapon name from either inventory or custom input
            let weaponName = '';
            const weaponSource = document.querySelector('input[name="weaponSource"]:checked').value;

            if (weaponSource === 'inventory') {
                const weaponSelect = document.getElementById('weaponFromInventory');
                const weaponIndex = parseInt(weaponSelect.value);
                if (isNaN(weaponIndex) || weaponIndex < 0) {
                    showThemedAlert('Please select a weapon from inventory');
                    return;
                }

                // Get weapon from appropriate inventory based on actor type
                let weapon = null;
                if (currentActorType === 'npc') {
                    const npc = npcs.find(n => n.id === currentActorId);
                    if (npc && npc.inventory && Array.isArray(npc.inventory)) {
                        weapon = npc.inventory[weaponIndex];
                    }
                } else {
                    weapon = playerInventory[weaponIndex];
                }

                if (!weapon) {
                    showThemedAlert('Selected weapon not found in inventory');
                    return;
                }
                weaponName = weapon.name;
            } else {
                weaponName = document.getElementById('attackName').value.trim();
                if (!weaponName) {
                    showThemedAlert('Please enter weapon/attack name');
                    return;
                }
            }

            const targetRadio = document.querySelector('input[name="attackTargetListTarget"]:checked');
            if (!targetRadio) {
                showThemedAlert('Please select a target');
                return;
            }

            const targetId = parseInt(targetRadio.value);
            const targetType = targetRadio.dataset.type;

            const actionType = document.querySelector('input[name="attackActionType"]:checked').value;
            const damageTypeSelect = document.getElementById('attackDamageType');
            const attackDamageType = damageTypeSelect
                ? (normalizeDamageTypeClient(damageTypeSelect.value) || '')
                : '';

            let damage = damageRollResult ? damageRollResult.total : 0;
            let rageBonusAmount = 0;
            const actingCharacter = getCharacterDataForActor(currentActorId, currentActorType);
            if (actingCharacter) {
                const rageContext = await computeBarbarianRageBonus(actingCharacter, attackDamageType);
                if (rageContext.active) {
                    rageBonusAmount = rageContext.bonus;
                    damage += rageBonusAmount;
                }
            }

            try {
                const response = await fetch(`/encounter/${activeEncounter.id}/action/attack`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        actorId: currentActorId,
                        actorType: currentActorType,
                        targetId: targetId,
                        targetType: targetType,
                        attackRoll: attackRollResult.roll,
                        attackBonus: attackRollResult.bonus,
                        damage: damage,
                        damageType: attackDamageType || 'physical',
                        weaponName: weaponName,
                        actionType: actionType,
                        isCrit: attackRollResult.isCrit,
                        rageBonus: rageBonusAmount
                    })
                });

                const data = await response.json();

                if (data.success) {
                    closeAttackModal();

                    // Show combat result modal
                    const encounter = data.encounter;
                    const lastLogEntry = encounter.combatLog[encounter.combatLog.length - 1];

                    if (lastLogEntry && lastLogEntry.type === 'attack') {
                        setTimeout(() => {
                            showCombatResult(lastLogEntry);
                        }, 100);
                    }

                    if (rageBonusAmount > 0) {
                        showLevelToast(`Rage adds +${rageBonusAmount} damage!`, 'success');
                    }
                    await pollCombatStatus();
                } else {
                    showThemedAlert('Failed to perform attack: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error submitting attack:', error);
                showThemedAlert('Failed to submit attack: ' + error.message);
            }
        }

        // === SPELL MODAL ===

        function openSpellModal(actorId, actorType, actorName) {
            currentActorId = actorId;
            currentActorType = actorType;
            currentActorName = actorName;
            spellEffectRollResult = null;
            forcePlayerSpellSelection = shouldUsePlayerSpellListForActor(actorId, actorType);
            setSpellFormLocked(forcePlayerSpellSelection);
            clearSpellSelection();
            if (forcePlayerSpellSelection) {
                renderSpellSelectionList();
            } else {
                const section = document.getElementById('spellSelectionSection');
                if (section) section.style.display = 'none';
            }

            // Reset form
            document.getElementById('spellName').value = '';
            document.getElementById('spellLevel').value = '1';
            document.getElementById('spellDice').value = '';
            document.getElementById('spellMultiTarget').checked = false;
            document.getElementById('spellEffectResult').style.display = 'none';
            document.getElementById('spellDiceGroup').style.display = 'block';
            populateDamageTypeSelect('spellDamageType');
            setDamageTypeSelectValue('spellDamageType', '');
            document.getElementById('spellDamageTypeGroup').style.display = 'none';

            // Reset to damage
            selectSpellType('damage');

            // Populate targets
            populateTargetList('spellTargetList', false);

            document.getElementById('spellModal').classList.add('active');
        }

        function closeSpellModal() {
            document.getElementById('spellModal').classList.remove('active');
            clearSpellSelection();
            forcePlayerSpellSelection = false;
        }

        function rollSpellEffect() {
            const diceInput = document.getElementById('spellDice');
            const diceStrRaw = diceInput ? diceInput.value.trim() : '';
            if (!diceStrRaw) {
                showThemedAlert('Please enter dice (e.g., 3d6)');
                return;
            }

            const diceStr = diceStrRaw.replace(/\s+/g, '');
            const effectMeta = resolveCurrentSpellEffect();
            if (effectMeta) {
                applySpellTargetingDefaults(effectMeta);
                if (effectMeta.damageType) {
                    setDamageTypeSelectValue('spellDamageType', effectMeta.damageType);
                }
            }
            const configuredInstances = effectMeta?.instances && effectMeta.instances > 1 ? effectMeta.instances : 1;
            const perInstanceRoll = !!(effectMeta?.perInstanceRoll && configuredInstances > 1);
            const instanceLabel = effectMeta?.instanceLabel || 'Instance';

            const applyAbility = !perInstanceRoll && forcePlayerSpellSelection && effectMeta?.addAbilityMod;
            let abilityMod = 0;
            let total = 0;
            let breakdown = '';

            if (perInstanceRoll) {
                const perInstanceTotals = [];
                const perInstanceBreakdowns = [];
                for (let i = 0; i < configuredInstances; i++) {
                    const result = rollDiceString(diceStr);
                    perInstanceTotals.push(result.total);
                    perInstanceBreakdowns.push(`${instanceLabel} ${i + 1}: ${result.breakdown}`);
                    total += result.total;

                    postDiceLog({
                        label: `${label} (${instanceLabel} ${i + 1})`,
                        expression: diceStr,
                        roll: result.total - (result.modifier || 0),
                        modifier: (result.modifier || 0),
                        total: result.total
                    });
                }
                breakdown = perInstanceBreakdowns.join(' | ');
                spellEffectRollResult = {
                    total,
                    breakdown,
                    abilityModApplied: 0,
                    perInstanceRoll: true,
                    perInstanceTotals,
                    instanceCount: configuredInstances
                };
            } else {
                const result = rollDiceString(diceStr);
                total = result.total;
                breakdown = result.breakdown;

                if (applyAbility) {
                    abilityMod = getSpellcastingAbilityModifier();
                    if (abilityMod) {
                        total += abilityMod;
                        breakdown += abilityMod >= 0 ? ` + ${abilityMod}` : ` - ${Math.abs(abilityMod)}`;
                    }
                }

                spellEffectRollResult = {
                    ...result,
                    total,
                    breakdown,
                    abilityModApplied: abilityMod,
                    perInstanceRoll: false,
                    perInstanceTotals: null,
                    instanceCount: 1
                };

                postDiceLog({
                    label: `${label} Roll`,
                    expression: diceStr,
                    roll: result.total - (result.modifier || 0),
                    modifier: (result.modifier || 0) + abilityMod,
                    total
                });
            }

            const spellType = document.querySelector('input[name="spellType"]:checked').value;
            let label = 'Damage';
            if (spellType === 'healing') {
                label = 'Healing';
            } else if (spellType === 'other') {
                label = 'Effect';
            }

            document.getElementById('spellEffectLabel').textContent = label;
            document.getElementById('spellEffectTotal').textContent = total;
            document.getElementById('spellEffectBreakdown').textContent = breakdown;
            document.getElementById('spellEffectResult').style.display = 'block';
        }

        async function submitSpell() {
            let spellName = document.getElementById('spellName').value.trim();
            let spellLevel = parseInt(document.getElementById('spellLevel').value, 10);
            const preparedSpell = selectedSpellId ? SPELL_INDEX[selectedSpellId] : null;

            if (forcePlayerSpellSelection) {
                if (!preparedSpell) {
                    showThemedAlert('Select one of your prepared or known spells to cast.');
                    return;
                }
                spellName = preparedSpell.name;
                spellLevel = preparedSpell.level;
            } else if (!spellName) {
                showThemedAlert('Please enter spell name');
                return;
            }

            if (Number.isNaN(spellLevel)) {
                spellLevel = 0;
            }

            const spellType = document.querySelector('input[name="spellType"]:checked').value;
            const actionType = document.querySelector('input[name="spellActionType"]:checked').value;
            const multiTarget = document.getElementById('spellMultiTarget').checked;
            const effectData = resolveCurrentSpellEffect(spellName);

            // Get selected targets
            let targetIds = [];
            let targetTypes = [];

            if (multiTarget) {
                const checked = document.querySelectorAll('input[name="spellTargetListTarget"]:checked');
                if (checked.length === 0) {
                    showThemedAlert('Please select at least one target');
                    return;
                }
                checked.forEach(cb => {
                    targetIds.push(parseInt(cb.value));
                    targetTypes.push(cb.dataset.type);
                });
            } else {
                const targetRadio = document.querySelector('input[name="spellTargetListTarget"]:checked');
                if (!targetRadio) {
                    showThemedAlert('Please select a target');
                    return;
                }
                targetIds = [parseInt(targetRadio.value)];
                targetTypes = [targetRadio.dataset.type];
            }

            if (multiTarget && effectData?.perInstanceRoll && effectData.instances && targetIds.length > effectData.instances) {
                showThemedAlert(`${spellName} can target up to ${effectData.instances} creature(s) with this casting. Select fewer targets or disable multiple targeting.`);
                return;
            }

            let damage = null;
            let healing = null;
            const hasInstanceTotals = Array.isArray(spellEffectRollResult?.perInstanceTotals) && spellEffectRollResult.perInstanceTotals.length;

            if (spellType === 'damage' && spellEffectRollResult) {
                if (hasInstanceTotals) {
                    if (multiTarget && targetIds.length > 1) {
                        const allocations = distributeInstanceTotals(targetIds.length, spellEffectRollResult.perInstanceTotals);
                        damage = targetIds.map((_, idx) => allocations[idx] || 0);
                    } else {
                        const aggregate = spellEffectRollResult.perInstanceTotals.reduce((sum, value) => sum + value, 0);
                        damage = targetIds.map(() => aggregate);
                    }
                } else {
                    damage = targetIds.map(() => spellEffectRollResult.total);
                }
            } else if (spellType === 'healing' && spellEffectRollResult) {
                if (hasInstanceTotals) {
                    if (multiTarget && targetIds.length > 1) {
                        const allocations = distributeInstanceTotals(targetIds.length, spellEffectRollResult.perInstanceTotals);
                        healing = targetIds.map((_, idx) => allocations[idx] || 0);
                    } else {
                        const aggregate = spellEffectRollResult.perInstanceTotals.reduce((sum, value) => sum + value, 0);
                        healing = targetIds.map(() => aggregate);
                    }
                } else {
                    healing = targetIds.map(() => spellEffectRollResult.total);
                }
            }

            const manualDamageTypeSelect = document.getElementById('spellDamageType');
            const manualDamageType = spellType === 'damage' && manualDamageTypeSelect
                ? normalizeDamageTypeClient(manualDamageTypeSelect.value)
                : '';
            const finalDamageType = spellType === 'damage'
                ? (manualDamageType || effectData?.damageType || 'magical')
                : null;

            try {
                const response = await fetch(`/encounter/${activeEncounter.id}/action/spell`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        actorId: currentActorId,
                        actorType: currentActorType,
                        targetIds: targetIds,
                        targetTypes: targetTypes,
                        spellName,
                        spellLevel,
                        damage: damage,
                        damageType: finalDamageType,
                        healing: healing,
                        actionType: actionType
                    })
                });

                const data = await response.json();

                if (data.success) {
                    closeSpellModal();
                    await pollCombatStatus();
                } else {
                    showThemedAlert('Failed to cast spell: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error casting spell:', error);
                showThemedAlert('Failed to cast spell');
            }
        }

        // === OTHER ACTION MODAL ===

        function openOtherActionModal(actorId, actorType, actorName) {
            currentActorId = actorId;
            currentActorType = actorType;
            currentActorName = actorName;

            // Reset form
            document.getElementById('otherActionName').value = 'Dash';
            document.getElementById('customActionGroup').style.display = 'none';
            document.getElementById('customActionName').value = '';
            document.getElementById('otherActionDescription').value = '';

            document.getElementById('otherActionModal').classList.add('active');
        }

        function closeOtherActionModal() {
            document.getElementById('otherActionModal').classList.remove('active');
        }

        async function submitOtherAction() {
            let actionName = document.getElementById('otherActionName').value;

            if (actionName === 'Custom') {
                const customName = document.getElementById('customActionName').value.trim();
                if (!customName) {
                    showThemedAlert('Please enter custom action name');
                    return;
                }
                actionName = customName;
            }

            const description = document.getElementById('otherActionDescription').value.trim();
            const actionType = document.querySelector('input[name="otherActionType"]:checked').value;

            try {
                const response = await fetch(`/encounter/${activeEncounter.id}/action/other`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        actorId: currentActorId,
                        actorType: currentActorType,
                        actionName: actionName,
                        actionType: actionType,
                        description: description
                    })
                });

                const data = await response.json();

                if (data.success) {
                    closeOtherActionModal();
                    await pollCombatStatus();
                } else {
                    showThemedAlert('Failed to perform action: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error performing action:', error);
                showThemedAlert('Failed to perform action');
            }
        }

        // Handle custom action dropdown
        document.addEventListener('DOMContentLoaded', function() {
            const actionSelect = document.getElementById('otherActionName');
            const customGroup = document.getElementById('customActionGroup');

            if (actionSelect && customGroup) {
                actionSelect.addEventListener('change', function() {
                    if (this.value === 'Custom') {
                        customGroup.style.display = 'block';
                    } else {
                        customGroup.style.display = 'none';
                    }
                });
            }

            // Handle spell multi-target checkbox
            const multiTargetCheck = document.getElementById('spellMultiTarget');
            if (multiTargetCheck) {
                multiTargetCheck.addEventListener('change', function() {
                    const container = document.getElementById('spellTargetList');
                    populateTargetList('spellTargetList', this.checked);
                });
            }
        });

        // === USE ITEM MODAL ===

        let selectedItemIndex = null;
        let useItemEffectResult = null;
        let currentItemDiceString = null;
        let currentItemEffectType = null; // 'healing' or 'damage'

        function openUseItemModal(actorId, actorType, actorName) {
            currentActorId = actorId;
            currentActorType = actorType;
            currentActorName = actorName;
            selectedItemIndex = null;
            useItemEffectResult = null;

            // Reset form
            document.getElementById('useItemResult').style.display = 'none';
            document.getElementById('useItemTargetGroup').style.display = 'none';

            // Populate usable items (potions, consumables)
            populateUsableItems();

            document.getElementById('useItemModal').classList.add('active');
        }

        function closeUseItemModal() {
            document.getElementById('useItemModal').classList.remove('active');
            selectedItemIndex = null;
            useItemEffectResult = null;
            currentItemDiceString = null;
            currentItemEffectType = null;
        }

        function populateUsableItems() {
            const container = document.getElementById('usableItemsList');

            let inventory = [];
            if (currentActorType === 'npc') {
                const npc = npcs.find(n => n.id === currentActorId);
                if (npc && npc.inventory && Array.isArray(npc.inventory)) {
                    inventory = npc.inventory;
                }
            } else {
                inventory = playerInventory;
            }

            const usableItems = inventory.filter(item =>
                item.category === 'potion' ||
                item.category === 'consumable' ||
                (item.effect && item.effect.type)
            );

            if (usableItems.length === 0) {
                container.innerHTML = '<div style="color: #888; padding: 20px;">No usable items in inventory</div>';
                return;
            }

            let html = '';
            usableItems.forEach(item => {
                const realIndex = inventory.indexOf(item);
                let icon = '';
                if (item.category === 'potion') icon = '';
                if (item.effect?.type === 'damage') icon = '';

                let effectText = '';
                let effectColor = '#10b981';

                if (item.effect?.type === 'healing') {
                    effectText = `Heals ${item.effect.dice || ''}`;
                    effectColor = '#10b981';
                } else if (item.effect?.type === 'damage') {
                    effectText = `Damage ${item.effect.dice || ''} ${item.effect.damageType || ''}`;
                    effectColor = '#ef4444';
                } else if (item.effect?.description) {
                    effectText = item.effect.description;
                    effectColor = '#a5b4fc';
                }

                html += `
                    <label class="target-option" style="cursor: pointer;">
                        <input type="radio" name="selectedItem" value="${realIndex}" onchange="handleUseItemSelection(${realIndex})">
                        <span>
                            <span style="font-size: 18px; margin-right: 8px;">${icon}</span>
                            <strong>${item.name}</strong>
                            ${effectText ? `<br><span style="font-size: 12px; color: ${effectColor};">${effectText}</span>` : ''}
                            ${item.description ? `<br><span style="font-size: 12px; color: #94a3b8;">${item.description}</span>` : ''}
                            <br><span style="font-size: 12px; color: #64748b;">Qty: ${item.quantity || 1}</span>
                        </span>
                    </label>
                `;
            });

            container.innerHTML = html;
        }

        function handleUseItemSelection(itemIndex) {
            selectedItemIndex = itemIndex;
            useItemEffectResult = null;
            currentItemDiceString = null;
            currentItemEffectType = null;

            let item = null;
            if (currentActorType === 'npc') {
                const npc = npcs.find(n => n.id === currentActorId);
                if (npc && npc.inventory && Array.isArray(npc.inventory)) {
                    item = npc.inventory[itemIndex];
                }
            } else {
                item = playerInventory[itemIndex];
            }
            if (!item) return;

            const effect = item.effect || null;
            const needsTarget = effect && (effect.type === 'healing' || effect.type === 'damage');
            document.getElementById('useItemTargetGroup').style.display = needsTarget ? 'block' : 'none';
            if (needsTarget) {
                populateTargetList('useItemTargetList', false);
            }

            if (effect?.dice) {
                currentItemDiceString = effect.dice;
                currentItemEffectType = effect.type;
                const label = effect.type === 'damage' ? 'Damage' : effect.type === 'healing' ? 'Healing' : 'Effect';
                document.getElementById('useItemRollLabel').textContent = label;
                document.getElementById('useItemResultLabel').textContent = label;
                document.getElementById('useItemDiceNotation').textContent = effect.dice;
                document.getElementById('useItemRollSection').style.display = 'block';
                document.getElementById('useItemResult').style.display = 'none';
            } else {
                document.getElementById('useItemRollSection').style.display = 'none';
                document.getElementById('useItemResult').style.display = 'none';
            }
        }

        function rollItemEffect() {
            if (!currentItemDiceString) {
                showThemedAlert('No dice to roll');
                return;
            }

            const result = rollDiceString(currentItemDiceString);
            useItemEffectResult = result;

            document.getElementById('useItemEffectTotal').textContent = result.total;
            document.getElementById('useItemEffectBreakdown').textContent = result.breakdown;
            document.getElementById('useItemResult').style.display = 'block';

             postDiceLog({
                 label: currentItemEffectType === 'healing' ? 'Item Healing' : 'Item Effect',
                 expression: currentItemDiceString,
                 roll: result.total - (result.modifier || 0),
                 modifier: result.modifier || 0,
                 total: result.total
             });
        }

        async function submitUseItem() {
            if (selectedItemIndex === null) {
                showThemedAlert('Please select an item to use');
                return;
            }

            // Get item from appropriate inventory
            let item = null;
            if (currentActorType === 'npc') {
                const npc = npcs.find(n => n.id === currentActorId);
                if (npc && npc.inventory && Array.isArray(npc.inventory)) {
                    item = npc.inventory[selectedItemIndex];
                }
            } else {
                item = playerInventory[selectedItemIndex];
            }

            if (!item) {
                showThemedAlert('Item not found in inventory');
                return;
            }

            const actionType = document.querySelector('input[name="useItemActionType"]:checked').value;

            // Get target if needed
            let targetId = null;
            let targetType = null;

            const effect = item.effect || null;
            if (effect && (effect.type === 'healing' || effect.type === 'damage')) {
                const targetRadio = document.querySelector('input[name="useItemTargetListTarget"]:checked');
                if (!targetRadio) {
                    showThemedAlert('Please select a target');
                    return;
                }
                if (effect.dice && !useItemEffectResult) {
                    showThemedAlert('Please roll the effect first');
                    return;
                }

                targetId = parseInt(targetRadio.value);
                targetType = targetRadio.dataset.type;
            }

            try {
                const response = await fetch(`/encounter/${activeEncounter.id}/action/use-item`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        actorId: currentActorId,
                        actorType: currentActorType,
                        itemName: item.name,
                        itemType: item.category || item.type,
                        itemEffect: effect ? effect.type : null,
                        effectDescription: effect ? effect.description || '' : '',
                        effectDice: effect ? effect.dice || '' : '',
                        effectDamageType: effect ? effect.damageType || '' : '',
                        healAmount: effect?.type === 'healing' && useItemEffectResult ? useItemEffectResult.total : 0,
                        healBreakdown: useItemEffectResult ? useItemEffectResult.breakdown : '',
                        damageAmount: effect?.type === 'damage' && useItemEffectResult ? useItemEffectResult.total : 0,
                        targetId: targetId,
                        targetType: targetType,
                        actionType: actionType
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // Reduce item quantity or remove item
                    if (currentActorType === 'npc') {
                        // For NPCs, update their inventory and save to backend
                        const npc = npcs.find(n => n.id === currentActorId);
                        if (npc && npc.inventory) {
                            if (item.quantity && item.quantity > 1) {
                                npc.inventory[selectedItemIndex].quantity--;
                            } else {
                                npc.inventory.splice(selectedItemIndex, 1);
                            }

                            // Save NPC inventory to backend
                            await fetch(`/npc/${currentActorId}`, {
                                method: 'PUT',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(npc)
                            });

                            await loadNPCs();
                        }
                    } else {
                        // For players, update local inventory
                        if (item.quantity && item.quantity > 1) {
                            playerInventory[selectedItemIndex].quantity--;
                        } else {
                            playerInventory.splice(selectedItemIndex, 1);
                        }
                        saveInventory();
                        renderInventory();
                    }

                    closeUseItemModal();
                    await pollCombatStatus();
                } else {
                    showThemedAlert('Failed to use item: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error using item:', error);
                showThemedAlert('Failed to use item');
            }
        }

        // === END TURN ===

        async function endParticipantTurn() {
            if (!activeEncounter) {
                showThemedAlert('No active encounter to advance.');
                return;
            }

            const sorted = getSortedParticipants({ includeHidden: true });
            const currentIndex = hasValue(activeEncounter?.currentTurn) ? activeEncounter.currentTurn : 0;
            const current = sorted[currentIndex];
            if (current) {
                const display = getParticipantDisplay(current);
                const isPlayer = current.type === 'player';
                const hp = display.hp || 0;
                const state = isPlayer ? getDeathSaveState(display.entity?.id || current.id) : { successes: 0, fails: 0 };
                const needsDeathSave = isPlayer && hp <= 0 && state.fails < 3 && state.successes < 3 && !deathSaveRolledThisTurn;
                if (needsDeathSave) {
                    showThemedAlert('Roll a death saving throw before ending your turn.');
                    return;
                }
            }

            const endpoints = [
                `/encounter/${activeEncounter.id}/end-turn`,
                `/encounter/${activeEncounter.id}/next-turn`
            ];

            for (const url of endpoints) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    const data = await response.json();
                    if (data.success) {
                        await pollCombatStatus();
                        return;
                    }
                    console.warn('End turn attempt failed', { url, data });
                } catch (error) {
                    console.error('Error ending turn via', url, error);
                }
            }

            showThemedAlert('Failed to end turn: no response from server');
        }

        // Dice rolling utility
        function rollDiceString(diceStr) {
            const sanitized = (diceStr || '').replace(/\s+/g, '');
            const match = sanitized.match(/^(\d+)d(\d+)([+\-]\d+)?$/i);
            if (!match) {
                return { total: 0, breakdown: 'Invalid dice format' };
            }

            const count = parseInt(match[1]);
            const sides = parseInt(match[2]);
            const modifier = match[3] ? parseInt(match[3]) : 0;

            const rolls = [];
            let sum = 0;

            for (let i = 0; i < count; i++) {
                const roll = Math.floor(Math.random() * sides) + 1;
                rolls.push(roll);
                sum += roll;
            }

            const total = sum + modifier;
            const breakdown = `${count}d${sides}: [${rolls.join(', ')}]${modifier !== 0 ? ` ${modifier >= 0 ? '+' : ''}${modifier}` : ''} = ${total}`;

            return { total, breakdown, rolls, modifier };
        }

        // Update Game UI
        function updateGameUI(character) {
            if (!character) return;

            // maxHp is from stat sheet, never changes
            const maxHP = character.maxHp || character.hp || 0;

            // Current HP starts at max
            let currentHP = maxHP;

            // During combat, get current HP from encounter participant data
            if (activeEncounter && activeEncounter.participants) {
                const playerParticipant = activeEncounter.participants.find(p =>
                    p.type === 'player' && p.id === currentUser.id
                );
                if (playerParticipant) {
                    // Use currentHp from encounter if available, otherwise default to maxHP
                    currentHP = playerParticipant.currentHp !== undefined ? playerParticipant.currentHp : maxHP;
                }
            }

            // Update health bar
            updateHealthBar(currentHP, maxHP);

            // Update stats
            document.getElementById('gameAC').textContent = calculateCharacterAC(character);
            document.getElementById('gameSpeed').textContent = (character.speed || 0) + ' ft';
            document.getElementById('gameLevel').textContent = character.level || 1;

            // Update HP input
            document.getElementById('playerHPInput').value = currentHP;
            document.getElementById('playerHPInput').max = maxHP;

            renderDeathSaveTracker(character, currentHP, maxHP);

            // Check if character is a spellcaster
            const spellcasterClasses = ['Wizard', 'Cleric', 'Sorcerer', 'Bard', 'Druid', 'Warlock', 'Paladin', 'Ranger'];
            const isSpellcaster = spellcasterClasses.includes(character.class);

            if (isSpellcaster) {
                renderSpellSlots(character).catch(err => console.error('Failed to render spell slots', err));
                document.getElementById('gameSpellSlotsSection').style.display = 'block';
            } else {
                document.getElementById('gameSpellSlotsSection').style.display = 'none';
            }

            renderCombatRageControlBar().catch(err => console.error('Failed to render combat rage control', err));
        }

        // Update Health Bar
        function updateHealthBar(current, max) {
            const healthBar = document.getElementById('gameHealthBarFill');
            const currentHPSpan = document.getElementById('gameCurrentHP');
            const maxHPSpan = document.getElementById('gameMaxHP');

            currentHPSpan.textContent = current;
            maxHPSpan.textContent = max;

            const percentage = max > 0 ? (current / max) * 100 : 0;
            healthBar.style.width = percentage + '%';

            // Remove existing classes
            healthBar.classList.remove('low', 'critical');

            // Add appropriate class based on HP percentage
            if (percentage <= 25) {
                healthBar.classList.add('critical');
            } else if (percentage <= 50) {
                healthBar.classList.add('low');
            }
        }

        // Adjust Player HP (for +/- buttons)
        function adjustPlayerHP(change) {
            const input = document.getElementById('playerHPInput');
            const currentHP = parseInt(input.value) || 0;
            const maxHP = parseInt(input.max) || 0;

            const newHP = Math.max(0, Math.min(maxHP, currentHP + change));
            input.value = newHP;

            // Update visual health bar immediately
            updateHealthBar(newHP, maxHP);
            renderDeathSaveTracker(playerCharacter, newHP, maxHP);
        }

        // Spell slot helpers (DNDOPEN progression)
        const SPELLCASTING_CLASSES = new Set(['wizard', 'cleric', 'sorcerer', 'bard', 'druid', 'warlock', 'paladin', 'ranger']);

        function getSpellcastingStorageKey(characterId) {
            return `spellSlots_${characterId}`;
        }

        function buildSpellSlotState(config) {
            if (!config) return null;
            if (config.type === 'warlock') {
                return {
                    type: 'warlock',
                    level: config.level,
                    pactTotal: config.slots,
                    pactRemaining: config.slots,
                    pactLevel: config.slotLevel
                };
            }
            return {
                type: 'slots',
                level: config.level,
                slotsRemaining: [...config.slots]
            };
        }

        function persistSpellSlotState(characterId, state) {
            const key = getSpellcastingStorageKey(characterId);
            localStorage.setItem(key, JSON.stringify(state));
        }

        function getSpellSlotState(character, config) {
            if (!character || !config) return null;
            const key = getSpellcastingStorageKey(character.id);
            let state = null;
            try {
                state = JSON.parse(localStorage.getItem(key));
            } catch {
                state = null;
            }

            const needsReset = !state || state.type !== config.type || state.level !== config.level;
            if (needsReset) {
                state = buildSpellSlotState(config);
                persistSpellSlotState(character.id, state);
                return state;
            }

            if (config.type === 'warlock') {
                state.pactTotal = config.slots;
                state.pactLevel = config.slotLevel;
                if (typeof state.pactRemaining !== 'number' || state.pactRemaining > state.pactTotal) {
                    state.pactRemaining = state.pactTotal;
                }
            } else {
                state.slotsRemaining = state.slotsRemaining || [];
                config.slots.forEach((count, idx) => {
                    if (typeof state.slotsRemaining[idx] !== 'number') {
                        state.slotsRemaining[idx] = count;
                    }
                    state.slotsRemaining[idx] = Math.min(Math.max(state.slotsRemaining[idx], 0), count);
                });
            }
            persistSpellSlotState(character.id, state);
            return state;
        }

        async function ensureSpellcastingConfig(char) {
            if (!char) return null;
            const classKey = normalizeClassKey(char.class || '');
            if (!SPELLCASTING_CLASSES.has(classKey)) return null;
            const level = char.level || 1;
            const cacheKey = `${classKey}-${level}-${char.id || 'unknown'}`;
            if (spellcastingConfigCache[cacheKey]) return spellcastingConfigCache[cacheKey];

            const progression = await fetchClassLevelInfo(classKey, level);
            if (!progression) return null;

            if (classKey === 'warlock') {
                const slots = parseInt(getProgressionValue(progression, "spellSlots"), 10) || 0;
                const slotLevel = parseInt(getProgressionValue(progression, "slotLevel"), 10) || 1;
                if (!slots) return null;
                const config = { type: 'warlock', classKey, level, slots, slotLevel };
                spellcastingConfigCache[cacheKey] = config;
                return config;
            }

            const slots = [];
            for (let i = 1; i <= 9; i++) {
                const val = parseInt(getProgressionValue(progression, `slot${i}`), 10) || 0;
                slots.push(val);
            }
            const hasSlots = slots.some(count => count > 0);
            if (!hasSlots) return null;
            const config = { type: 'slots', classKey, level, slots };
            spellcastingConfigCache[cacheKey] = config;
            return config;
        }

        async function renderSpellSlots(character) {
            const container = document.getElementById('gameSpellSlotsContainer');
            const section = document.getElementById('gameSpellSlotsSection');
            if (!container || !section) return;

            const config = await ensureSpellcastingConfig(character);
            if (!config) {
                section.style.display = 'none';
                container.innerHTML = '';
                return;
            }

            const state = getSpellSlotState(character, config);
            if (!state) {
                section.style.display = 'none';
                container.innerHTML = '';
                return;
            }

            let html = '';
            if (config.type === 'warlock') {
                const total = state.pactTotal;
                const remaining = state.pactRemaining;
                html = `
                    <div class="spell-level-row">
                        <div class="spell-level-label">Pact Slots (Level ${config.slotLevel})</div>
                        <div class="spell-slots">
                            ${Array(total).fill(0).map((_, i) => {
                                const isFilled = i < remaining;
                                return `<div class="spell-slot ${isFilled ? 'filled' : ''}" onclick="togglePactSlot(${isFilled})"></div>`;
                            }).join('')}
                        </div>
                        <div class="player-rest-summary" style="margin-top:8px;">Short/Long rest: resets pact slots.</div>
                    </div>
                `;
            } else {
                html = config.slots.map((count, index) => {
                    if (count <= 0) return '';
                    const levelNum = index + 1;
                    const remaining = state.slotsRemaining[index] ?? count;
                    const slotsHtml = Array(count).fill(0).map((_, i) => {
                        const isFilled = i < remaining;
                        return `<div class="spell-slot ${isFilled ? 'filled' : ''}" onclick="toggleSpellSlot(${index}, ${isFilled})"></div>`;
                    }).join('');
                    return `
                        <div class="spell-level-row">
                            <div class="spell-level-label">Level ${levelNum} (${remaining}/${count})</div>
                            <div class="spell-slots">${slotsHtml}</div>
                        </div>
                    `;
                }).join('');
                html += `<div class="player-rest-summary" style="margin-top:8px;">Long rest: resets all spell slots.</div>`;
            }

            container.innerHTML = html;
            section.style.display = 'block';
        }

        async function toggleSpellSlot(levelIndex, wasFilled) {
            if (!playerCharacter) return;
            const alreadyFilled = wasFilled === true || wasFilled === 'true';
            const config = await ensureSpellcastingConfig(playerCharacter);
            if (!config || config.type !== 'slots') return;
            const state = getSpellSlotState(playerCharacter, config);
            if (!state) return;

            const max = config.slots[levelIndex] || 0;
            const current = state.slotsRemaining[levelIndex] ?? max;
            if (alreadyFilled) {
                state.slotsRemaining[levelIndex] = Math.max(0, current - 1);
            } else {
                state.slotsRemaining[levelIndex] = Math.min(max, current + 1);
            }
            persistSpellSlotState(playerCharacter.id, state);
            renderSpellSlots(playerCharacter).catch(err => console.error('Failed to render spell slots', err));
        }

        async function togglePactSlot(wasFilled) {
            if (!playerCharacter) return;
            const config = await ensureSpellcastingConfig(playerCharacter);
            if (!config || config.type !== 'warlock') return;
            const state = getSpellSlotState(playerCharacter, config);
            if (!state) return;

            if (wasFilled) {
                state.pactRemaining = Math.max(0, state.pactRemaining - 1);
            } else {
                state.pactRemaining = Math.min(state.pactTotal, state.pactRemaining + 1);
            }
            persistSpellSlotState(playerCharacter.id, state);
            renderSpellSlots(playerCharacter).catch(err => console.error('Failed to render pact slots', err));
        }

        // Update Player HP
        async function updatePlayerHP() {
            if (!activeEncounter || !playerCharacter) return;

            const newHP = parseInt(document.getElementById('playerHPInput').value);
            if (isNaN(newHP) || newHP < 0) {
                showThemedAlert('Please enter a valid HP value');
                return;
            }

            const playerParticipant = activeEncounter.participants?.find(p =>
                p.type === 'player' && p.id === currentUser.id
            );

            if (!playerParticipant) return;

            try {
                const response = await fetch(`/encounter/${activeEncounter.id}/participant/${playerParticipant.id}/hp`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ hp: newHP, type: 'player' })
                });

                const data = await response.json();

                if (data.success) {
                    await pollCombatStatus();
                    showThemedAlert('HP updated successfully!');
                } else {
                    showThemedAlert('Failed to update HP: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error updating HP:', error);
                showThemedAlert('Failed to update HP');
            }
        }

        // Toggle Collapsible Section
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const arrow = document.getElementById(sectionId + 'Arrow');

            if (section) {
                section.classList.toggle('collapsed');
                if (arrow) {
                    arrow.textContent = section.classList.contains('collapsed') ? '' : '';
                }
            }
        }

        function openToolsPopup() {
            if (!campaignId) return;

            if (toolsPopupWindow && !toolsPopupWindow.closed) {
                toolsPopupWindow.focus();
                return;
            }

            const url = new URL(window.location.href);
            url.searchParams.set('toolsPopup', '1');
            toolsPopupWindow = window.open(
                url.toString(),
                'campaignToolsPopup',
                'width=1100,height=800,resizable=yes,scrollbars=yes'
            );

            if (toolsPopupWindow) {
                toolsPopupWindow.focus();
            }
        }

        // Inventory Management
        let playerInventory = [];
        let playerGold = 0;
        let playerNotes = [];
        function normalizeInventoryEntry(item) {
            if (!item) return null;
            if (!item.id) item.id = `inv_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`;
            if (item.catalogId && window.getEquipmentCatalogItem) {
                const definition = window.getEquipmentCatalogItem(item.catalogId);
                if (definition) {
                    item.name = definition.name;
                    item.category = definition.category;
                    item.subcategory = definition.subcategory || '';
                    item.type = definition.category === 'weapon' ? 'weapon'
                        : (definition.category === 'armor' || definition.category === 'shield') ? 'armor'
                        : definition.category === 'potion' ? 'potion'
                        : definition.category === 'consumable' ? 'consumable'
                        : definition.category === 'tool' ? 'tool'
                        : definition.category === 'ammo' ? 'ammo'
                        : 'gear';
                    item.damage = definition.damage || item.damage || null;
                    item.properties = definition.properties || item.properties || [];
                    item.weaponType = definition.weaponType || item.weaponType || null;
                    item.ammo = definition.ammo || item.ammo || null;
                    item.acBase = definition.acBase || item.acBase || null;
                    item.acBonus = definition.acBonus || item.acBonus || null;
                    item.ac = item.ac || definition.acBase || null;
                    item.effect = definition.effect || item.effect || null;
                    item.weight = definition.weight || item.weight || 0;
                    item.cost = definition.cost || item.cost || '';
                    if (!item.description && definition.description) {
                        item.description = definition.description;
                    }
                }
            } else {
                item.category = item.category || item.type || 'gear';
                item.type = item.type || item.category;
                if (item.category === 'shield') {
                    item.type = 'armor';
                }
                item.mode = item.mode || (item.catalogId ? 'catalog' : 'custom');
            }
            if (typeof item.damage === 'string') {
                item.damage = { dice: item.damage, type: item.damageType || '' };
            }
            if (typeof item.quantity !== 'number') {
                item.quantity = parseInt(item.quantity || 1) || 1;
            }
            item.equipped = !!item.equipped;
            if (!item.effect) {
                if (item.healAmount) {
                    item.effect = { type: 'healing', dice: item.healAmount, description: '' };
                } else if (item.damageAmount) {
                    item.effect = { type: 'damage', dice: item.damageAmount, damageType: item.damageType || '', description: '' };
                }
            }
            return item;
        }

        function buildInventoryFromCharacter() {
            if (!playerCharacter) return [];

            let sourceItems = [];

            if (Array.isArray(playerCharacter.inventory) && playerCharacter.inventory.length) {
                sourceItems = playerCharacter.inventory;
            } else if (Array.isArray(playerCharacter.equipment) && playerCharacter.equipment.length) {
                sourceItems = playerCharacter.equipment;
            } else if (typeof playerCharacter.equipment === 'string' && playerCharacter.equipment.trim()) {
                sourceItems = playerCharacter.equipment
                    .split(/[\n,;]+/)
                    .map(item => item.trim())
                    .filter(Boolean)
                    .map(name => ({
                        name,
                        category: 'gear',
                        type: 'gear',
                        quantity: 1,
                        mode: 'custom'
                    }));
            } else {
                return [];
            }

            return sourceItems
                .map(item => normalizeInventoryEntry({ ...item }))
                .filter(Boolean);
        }

        function getCatalogOptionSummary(item) {
            if (item.damage?.dice) {
                return ` (${item.damage.dice})`;
            }
            if (item.effect?.dice) {
                return ` (${item.effect.dice})`;
            }
            if (item.acBase) {
                return ` (AC ${item.acBase})`;
            }
            if (item.acBonus) {
                return ` (+${item.acBonus} AC)`;
            }
            return '';
        }

        function buildCatalogOptionsForType(type, includeCustom = true) {
            const items = EQUIPMENT_GROUPS[type] || [];
            const catalogOptions = items
                .slice()
                .sort((a, b) => a.name.localeCompare(b.name))
                .map(item => `<option value="${item.id}">${item.name}${getCatalogOptionSummary(item)}</option>`)
                .join('');
            if (!includeCustom) {
                return catalogOptions;
            }
            return `<option value="${CUSTOM_OPTION_VALUE}">Custom Item</option>${catalogOptions}`;
        }

        // Helper function to calculate ability modifier
        function getAbilityModifier(abilityScore) {
            return Math.floor((abilityScore - 10) / 2);
        }

        // Get attack bonus modifier for a weapon based on character stats
        function getWeaponAbilityModifier(weapon) {
            if (!playerCharacter || !playerCharacter.abilities) {
                return 0;
            }

            const str = playerCharacter.abilities.strength || 10;
            const dex = playerCharacter.abilities.dexterity || 10;
            const strMod = getAbilityModifier(str);
            const dexMod = getAbilityModifier(dex);

            const weaponType = weapon.weaponType || 'melee';

            // Finesse weapons use the higher of STR or DEX
            if (weaponType === 'finesse') {
                return Math.max(strMod, dexMod);
            }
            // Ranged weapons use DEX
            else if (weaponType === 'ranged') {
                return dexMod;
            }
            // Thrown weapons typically use STR (can be thrown with DEX for finesse)
            else if (weaponType === 'thrown') {
                return strMod;
            }
            // Melee weapons use STR
            else {
                return strMod;
            }
        }

        function getCharacterProficiencyBonus(character = playerCharacter) {
            const level = character?.level || 1;
            return calculateProficiencyBonus(level);
        }

        function isProficientWithWeapon(weapon, character = playerCharacter) {
            if (!weapon || !character) return false;
            const profStr = (character.proficiencies || '').toLowerCase();
            if (!profStr) return false;
            const subcategory = (weapon.subcategory || '').toLowerCase();
            const weaponName = (weapon.name || weapon.id || '').toLowerCase();

            if (profStr.includes('all weapons')) return true;
            if (subcategory.startsWith('simple') && profStr.includes('simple weapons')) return true;
            if (subcategory.startsWith('martial') && profStr.includes('martial weapons')) return true;
            if (weaponName && profStr.includes(weaponName)) return true;
            return false;
        }

        function computeWeaponBonuses(weapon, actorType = currentActorType, actorId = currentActorId) {
            let abilityMod = 0;
            let proficiencyBonus = 0;
            let proficient = false;

            if (actorType === 'npc') {
                const npc = npcs.find(n => n.id === actorId);
                abilityMod = getNPCWeaponAbilityModifier(weapon, npc?.stats);
            } else {
                abilityMod = getWeaponAbilityModifier(weapon);
                proficient = isProficientWithWeapon(weapon, playerCharacter);
                proficiencyBonus = proficient ? getCharacterProficiencyBonus(playerCharacter) : 0;
            }

            const attackBonus = (Number(weapon.attackBonus) || 0) + abilityMod + proficiencyBonus;
            const damageBonus = abilityMod + (Number(weapon.damageBonus) || 0);

            return { attackBonus, damageBonus, abilityMod, proficiencyBonus, proficient };
        }

        function formatBonusValue(bonus) {
            return bonus >= 0 ? `+${bonus}` : `${bonus}`;
        }

        function buildDamageFormula(weapon, damageBonus = 0) {
            const diceRaw = getItemDamageDice(weapon) || '1d6';
            const dice = (diceRaw || '').toString().split(/\s+/)[0] || '1d6';
            if (!damageBonus) return dice;
            return `${dice}${formatBonusValue(damageBonus)}`;
        }

        function loadInventory() {
            const inventoryKey = `inventory_${campaignId}_${currentUser.id}`;
            const savedInventory = localStorage.getItem(inventoryKey);
            if (savedInventory) {
                try {
                    const parsed = JSON.parse(savedInventory);
                    playerInventory = Array.isArray(parsed)
                        ? parsed.map(item => normalizeInventoryEntry({ ...item })).filter(Boolean)
                        : [];
                } catch (err) {
                    console.error('Failed to parse stored inventory:', err);
                    playerInventory = buildInventoryFromCharacter();
                }
            } else {
                playerInventory = buildInventoryFromCharacter();
                if (playerInventory.length) {
                    localStorage.setItem(inventoryKey, JSON.stringify(playerInventory));
                }
            }

            const savedGold = localStorage.getItem(`gold_${campaignId}_${currentUser.id}`);
            if (savedGold !== null) {
                const parsedGold = parseInt(savedGold, 10);
                playerGold = Number.isNaN(parsedGold) ? 0 : parsedGold;
            } else {
                playerGold = 0;
            }

            renderInventory();
            refreshCharacterSheet();
        }

        function saveInventory() {
            localStorage.setItem(`inventory_${campaignId}_${currentUser.id}`, JSON.stringify(playerInventory));
            localStorage.setItem(`gold_${campaignId}_${currentUser.id}`, playerGold.toString());

            // Refresh equipment section in character sheet
            updateEquipmentSection();
        }

        function updateEquipmentSection() {
            const equipmentSection = document.getElementById('equipmentSection');
            if (equipmentSection) {
                equipmentSection.innerHTML = renderEquipmentFromInventory();
            }
        }

        function renderInventory() {
            const grid = document.getElementById('inventoryGrid');

            const equipment = playerInventory.filter(item => item.category === 'armor' || item.category === 'shield');
            const weapons = playerInventory.filter(item => item.category === 'weapon');
            const potions = playerInventory.filter(item => item.category === 'potion');
            const consumables = playerInventory.filter(item => item.category === 'consumable');
            const other = playerInventory.filter(item =>
                !['armor', 'shield', 'weapon', 'potion', 'consumable'].includes(item.category)
            );

            if (playerInventory.length === 0) {
                grid.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #94a3b8; padding: 40px 20px;">No items in inventory</div>';
                return;
            }

            let html = '';

            if (equipment.length > 0) {
                html += '<div style="grid-column: 1 / -1; margin-top: 16px; margin-bottom: 8px; font-weight: 600; color: #3b82f6; font-size: 16px; border-bottom: 2px solid #3b82f6; padding-bottom: 4px;"> Armor & Shields</div>';
                equipment.forEach(item => {
                    const realIndex = playerInventory.indexOf(item);
                    html += renderInventoryItem(item, realIndex);
                });
            }

            if (weapons.length > 0) {
                html += '<div style="grid-column: 1 / -1; margin-top: 16px; margin-bottom: 8px; font-weight: 600; color: #ef4444; font-size: 16px; border-bottom: 2px solid #ef4444; padding-bottom: 4px;"> Weapons</div>';
                weapons.forEach(item => {
                    const realIndex = playerInventory.indexOf(item);
                    html += renderInventoryItem(item, realIndex);
                });
            }

            if (potions.length > 0) {
                html += '<div style="grid-column: 1 / -1; margin-top: 16px; margin-bottom: 8px; font-weight: 600; color: #10b981; font-size: 16px; border-bottom: 2px solid #10b981; padding-bottom: 4px;"> Potions</div>';
                potions.forEach(item => {
                    const realIndex = playerInventory.indexOf(item);
                    html += renderInventoryItem(item, realIndex);
                });
            }

            if (consumables.length > 0) {
                html += '<div style="grid-column: 1 / -1; margin-top: 16px; margin-bottom: 8px; font-weight: 600; color: #a855f7; font-size: 16px; border-bottom: 2px solid #a855f7; padding-bottom: 4px;"> Consumables & Vials</div>';
                consumables.forEach(item => {
                    const realIndex = playerInventory.indexOf(item);
                    html += renderInventoryItem(item, realIndex);
                });
            }

            if (other.length > 0 || playerGold > 0) {
                html += '<div style="grid-column: 1 / -1; margin-top: 16px; margin-bottom: 8px; font-weight: 600; color: #f59e0b; font-size: 16px; border-bottom: 2px solid #f59e0b; padding-bottom: 4px;"> Other Items</div>';

                html += `
                    <div style="grid-column: 1 / -1; background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%); padding: 12px 16px; border-radius: 8px; margin-bottom: 8px; display: flex; align-items: center; justify-content: space-between;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 24px;"></span>
                            <span style="font-weight: 600; color: #1e293b; font-size: 16px;">Gold</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span style="font-weight: 700; color: #1e293b; font-size: 18px;">${playerGold} gp</span>
                            <button onclick="editGold()" style="background: rgba(255,255,255,0.9); border: none; padding: 4px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; color: #1e293b;">Edit</button>
                        </div>
                    </div>
                `;

                other.forEach(item => {
                    const realIndex = playerInventory.indexOf(item);
                    html += renderInventoryItem(item, realIndex);
                });
            }

            grid.innerHTML = html;
        }

        function formatDamageString(item) {
            if (!item) return '';
            if (typeof item.damage === 'string') {
                return item.damage;
            }
            if (item.damage?.dice) {
                return `${item.damage.dice}${item.damage.type ? ' ' + item.damage.type : ''}`;
            }
            if (item.damageDice) {
                return item.damageDice;
            }
            return '';
        }

        function getItemDamageDice(item) {
            if (!item) return '';
            if (typeof item.damage === 'string') return item.damage;
            if (item.damage?.dice) return item.damage.dice;
            if (item.damageDice) return item.damageDice;
            return '';
        }

        function getItemDamageType(item) {
            if (!item) return '';
            if (item.damage?.type) return item.damage.type;
            if (typeof item.damageType === 'string') return item.damageType;
            if (item.damage && typeof item.damage.type === 'string') return item.damage.type;
            return '';
        }

        function renderInventoryItem(item, index) {
            const category = item.category || item.type || 'gear';
            let typeIcon = '';

            if (category === 'weapon') {
                typeIcon = '';
            } else if (category === 'potion') {
                typeIcon = '';
            } else if (category === 'consumable') {
                typeIcon = '';
            } else if (category === 'armor' || category === 'shield') {
                typeIcon = '';
            }

            const stats = [];
            if (item.damage?.dice && category === 'weapon') {
                stats.push(`${item.damage.dice} ${item.damage.type || ''}`);
            }
            if ((item.acBase || item.acBonus) && (category === 'armor' || category === 'shield')) {
                const acParts = [];
                if (item.acBase) acParts.push(`Base ${item.acBase}`);
                if (item.acBonus) acParts.push(`+${item.acBonus}`);
                stats.push(`AC ${acParts.join(' ')}`);
            }
            if (item.effect?.dice) {
                const label = item.effect.type === 'healing' ? 'Heal' : item.effect.type === 'damage' ? `Dmg ${item.effect.damageType || ''}` : 'Effect';
                stats.push(`${label} ${item.effect.dice}`);
            }

            const statsText = stats.length ? ` - ${stats.join(' | ')}` : '';
            const equippedBadge = item.equipped ? '<span style="background: #10b981; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; margin-left: 6px;">EQUIPPED</span>' : '';
            const equipable = category === 'weapon' || category === 'armor' || category === 'shield';
            const equipBtn = equipable ?
                `<button onclick="toggleEquip(${index})" style="background: ${item.equipped ? '#64748b' : '#3b82f6'}; color: white; border: none; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 11px;">${item.equipped ? 'Unequip' : 'Equip'}</button>` : '';

            return `
                <div style="padding: 10px; border-bottom: 1px solid rgba(148, 163, 184, 0.1); display: flex; align-items: center; justify-content: space-between; background: rgba(15, 23, 42, 0.3); margin-bottom: 4px; border-radius: 6px;">
                    <div>
                        <span style="margin-right: 6px;">${typeIcon}</span>
                        <span style="color: #e0e6ff;">${item.name}</span>
                        <span style="color: #94a3b8; font-size: 12px;">${statsText}</span>
                        ${equippedBadge}
                        <span style="color: #94a3b8; font-size: 12px; margin-left: 8px;">x${item.quantity || 1}</span>
                    </div>
                    <div style="display: flex; gap: 6px;">
                        ${equipBtn}
                        <button onclick="deleteInventoryItem(${index})" style="background: #ef4444; color: white; border: none; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 11px;">Delete</button>
                    </div>
                </div>
            `;
        }

        function toggleEquip(index) {
            const item = playerInventory[index];
            item.equipped = !item.equipped;
            saveInventory();
            renderInventory();
            refreshCharacterSheet();
        }

        function editGold() {
            const newGold = prompt('Enter new gold amount:', playerGold);
            if (newGold !== null) {
                playerGold = parseInt(newGold) || 0;
                saveInventory();
                renderInventory();
            }
        }

        function addInventoryItem() {
            // Open add item modal
            document.getElementById('addItemModal').classList.add('active');

            // Initialize with weapon dropdown
            handleItemTypeChange();
        }

        function closeAddItemModal() {
            document.getElementById('addItemModal').classList.remove('active');
        }

        function submitAddItem() {
            const type = document.getElementById('itemType').value;
            const itemNameSelect = document.getElementById('itemNameSelect');
            const selectedValue = itemNameSelect.value;
            const quantity = parseInt(document.getElementById('itemQuantity').value) || 1;
            const equipped = document.getElementById('itemEquipped').checked;
            const description = document.getElementById('itemDescription').value.trim();

            let item;
            if (selectedValue === CUSTOM_OPTION_VALUE) {
                const customName = document.getElementById('itemCustomName').value.trim();
                if (!customName) {
                    showThemedAlert('Please enter a custom item name');
                    return;
                }
                item = {
                    name: customName,
                    type,
                    category: type,
                    quantity,
                    equipped,
                    description
                };
                if (type === 'weapon') {
                    const damage = document.getElementById('weaponDamage').value.trim();
                    if (damage) {
                        item.damage = { dice: damage, type: document.getElementById('weaponDamageType').value || 'physical' };
                    }
                    item.weaponType = 'melee';
                } else if (type === 'armor' || type === 'shield') {
                    item.acBonus = parseInt(document.getElementById('armorBonus').value) || 0;
                } else if (type === 'potion') {
                    const effectType = document.getElementById('potionEffect').value;
                    if (effectType === 'healing') {
                        item.effect = { type: 'healing', dice: document.getElementById('potionHealAmount').value || '2d4+2' };
                    } else {
                        item.effect = { type: effectType, description: document.getElementById('potionEffectDescription').value.trim() };
                    }
                } else if (type === 'consumable') {
                    const dice = document.getElementById('vialDamageAmount').value.trim() || '2d6';
                    const dmgType = document.getElementById('vialDamageType').value || 'acid';
                    item.effect = { type: 'damage', dice, damageType: dmgType };
                }
            } else {
                const definition = window.getEquipmentCatalogItem ? window.getEquipmentCatalogItem(selectedValue) : null;
                if (!definition) {
                    showThemedAlert('Unable to load selected item from the catalog.');
                    return;
                }
                item = {
                    catalogId: definition.id,
                    mode: 'catalog',
                    name: definition.name,
                    category: definition.category,
                    subcategory: definition.subcategory || '',
                    type: definition.category,
                    quantity,
                    equipped,
                    description: description || definition.description || '',
                    damage: definition.damage || null,
                    properties: definition.properties || [],
                    weaponType: definition.weaponType || null,
                    ammo: definition.ammo || null,
                    acBase: definition.acBase || null,
                    acBonus: definition.acBonus || null,
                    effect: definition.effect || null,
                    cost: definition.cost || '',
                    weight: definition.weight ?? 0
                };
            }

            playerInventory.push(normalizeInventoryEntry(item));
            saveInventory();
            renderInventory();
            closeAddItemModal();
            document.getElementById('addItemForm').reset();
            document.getElementById('customItemNameGroup').style.display = 'none';
        }

        // Handle item type selection to populate dropdown
        function handleItemTypeChange() {
            const type = document.getElementById('itemType').value;
            const itemNameSelect = document.getElementById('itemNameSelect');

            document.getElementById('weaponFields').style.display = type === 'weapon' ? 'block' : 'none';
            document.getElementById('armorFields').style.display = (type === 'armor' || type === 'shield') ? 'block' : 'none';
            document.getElementById('potionFields').style.display = type === 'potion' ? 'block' : 'none';
            document.getElementById('vialFields').style.display = type === 'consumable' ? 'block' : 'none';

            itemNameSelect.innerHTML = buildCatalogOptionsForType(type);
            document.getElementById('customItemNameGroup').style.display = 'none';
        }

        // Handle item selection from dropdown
        function handleItemSelection() {
            const selectedValue = document.getElementById('itemNameSelect').value;
            const customNameGroup = document.getElementById('customItemNameGroup');
            if (selectedValue === CUSTOM_OPTION_VALUE) {
                customNameGroup.style.display = 'block';
            } else {
                customNameGroup.style.display = 'none';
            }
        }

        function deleteInventoryItem(index) {
            if (confirm('Delete this item?')) {
                playerInventory.splice(index, 1);
                saveInventory();
                renderInventory();
            }
        }

        // Notes Management
        function getNotesStorageKey() {
            return `notes_${campaignId}_${currentUser.id}`;
        }

        function loadPlayerNotes() {
            const container = document.getElementById('playerNotesContainer');
            if (!container) return;

            const savedNotes = localStorage.getItem(getNotesStorageKey());
            if (savedNotes) {
                try {
                    const parsed = JSON.parse(savedNotes);
                if (Array.isArray(parsed)) {
                    playerNotes = parsed;
                    playerNotes.forEach(note => {
                        if (typeof note.collapsed !== 'boolean') {
                            note.collapsed = false;
                        }
                    });
                } else if (typeof parsed === 'string') {
                    playerNotes = [{
                        id: Date.now(),
                        title: 'Notes',
                        content: parsed,
                        updated: new Date().toISOString(),
                        collapsed: false
                    }];
                } else {
                    playerNotes = [];
                }
            } catch (err) {
                playerNotes = [{
                    id: Date.now(),
                    title: 'Notes',
                    content: savedNotes,
                    updated: new Date().toISOString(),
                    collapsed: false
                }];
            }
        } else {
            playerNotes = [];
            }

            renderPlayerNotes();
        }

        function saveNotesToStorage() {
            localStorage.setItem(getNotesStorageKey(), JSON.stringify(playerNotes));
        }

        function addPlayerNote() {
            const newNote = {
                id: Date.now(),
                title: '',
                content: '',
                updated: null,
                collapsed: false
            };
            playerNotes.unshift(newNote);
            renderPlayerNotes();
        }

        function updatePlayerNoteField(id, field, value) {
            const index = playerNotes.findIndex(note => note.id === id);
            if (index === -1) return;
            playerNotes[index][field] = value;
        }

        function savePlayerNote(id) {
            const index = playerNotes.findIndex(note => note.id === id);
            if (index === -1) return;

            playerNotes[index].updated = new Date().toISOString();
            playerNotes[index].collapsed = true;
            saveNotesToStorage();
            renderPlayerNotes();
            showThemedAlert('Note saved!');
        }

        function deletePlayerNote(id) {
            const index = playerNotes.findIndex(note => note.id === id);
            if (index === -1) return;

            playerNotes.splice(index, 1);
            saveNotesToStorage();
            renderPlayerNotes();
        }

        function renderPlayerNotes() {
            const container = document.getElementById('playerNotesContainer');
            if (!container) return;

            if (playerNotes.length === 0) {
                container.innerHTML = '<div class="note-empty-state">No notes yet. Click "Add Note" to get started.</div>';
                return;
            }

            container.innerHTML = playerNotes.map(note => {
                const updatedText = note.updated
                    ? `Last updated ${new Date(note.updated).toLocaleString()}`
                    : 'Unsaved';
                const collapsedClass = note.collapsed ? 'collapsed' : '';
                return `
                    <div class="note-card ${collapsedClass}" data-note-id="${note.id}" onclick="handleNoteCardClick(${note.id}, ${note.collapsed}, event)">
                        <div style="display:flex; align-items:center; gap:10px;">
                            <input
                                type="text"
                                class="note-title"
                                placeholder="Description / Title"
                                value="${escapeHtml(note.title || '')}"
                                oninput="updatePlayerNoteField(${note.id}, 'title', this.value)"
                                ${note.collapsed ? 'readonly' : ''}>
                            <button class="btn btn-secondary" style="padding:6px 10px;" onclick="toggleNoteCollapse(${note.id}, event)">
                                ${note.collapsed ? 'Expand' : 'Collapse'}
                            </button>
                        </div>
                        <textarea
                            class="notes-textarea"
                            placeholder="Write your notes..."
                            oninput="updatePlayerNoteField(${note.id}, 'content', this.value)">${escapeHtml(note.content || '')}</textarea>
                        <div class="note-card-actions">
                            <button class="btn btn-secondary" onclick="deletePlayerNote(${note.id})">Delete</button>
                            <button class="btn btn-success" onclick="savePlayerNote(${note.id})">Save</button>
                        </div>
                        <div class="note-meta">${updatedText}</div>
                    </div>
                `;
            }).join('');
        }

        function getSeenQuestStorageKey() {
            if (!campaignId || !currentUser) return null;
            return `questsSeen_${campaignId}_${currentUser.id}`;
        }

        function loadSeenQuests() {
            const key = getSeenQuestStorageKey();
            if (!key) return;
            try {
                const raw = localStorage.getItem(key);
                if (!raw) return;
                const ids = JSON.parse(raw);
                if (Array.isArray(ids)) {
                    seenQuestIds = new Set(ids);
                }
            } catch (err) {
                console.warn('Failed to load seen quests', err);
            }
        }

        function saveSeenQuests() {
            const key = getSeenQuestStorageKey();
            if (!key) return;
            localStorage.setItem(key, JSON.stringify(Array.from(seenQuestIds)));
        }

        function markQuestSeen(id) {
            seenQuestIds.add(id);
            saveSeenQuests();
        }

        function upsertQuest(quest) {
            if (!quest || typeof quest.id === 'undefined') return;
            const index = campaignQuests.findIndex(q => q.id === quest.id);
            if (quest.deleted) {
                if (index >= 0) {
                    campaignQuests.splice(index, 1);
                }
                return;
            }
            if (index >= 0) {
                campaignQuests[index] = quest;
            } else {
                campaignQuests.unshift(quest);
            }
        }

        async function fetchQuests() {
            if (!campaignId) return;
            try {
                const response = await fetch(`/campaigns/${campaignId}/quests`);
                const data = await response.json();
                if (data.success) {
                    campaignQuests = data.quests || [];
                    renderQuestBoard();
                    renderPlayerQuests();
                }
            } catch (err) {
                console.error('Failed to load quests', err);
            }
        }

        function sortQuests(quests) {
            const priority = quest => quest.status === 'Completed' ? 1 : 0;
            return [...quests].sort((a, b) => {
                const diff = priority(a) - priority(b);
                if (diff !== 0) return diff;
                const aTime = new Date(a.created || 0).getTime();
                const bTime = new Date(b.created || 0).getTime();
                return bTime - aTime;
            });
        }

        function connectQuestStream() {
            if (questStreamConnected || !campaignId) return;
            questStreamConnected = true;
            if (typeof EventSource === 'undefined') return;
            questEventsSource = new EventSource(`/events/campaign/${campaignId}`);
            questEventsSource.addEventListener('quest', event => {
                try {
                    const quest = JSON.parse(event.data);
                    if (quest.deleted) {
                        const idx = campaignQuests.findIndex(q => q.id === quest.id);
                        if (idx >= 0) {
                            campaignQuests.splice(idx, 1);
                            renderQuestBoard();
                            renderPlayerQuests();
                        }
                        return;
                    }
                    upsertQuest(quest);
                    renderQuestBoard();
                    renderPlayerQuests();
                    if (userRole === 'player' && quest && quest.status !== 'Completed' && !seenQuestIds.has(quest.id)) {
                        questPopupQueue.push(quest);
                        processQuestPopupQueue();
                    }
                } catch (err) {
                    console.error('Failed to parse quest event', err);
                }
            });
            questEventsSource.addEventListener('level', event => {
                try {
                    const levelEvent = JSON.parse(event.data);
                    handleLevelEvent(levelEvent);
                } catch (err) {
                    console.error('Failed to parse level event', err);
                }
            });
            questEventsSource.onerror = () => {
                questStreamConnected = false;
                if (questEventsSource) {
                    questEventsSource.close();
                    questEventsSource = null;
                }
                setTimeout(connectQuestStream, 3000);
            };
        }

        function disconnectQuestStream() {
            questStreamConnected = false;
            if (questEventsSource) {
                questEventsSource.close();
                questEventsSource = null;
            }
        }

        function processQuestPopupQueue() {
            if (questPopupVisible) return;
            const nextQuest = questPopupQueue.shift();
            if (!nextQuest) return;
            showQuestPopup(nextQuest);
        }

        function handleLevelEvent(levelEvent) {
            if (!levelEvent) return;
            const eventCampaignId = parseInt(levelEvent.campaignId ?? levelEvent.character?.campaignId ?? campaignId, 10);
            if (campaignId && eventCampaignId && eventCampaignId !== campaignId) return;

            const characterId = levelEvent.characterId;
            const isPlayerCharacter = playerCharacter && characterId && playerCharacter.id === characterId;
            const initiatedByCurrentUser = Number(levelEvent.initiatedBy) === Number(currentUser?.id);
            const skipPlayerUpdate = isPlayerCharacter && levelEvent.action === 'completed' && initiatedByCurrentUser;

            if (isPlayerCharacter && levelEvent.character && !skipPlayerUpdate) {
                playerCharacter = levelEvent.character;
                renderCharacterSheet(playerCharacter, { skipGameUpdate: false });
                updateGameUI(playerCharacter);
                if (levelEvent.action === 'requested') {
                    showLevelToast(`Level ${playerCharacter.pendingLevelUp?.targetLevel || playerCharacter.level} is ready to apply.`, 'warning');
                } else if (levelEvent.action === 'completed') {
                    showLevelToast(`Level ${playerCharacter.level} complete!`, 'success');
                    closeLevelUpModal();
                }
            }

            if (userRole === 'dm') {
                loadPlayers().catch(err => console.error('Failed to refresh players after level event', err));
                if (levelEvent.action === 'completed' && levelEvent.character) {
                    showLevelToast(`${levelEvent.character.name || 'Player'} reached level ${levelEvent.character.level}.`, 'success');
                } else if (levelEvent.action === 'requested' && !initiatedByCurrentUser && levelEvent.character) {
                    const pending = levelEvent.character.pendingLevelUp?.targetLevel || (levelEvent.character.level + 1);
                    showLevelToast(`${levelEvent.character.name || 'Player'} is awaiting approval for level ${pending}.`, 'warning');
                }
            } else if (!isPlayerCharacter) {
                loadPlayers().catch(err => console.error('Failed to refresh players after level event', err));
            }
            updateLevelUpCallout();
        }

        function showQuestPopup(quest) {
            const overlay = document.getElementById('questPopup');
            if (!overlay) return;
            document.getElementById('questPopupTitle').textContent = quest.title || 'New Quest';
            document.getElementById('questPopupDescription').textContent = quest.description || '';
            document.getElementById('questPopupRewards').textContent = quest.rewards?.trim() ? quest.rewards : 'Rewards to be determined.';
            const turnInWrap = document.getElementById('questPopupTurnInWrap');
            const turnInText = document.getElementById('questPopupTurnIn');
            if (quest.turnInLocation && quest.turnInLocation.trim().length) {
                turnInText.textContent = quest.turnInLocation;
                turnInWrap.style.display = 'block';
            } else {
                turnInWrap.style.display = 'none';
                turnInText.textContent = '';
            }
            overlay.dataset.questId = quest.id;
            overlay.classList.add('active');
            questPopupVisible = true;
        }

        window.acknowledgeQuestPopup = function() {
            const overlay = document.getElementById('questPopup');
            if (!overlay) return;
            const questId = parseInt(overlay.dataset.questId, 10);
            if (questId) {
                markQuestSeen(questId);
            }
            overlay.classList.remove('active');
            questPopupVisible = false;
            processQuestPopupQueue();
        };

        function openQuestModal() {
            if (userRole !== 'dm') return;
            const modal = document.getElementById('questModal');
            if (!modal) return;

            document.getElementById('questTitleInput').value = '';
            document.getElementById('questDescriptionInput').value = '';
            document.getElementById('questRewardsInput').value = '';
            document.getElementById('questTurnInInput').value = '';
            modal.classList.add('active');
        }

        function closeQuestModal() {
            const modal = document.getElementById('questModal');
            if (!modal) return;
            modal.classList.remove('active');
        }

        function submitQuest() {
            if (userRole !== 'dm') return;
            const title = document.getElementById('questTitleInput').value.trim();
            const description = document.getElementById('questDescriptionInput').value.trim();
            const rewards = document.getElementById('questRewardsInput').value.trim();
            const turnInLocation = document.getElementById('questTurnInInput').value.trim();

            if (!title) {
                showThemedAlert('Please provide a quest title.');
                return;
            }

            if (!description) {
                showThemedAlert('Add a description so players know what to do.');
                return;
            }

            fetch(`/campaigns/${campaignId}/quests`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    userId: currentUser.id,
                    title,
                    description,
                    rewards,
                    turnInLocation
                })
            })
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    showThemedAlert(data.error || 'Failed to create quest');
                    return;
                }
                upsertQuest(data.quest);
                renderQuestBoard();
                renderPlayerQuests();
                closeQuestModal();
                showThemedAlert('Quest posted to the board!');
            })
            .catch(err => {
                console.error('Failed to create quest', err);
                showThemedAlert('Failed to create quest');
            });
        }

        function buildQuestCardHtml(quest, context) {
            const createdText = quest.created ? `Posted ${new Date(quest.created).toLocaleDateString()}` : '';
            const rewards = quest.rewards && quest.rewards.trim().length
                ? quest.rewards
                : 'To be determined';
            const cardId = `questCard-${context}-${quest.id}`;
            const arrowId = `questArrow-${context}-${quest.id}`;
            const statusLabel = quest.status === 'Completed' ? 'Completed' : 'Active';
            const statusClass = statusLabel === 'Completed' ? 'completed' : '';
            const showActions = context === 'dm';

            return `
                <div class="quest-card" id="${cardId}">
                    <div class="quest-card-header" onclick="toggleQuestCard(${quest.id}, '${context}')">
                        <div>
                            <div class="quest-title">${escapeHtml(quest.title)}</div>
                            <div class="quest-meta">${createdText}</div>
                            ${quest.turnInLocation && quest.turnInLocation.trim().length ? `
                                <div class="quest-turnin-tag">
                                    <span>Turn In With:</span>
                                    <strong>${escapeHtml(quest.turnInLocation)}</strong>
                                </div>
                            ` : ''}
                        </div>
                        <div style="display:flex; align-items:center; gap:8px;">
                            <div class="quest-status ${statusClass}">${escapeHtml(statusLabel)}</div>
                            <span class="quest-expand-indicator" id="${arrowId}"></span>
                        </div>
                    </div>
                    <div class="quest-card-body">
                        <div class="quest-description">${escapeHtml(quest.description)}</div>
                        <div class="quest-rewards">
                            <div class="quest-rewards-label">Rewards</div>
                            <div class="quest-rewards-text">${escapeHtml(rewards)}</div>
                        </div>
                        ${quest.turnInLocation && quest.turnInLocation.trim().length ? `
                            <div class="quest-rewards" style="margin-top: 12px;">
                                <div class="quest-rewards-label">Turn In</div>
                                <div class="quest-rewards-text">${escapeHtml(quest.turnInLocation)}</div>
                            </div>
                        ` : ''}
                        ${showActions ? `
                            <div class="quest-actions">
                                <button type="button" class="complete-btn" onclick="event.stopPropagation(); markQuestCompleted(${quest.id});" ${statusLabel === 'Completed' ? 'disabled' : ''}>Complete</button>
                                <button type="button" class="abandon-btn" onclick="event.stopPropagation(); abandonQuest(${quest.id});">Abandon</button>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        window.markQuestCompleted = function(questId) {
            fetch(`/campaigns/${campaignId}/quests/${questId}/status`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'complete', userId: currentUser.id })
            }).then(res => res.json()).then(data => {
                if (!data.success) {
                    showThemedAlert(data.error || 'Failed to complete quest');
                    return;
                }
                upsertQuest(data.quest);
                renderQuestBoard();
                renderPlayerQuests();
            }).catch(err => {
                console.error('Failed to update quest', err);
                showThemedAlert('Failed to complete quest');
            });
        };

        window.abandonQuest = function(questId) {
            fetch(`/campaigns/${campaignId}/quests/${questId}/status`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'abandon', userId: currentUser.id })
            }).then(res => res.json()).then(data => {
                if (!data.success) {
                    showThemedAlert(data.error || 'Failed to abandon quest');
                    return;
                }
                const index = campaignQuests.findIndex(q => q.id === questId);
                if (index >= 0) {
                    campaignQuests.splice(index, 1);
                }
                renderQuestBoard();
                renderPlayerQuests();
            }).catch(err => {
                console.error('Failed to abandon quest', err);
                showThemedAlert('Failed to abandon quest');
            });
        };

        function renderDiceLogEntry(entry) {
            const label = entry.label ? `${escapeHtml(entry.label)}  ` : '';
            const mod = entry.modifier ? (entry.modifier > 0 ? `+${entry.modifier}` : entry.modifier) : '+0';
            const time = entry.timestamp ? new Date(entry.timestamp).toLocaleTimeString() : '';
            const diceDescriptor = entry.expression ? escapeHtml(entry.expression) : (`d${entry.sides || 20}`);
            return `
                <div class="dice-log-entry">
                    <div>
                        <div><strong>${escapeHtml(entry.username || 'Player')}</strong> ${label}${diceDescriptor}</div>
                        <div class="roll-meta">${time}</div>
                    </div>
                    <div>
                        <div style="font-size:18px;font-weight:700;">${entry.total}</div>
                        <div class="roll-meta">Roll ${entry.roll} ${mod}</div>
                    </div>
                </div>
            `;
        }

        function renderDiceLog() {
            const container = document.getElementById('diceLogContainer');
            if (!container) return;
            if (!diceLogEntries.length) {
                container.innerHTML = '<div class="quest-empty-state">No rolls yet.</div>';
                return;
            }
            container.innerHTML = diceLogEntries.map(entry => renderDiceLogEntry(entry)).join('');
        }

        function toggleDiceLog() {
            const container = document.getElementById('diceLogContainer');
            if (!container) return;
            container.style.display = container.style.display === 'none' ? 'block' : 'none';
        }

        function clearDiceLog() {
            const modal = document.getElementById('clearDiceLogModal');
            if (modal) modal.classList.add('active');
        }

        function closeClearDiceLogModal() {
            const modal = document.getElementById('clearDiceLogModal');
            if (modal) modal.classList.remove('active');
        }

        async function confirmClearDiceLog() {
            closeClearDiceLogModal();
            if (!campaignId) return;
            diceLogEntries = [];
            renderDiceLog();
            const container = document.getElementById('diceLogContainer');
            if (container) {
                container.innerHTML = '<div class="quest-empty-state">No rolls yet.</div>';
            }
            try {
                await fetch(`/campaigns/${campaignId}/dice-log`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userId: currentUser?.id })
                });
            } catch (err) {
                console.error('Failed to clear dice log', err);
            }
        }

        function renderPlayerDiceLog() {
            const container = document.getElementById('playerDiceLog');
            if (!container) return;
            if (!diceLogEntries.length) {
                container.innerHTML = '<div class="quest-empty-state">No rolls yet.</div>';
                return;
            }
            container.innerHTML = diceLogEntries.map(entry => renderDiceLogEntry(entry)).join('');
        }

        async function fetchDiceLog() {
            if (!campaignId) return;
            try {
                const res = await fetch(`/campaigns/${campaignId}/dice-log`);
                const data = await res.json();
                if (data.success) {
                    diceLogEntries = data.entries || [];
                    renderDiceLog();
                    renderPlayerDiceLog();
                }
            } catch (err) {
                console.error('Failed to load dice log', err);
            }
        }

        function startDiceLogPolling() {
            fetchDiceLog();
            if (diceLogInterval) clearInterval(diceLogInterval);
            diceLogInterval = setInterval(fetchDiceLog, 5000);
        }

        function stopDiceLogPolling() {
            if (diceLogInterval) {
                clearInterval(diceLogInterval);
                diceLogInterval = null;
            }
        }

        function postDiceLog({ label, sides, roll, modifier, total, expression }) {
            if (!campaignId || !currentUser) return;
            fetch(`/campaigns/${campaignId}/dice-log`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    userId: currentUser.id,
                    username: currentUser.username,
                    label,
                    sides,
                    roll,
                    modifier,
                    total,
                    expression
                })
            }).then(res => res.json())
              .then(data => {
                if (data.success && data.entry) {
                    if (!diceLogEntries.find(entry => entry.id === data.entry.id)) {
                        diceLogEntries.unshift(data.entry);
                        if (diceLogEntries.length > 30) diceLogEntries.length = 30;
                        renderDiceLog();
                        renderPlayerDiceLog();
                    }
                }
              })
              .catch(err => console.error('Failed to post dice log', err));
        }

        function renderQuestBoard() {
            const board = document.getElementById('questBoard');
            const empty = document.getElementById('questBoardEmpty');
            if (!board) return;

            if (!campaignQuests.length) {
                board.innerHTML = '';
                if (empty) empty.style.display = 'block';
                return;
            }

            if (empty) empty.style.display = 'none';
            board.innerHTML = sortQuests(campaignQuests).map(q => buildQuestCardHtml(q, 'dm')).join('');
        }

        function renderPlayerQuests() {
            const list = document.getElementById('playerQuestList');
            const empty = document.getElementById('playerQuestEmpty');
            if (!list) return;

            if (!campaignQuests.length) {
                list.innerHTML = '';
                if (empty) empty.style.display = 'block';
                return;
            }

            if (empty) empty.style.display = 'none';
            list.innerHTML = sortQuests(campaignQuests).map(q => buildQuestCardHtml(q, 'player')).join('');
        }

        function toggleQuestCard(id, context = 'dm') {
            const card = document.getElementById(`questCard-${context}-${id}`);
            if (!card) return;
            const arrow = document.getElementById(`questArrow-${context}-${id}`);
            card.classList.toggle('expanded');
            if (arrow) {
                arrow.textContent = card.classList.contains('expanded') ? '' : '';
            }
        }

        window.toggleNoteCollapse = function(noteId, event) {
            if (event) {
                event.stopPropagation();
            }
            const index = playerNotes.findIndex(note => note.id === noteId);
            if (index === -1) return;
            playerNotes[index].collapsed = !playerNotes[index].collapsed;
            saveNotesToStorage();
            renderPlayerNotes();
        };

        window.handleNoteCardClick = function(noteId, isCollapsed, event) {
            const target = event.target;
            if (target.closest('button') || target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
                return;
            }
            if (isCollapsed) {
                toggleNoteCollapse(noteId, event);
            }
        };

        // Drag and Drop Section Reordering
        let draggedElement = null;

        function initializeDragAndDrop() {
            const draggableElements = document.querySelectorAll('.draggable-section');

            draggableElements.forEach(element => {
                element.addEventListener('dragstart', handleDragStart);
                element.addEventListener('dragend', handleDragEnd);
                element.addEventListener('dragover', handleDragOver);
                element.addEventListener('drop', handleDrop);
                element.addEventListener('dragleave', handleDragLeave);
            });

            // Load saved order
            loadSectionOrder();
        }

        function handleDragStart(e) {
            draggedElement = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');

            // Remove all drag-over classes
            document.querySelectorAll('.draggable-section').forEach(el => {
                el.classList.remove('drag-over');
            });

            // Save the new order
            saveSectionOrder();
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }

            e.dataTransfer.dropEffect = 'move';

            if (this !== draggedElement) {
                this.classList.add('drag-over');
            }

            return false;
        }

        function handleDragLeave(e) {
            this.classList.remove('drag-over');
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }

            if (draggedElement !== this) {
                const container = document.getElementById('draggableSectionsContainer');
                const allSections = [...container.querySelectorAll('.draggable-section')];
                const draggedIndex = allSections.indexOf(draggedElement);
                const targetIndex = allSections.indexOf(this);

                if (draggedIndex < targetIndex) {
                    container.insertBefore(draggedElement, this.nextSibling);
                } else {
                    container.insertBefore(draggedElement, this);
                }
            }

            this.classList.remove('drag-over');
            return false;
        }

        function saveSectionOrder() {
            const container = document.getElementById('draggableSectionsContainer');
            const sections = container.querySelectorAll('.draggable-section');
            const order = Array.from(sections).map(section => section.dataset.sectionId);
            localStorage.setItem(`sectionOrder_${campaignId}_${currentUser.id}`, JSON.stringify(order));
        }

        function loadSectionOrder() {
            const savedOrder = localStorage.getItem(`sectionOrder_${campaignId}_${currentUser.id}`);
            if (!savedOrder) return;

            const order = JSON.parse(savedOrder);
            const container = document.getElementById('draggableSectionsContainer');
            const sections = container.querySelectorAll('.draggable-section');

            // Create a map of sections by their IDs
            const sectionMap = {};
            sections.forEach(section => {
                sectionMap[section.dataset.sectionId] = section;
            });

            // Reorder based on saved order
            order.forEach(sectionId => {
                if (sectionMap[sectionId]) {
                    container.appendChild(sectionMap[sectionId]);
                }
            });
        }

        // Render Player View
        async function renderPlayerView() {
            document.getElementById('playerView').classList.add('active');

            // Load NPCs and other players so we can see them in combat
            await loadNPCs();
            await loadPlayers();

            try {
                if (!currentUser?.id) {
                    throw new Error('Missing current user  please log in again.');
                }

                const response = await fetch(`/player/campaign/${campaignId}/user/${currentUser.id}`);
                let data;
                try {
                    data = await response.json();
                } catch (parseErr) {
                    const text = await response.text().catch(() => '');
                    throw new Error(`Unexpected response while loading character${text ? `: ${text.slice(0, 120)}` : ''}`);
                }

                if (!response.ok && !data?.success) {
                    const statusMsg = `HTTP ${response.status} ${response.statusText || ''}`.trim();
                    throw new Error(data?.error || statusMsg || 'Unable to load character');
                }

                if (data.success && data.player) {
                    playerCharacter = data.player;
                    playerCharacter.userId = currentUser.id;
                    await ensureBarbarianConfig(playerCharacter);
                    loadInitiativeBonusOverride();

                    // One-time initialization for existing characters without maxHp
                    if (!data.player.maxHp || data.player.maxHp === 0) {
                        // Set maxHp to current HP (best we can do for existing characters)
                        data.player.maxHp = data.player.hp;
                        playerCharacter.maxHp = data.player.hp;
                        console.log('Initialized maxHp for existing character:', data.player.maxHp);

                        // Save it back to the server
                        fetch(`/player/${data.player.id}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(data.player)
                        }).catch(err => console.error('Failed to save maxHp:', err));
                    }

                    renderCharacterSheet(data.player);
                    updateGameUI(data.player);

                    // Load inventory and notes
                    loadInventory();
                    loadPlayerNotes();
                    await fetchQuests();
                    startDiceLogPolling();

                    // Initialize drag and drop for section reordering
                    initializeDragAndDrop();
                } else {
                    document.getElementById('characterSheet').innerHTML = `
                        <div class="error-message">
                            You haven't created a character for this campaign yet.
                            <br><br>
                            <a href="/character-creation.html?campaignId=${campaignId}" style="color: #818cf8; text-decoration: underline;">Create Character</a>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error loading character:', error);
                const message = error?.message || 'Failed to load your character';
                showError(message);
            }
        }

        // Render character sheet
        function calculateCharacterAC(char) {
            if (!char) return 10;
            const dex = char.abilities?.dexterity ?? 10;
            const dexMod = Math.floor((dex - 10) / 2);
            const inventorySource = playerInventory.length
                ? playerInventory
                : (Array.isArray(char.inventory) ? char.inventory.map(item => normalizeInventoryEntry({ ...item })).filter(Boolean) : []);

            if (!inventorySource.length) {
                return char.ac || (10 + dexMod);
            }

            let ac = 10 + dexMod;

            const armor = inventorySource.find(item => item.equipped && item.category === 'armor');
            const shield = inventorySource.find(item => item.equipped && item.category === 'shield');

            if (armor) {
                const base = armor.acBase || armor.ac || 10;
                const subType = (armor.subcategory || armor.type || '').toLowerCase();
                let dexContribution = dexMod;
                if (subType.includes('medium')) {
                    dexContribution = Math.min(dexMod, 2);
                } else if (subType.includes('heavy')) {
                    dexContribution = 0;
                }
                ac = base + dexContribution + (armor.acBonus || 0);
            }

            if (shield) {
                ac += shield.acBonus || shield.acBase || 2;
            }

            inventorySource.forEach(item => {
                if (item.equipped && item !== armor && item !== shield && item.acBonus) {
                    ac += item.acBonus;
                }
            });

            return ac;
        }

        function normalizeClassKey(value = '') {
            return value
                .replace(/\(.*?\)/g, '')
                .trim()
                .toLowerCase()
                .split(/\s+/)[0] || '';
        }

        function calculateDefaultHpGain(char) {
            const classKey = normalizeClassKey(char?.class || '');
            const die = CLASS_HIT_DICE[classKey] || 8;
            const average = Math.floor(die / 2) + 1;
            const conScore = char?.abilities?.constitution ?? 10;
            const conMod = Math.floor((conScore - 10) / 2);
            return Math.max(1, average + conMod);
        }

        function getLevelUpConMod() {
            const adjustments = computeAbilityAdjustments(levelUpContext?.abilitySelections || []);
            const baseCon = playerCharacter?.abilities?.constitution ?? 10;
            const adjustedCon = baseCon + (adjustments.constitution || 0);
            return Math.floor(((adjustedCon || 10) - 10) / 2);
        }

        async function openLevelUpWorkflow() {
            if (!playerCharacter?.pendingLevelUp) return;
            const targetLevel = playerCharacter.pendingLevelUp.targetLevel;
            const classKey = normalizeClassKey(playerCharacter.class || '');
            if (!classKey) {
                return showThemedAlert('Unknown class for this character.');
            }

            try {
                const response = await fetch(`/leveling/class/${classKey}/${targetLevel}`);
                const data = await response.json();
                if (!data.success) {
                    return showThemedAlert(data.error || 'Unable to load leveling data.');
                }

                levelUpContext = {
                    classKey,
                    targetLevel,
                    progression: data.progression,
                    hpGain: calculateDefaultHpGain(playerCharacter),
                    lastHpRoll: null,
                    abilitySelections: ['', ''],
                    abilityError: ''
                };

                renderLevelUpModal();
            } catch (error) {
                console.error('Failed to load leveling data', error);
                showThemedAlert('Failed to load DNDOPEN leveling guidance.');
            }
        }

        function getRaceLevelNote(raceName = '', level = 1) {
            const potentialKeys = [];
            if (playerCharacter?.subrace) {
                potentialKeys.push(playerCharacter.subrace.toLowerCase());
            }
            if (raceName) {
                potentialKeys.push(raceName.toLowerCase());
            }
            potentialKeys.push((raceName || '').toLowerCase().split(/\s+/).slice(-2).join(' '));

            for (const key of potentialKeys) {
                if (!key) continue;
                const config = RACE_LEVEL_NOTES[key];
                if (config) {
                    if (config[level]) return config[level];
                    if (config.every) return config.every;
                }
            }
            return '';
        }

        function computeAbilityAdjustments(selections = []) {
            return selections.reduce((acc, key) => {
                if (!key) return acc;
                acc[key] = (acc[key] || 0) + 1;
                return acc;
            }, {});
        }

        function renderAbilitySection(featureText = '') {
            if (!/(ability score improvement)/i.test(featureText || '')) {
                return '';
            }

            levelUpContext.abilitySelections = levelUpContext.abilitySelections || ['', ''];
            const selections = levelUpContext.abilitySelections;
            const adjustments = computeAbilityAdjustments(selections);
            const abilityCards = Object.keys(ABILITY_LABELS).map(key => {
                const base = playerCharacter?.abilities?.[key] ?? 10;
                const bonus = adjustments[key] || 0;
                const newValue = base + bonus;
                const bonusLabel = bonus ? ` (+${bonus})` : '';
                return `
                    <div class="levelup-column-card">
                        <div class="levelup-column-label">${ABILITY_LABELS[key]}</div>
                        <div class="levelup-column-value">${newValue}${bonusLabel}</div>
                    </div>
                `;
            }).join('');
            const buildOptions = selected => [''].concat(Object.keys(ABILITY_LABELS)).map(value => {
                const label = value ? ABILITY_LABELS[value] : 'No increase';
                const isSelected = selected === value ? 'selected' : '';
                return `<option value="${value}" ${isSelected}>${label}</option>`;
            }).join('');

            return `
                <div class="levelup-section">
                    <h4>Ability Score Improvement</h4>
                    <p>Select one ability twice (+2) or two different abilities (+1 each).</p>
                    <div class="levelup-columns">
                        <div class="levelup-column-card">
                            <div class="levelup-column-label">Increase One</div>
                            <select id="asiSelectA" onchange="handleAbilitySelection()">
                                ${buildOptions(selections[0])}
                            </select>
                        </div>
                        <div class="levelup-column-card">
                            <div class="levelup-column-label">Increase Two</div>
                            <select id="asiSelectB" onchange="handleAbilitySelection()">
                                ${buildOptions(selections[1])}
                            </select>
                        </div>
                    </div>
                    ${levelUpContext.abilityError ? `<div class="player-status-badge" style="margin-top:16px;">${levelUpContext.abilityError}</div>` : ''}
                    <div class="levelup-columns" style="margin-top:16px;">
                        ${abilityCards}
                    </div>
                </div>
            `;
        }

        function renderLevelUpModal() {
            if (!levelUpContext) return;
            const modal = document.getElementById('levelUpModal');
            const body = document.getElementById('levelUpModalBody');
            if (!modal || !body) return;

            const data = levelUpContext.progression || {};
            const columns = (data.columns || []).filter(col => col.value !== null && col.value !== undefined);
            const columnsHtml = columns.length
                ? `<div class="levelup-columns">${columns.map(col => `
                        <div class="levelup-column-card">
                            <div class="levelup-column-label">${col.label}</div>
                            <div class="levelup-column-value">${col.value}</div>
                        </div>
                    `).join('')}</div>`
                : '';
            const raceNote = getRaceLevelNote(playerCharacter?.race || '', levelUpContext.targetLevel);
            const hitDie = CLASS_HIT_DICE[levelUpContext.classKey] || 8;
            const abilitySection = renderAbilitySection(data.features);
            const baseMax = playerCharacter?.maxHp ?? playerCharacter?.hp ?? 0;
            const conMod = getLevelUpConMod();
            const lastRoll = levelUpContext.lastHpRoll;
            const hpFromRoll = lastRoll ? Math.max(1, lastRoll.roll + conMod) : null;
            if (hpFromRoll !== null) {
                levelUpContext.hpGain = hpFromRoll;
            }
            const hpGain = levelUpContext.hpGain || 0;
            const projectedMax = baseMax + hpGain;
            const rollNote = lastRoll
                ? `<div style="margin-top:8px;font-size:12px;color:#94a3b8;">Rolled d${hitDie}: ${lastRoll.roll} ${formatModifier(conMod)} = <strong>${hpGain}</strong></div>`
                : `<div style="margin-top:8px;font-size:12px;color:#94a3b8;">Roll your hit die to set HP gain.</div>`;

            body.innerHTML = `
                <div class="levelup-section">
                    <h4>SRD Guidance</h4>
                    <p><strong>Proficiency Bonus:</strong> ${data.proficiencyBonus}</p>
                    <p><strong>Features:</strong> ${data.features || ''}</p>
                    ${columnsHtml}
                    ${raceNote ? `<div class="player-rest-summary" style="display:block;margin-top:16px;">${raceNote}</div>` : ''}
                </div>
                <div class="levelup-section">
                    <h4>Hit Points</h4>
                    <p>Hit Die: d${hitDie}. Roll d${hitDie} and add your Constitution modifier.</p>
                    <div class="levelup-columns">
                        <div class="levelup-column-card">
                            <div class="levelup-column-label">HP Gained</div>
                            <input type="number" id="levelUpHpInput" min="1" value="${levelUpContext.hpGain}" oninput="handleHpGainInput(this.value)">
                            <button class="btn btn-small" style="margin-top:8px;" onclick="rollHpGain()">Roll Hit Die</button>
                            ${rollNote}
                        </div>
                        <div class="levelup-column-card">
                            <div class="levelup-column-label">Projected Max HP</div>
                            <div class="levelup-column-value" id="levelUpHpSummary">${projectedMax}</div>
                        </div>
                    </div>
                </div>
                ${abilitySection}
            `;

            modal.classList.add('active');
            document.getElementById('levelUpApplyBtn').disabled = Boolean(levelUpContext.abilityError);
            const selectA = document.getElementById('asiSelectA');
            const selectB = document.getElementById('asiSelectB');
            if (selectA) selectA.value = levelUpContext.abilitySelections?.[0] || '';
            if (selectB) selectB.value = levelUpContext.abilitySelections?.[1] || '';
        }

        function closeLevelUpModal() {
            const modal = document.getElementById('levelUpModal');
            if (modal) modal.classList.remove('active');
            levelUpContext = null;
        }

        function handleAbilitySelection() {
            if (!levelUpContext) return;
            const selectA = document.getElementById('asiSelectA');
            const selectB = document.getElementById('asiSelectB');
            levelUpContext.abilitySelections = [
                selectA ? selectA.value : '',
                selectB ? selectB.value : ''
            ];
            const adjustments = computeAbilityAdjustments(levelUpContext.abilitySelections);
            const baseAbilities = playerCharacter?.abilities || {};
            const invalid = Object.entries(adjustments).some(([key, bonus]) => {
                const base = baseAbilities[key] ?? 10;
                return base + bonus > 20;
            });
            levelUpContext.abilityError = invalid ? 'Ability scores cannot exceed 20.' : '';
            renderLevelUpModal();
        }

        function handleHpGainInput(value) {
            if (!levelUpContext) return;
            const parsed = Math.max(1, parseInt(value, 10) || 1);
            levelUpContext.hpGain = parsed;
            levelUpContext.lastHpRoll = null;
            const base = playerCharacter?.maxHp ?? playerCharacter?.hp ?? 0;
            const summary = document.getElementById('levelUpHpSummary');
            if (summary) {
                summary.textContent = base + parsed;
            }
            renderDeathSaveTracker(playerCharacter, base + parsed, base);
        }

        function rollHpGain() {
            if (!levelUpContext || !playerCharacter) return;
            const classKey = normalizeClassKey(playerCharacter.class || '');
            const die = CLASS_HIT_DICE[classKey] || 8;
            const conMod = getLevelUpConMod();
            const label = 'Level Up Hit Die';

            openDiceRollerModal(label, conMod);
            animateDiceRoll({
                sides: die,
                modifier: conMod,
                label,
                onComplete: ({ roll, total }) => {
                    const clampedTotal = Math.max(1, total);
                    levelUpContext.hpGain = clampedTotal;
                    levelUpContext.lastHpRoll = { roll, die };
                    addToRollHistory({ label, sides: die, roll, modifier: conMod, total: clampedTotal, expression: `d${die}` });
                    renderLevelUpModal();
                }
            });
        }

        async function applyLevelUp() {
            if (!levelUpContext || !playerCharacter) return;
            if (levelUpContext.abilityError) {
                return showThemedAlert(levelUpContext.abilityError);
            }

            const hpGain = Math.max(1, parseInt(levelUpContext.hpGain, 10) || 1);
            const baseMax = playerCharacter?.maxHp ?? playerCharacter?.hp ?? 0;
            const newMax = baseMax + hpGain;
            const adjustments = computeAbilityAdjustments(levelUpContext.abilitySelections || []);
            const updates = {
                level: levelUpContext.targetLevel,
                maxHp: newMax,
                hp: newMax,
                currentHp: newMax
            };
            if (Object.keys(adjustments).length) {
                const updatedAbilities = { ...(playerCharacter.abilities || {}) };
                Object.entries(adjustments).forEach(([key, bonus]) => {
                    updatedAbilities[key] = (updatedAbilities[key] || 0) + bonus;
                });
                updates.abilities = updatedAbilities;
            }
            const summary = {
                hpGain,
                abilityIncreases: adjustments,
                features: levelUpContext.progression?.features || ''
            };

            try {
                const response = await fetch(`/player/${playerCharacter.id}/complete-level`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ updates, summary })
                });
                const data = await response.json();
                if (!data.success) {
                    return showThemedAlert(data.error || 'Failed to apply level-up.');
                }

                playerCharacter = data.player;
                renderCharacterSheet(playerCharacter, { skipGameUpdate: false });
                updateGameUI(playerCharacter);
                closeLevelUpModal();
                showLevelToast(`Level ${playerCharacter.level} complete!`, 'success');
                updateLevelUpCallout();
            } catch (error) {
                console.error('Failed to apply level-up', error);
                showThemedAlert('Failed to apply level-up.');
            }
        }

        function getInitiativeModifier(character = playerCharacter) {
            if (!character) return 0;
            const rawDex = character.abilities?.dexterity;
            const dexScore = parseInt(rawDex !== undefined ? rawDex : 10, 10);
            const dexMod = Math.floor(((isNaN(dexScore) ? 10 : dexScore) - 10) / 2);
            const manualBonus = parseInt(character.initiativeBonus ?? 0, 10);
            const featureBonus = parseInt(character.bonuses?.initiative ?? 0, 10);
            const overrideBonus = parseInt(initiativeBonusOverride ?? 0, 10) || 0;

            // Initiative is a Dexterity check (see SRD/OpenDND), so start with Dex mod and layer bonuses
            return dexMod
                + (isNaN(manualBonus) ? 0 : manualBonus)
                + (isNaN(featureBonus) ? 0 : featureBonus)
                + overrideBonus;
        }

        function getInitiativeBonusKey() {
            const userId = currentUser?.id || 'guest';
            return `initiativeBonus_${campaignId}_${userId}`;
        }

        function loadInitiativeBonusOverride() {
            const stored = localStorage.getItem(getInitiativeBonusKey());
            initiativeBonusOverride = stored !== null ? (parseInt(stored, 10) || 0) : 0;
            const input = document.getElementById('initiativeBonusInput');
            if (input) {
                input.value = initiativeBonusOverride;
            }
        }

        function handleInitiativeBonusInput(value) {
            const parsed = parseInt(value, 10);
            initiativeBonusOverride = isNaN(parsed) ? 0 : parsed;
            localStorage.setItem(getInitiativeBonusKey(), initiativeBonusOverride);
            refreshCharacterSheet();
        }

        function refreshCharacterSheet() {
            if (playerCharacter) {
                renderCharacterSheet(playerCharacter, { skipGameUpdate: true });
                updateGameUI(playerCharacter);
            }
        }

        function renderCharacterSheet(char, options = {}) {
            const abilities = char.abilities || {};
            const profBonus = calculateProficiencyBonus(char.level || 1);

            // Calculate ability modifiers
            const strMod = Math.floor(((abilities.strength ?? 10) - 10) / 2);
            const dexMod = Math.floor(((abilities.dexterity ?? 10) - 10) / 2);
            const conMod = Math.floor(((abilities.constitution ?? 10) - 10) / 2);
            const intMod = Math.floor(((abilities.intelligence ?? 10) - 10) / 2);
            const wisMod = Math.floor(((abilities.wisdom ?? 10) - 10) / 2);
            const chaMod = Math.floor(((abilities.charisma ?? 10) - 10) / 2);

            const expertiseSet = new Set(
                (char.expertise || []).map(value => normalizeSkillKey(value))
            );
            const initiative = getInitiativeModifier(char);
            const currentHp = char.currentHp ?? char.hp ?? char.maxHp ?? 0;
            const maxHp = char.maxHp ?? char.hp ?? currentHp;
            const classKey = (char.class || '').toLowerCase();
            const hitDie = CLASS_HIT_DICE[classKey] || 8;
            const hitDice = `${char.level || 1}d${hitDie}`;
            const passivePerception = 10 + wisMod
                + (char.skills?.includes('perception') ? profBonus : 0)
                + (expertiseSet.has('perception') ? profBonus : 0);
            const calculatedAC = calculateCharacterAC(char);
            const barbarianAttackCard = renderBarbarianAttackStatsCard(char, strMod, profBonus);
            const heroTags = [
                char.background,
                char.alignment
            ].filter(Boolean).map(tag => `<span class="hero-tag">${tag}</span>`).join('');
            const expertiseBadges = expertiseSet.size
                ? `<div class="stat-section-title">EXPERTISE</div>
                    <div class="expertise-list">
                        ${[...expertiseSet].map(key => `<span class="expertise-badge">${formatSkillLabel(key)}</span>`).join('')}
                    </div>`
                : '';
            const traitEntries = [
                { label: 'Personality', value: char.personality },
                { label: 'Ideals', value: char.ideals },
                { label: 'Bonds', value: char.bonds },
                { label: 'Flaws', value: char.flaws }
            ].filter(entry => entry.value);
            const traitsHtml = traitEntries.length
                ? `<div class="stat-section-title">Character Traits</div>
                    <div class="trait-grid">
                        ${traitEntries.map(entry => `
                            <div class="trait-card">
                                <div class="trait-label">${entry.label}</div>
                                <div class="trait-value">${entry.value}</div>
                            </div>
                        `).join('')}
                    </div>`
                : '';
            const proficiencyLines = (char.proficiencies || '')
                .split(/\n+/)
                .map(line => line.trim())
                .filter(Boolean);
            const proficienciesHtml = proficiencyLines.length
                ? `<div class="stat-section-title">Proficiencies</div>
                    <div class="proficiency-list">
                        ${proficiencyLines.map(line => `<div class="proficiency-line">${line}</div>`).join('')}
                    </div>`
                : '';
            const backstoryHtml = char.backstory
                ? `<div class="stat-section-title">Features & Notes</div>
                    <div class="trait-card">
                        <div class="trait-value">${char.backstory}</div>
                    </div>`
                : '';

            const sheetHtml = `
                <div class="dnd-sheet">
                    <div class="character-sheet-card">
                        <div class="character-hero">
                            <div class="hero-left">
                                <div class="hero-avatar">
                                    ${char.profileImage
                                        ? `<img src="${char.profileImage}" alt="${char.name}">`
                                        : `<span></span>`}
                                </div>
                                <div>
                                    <div class="hero-name">${char.name}</div>
                                    <div class="hero-subtitle">${char.race || 'Unknown Ancestry'} ${char.class || 'Adventurer'}</div>
                                    <div class="hero-tags">${heroTags || '<span class="hero-tag">Unaligned</span>'}</div>
                                </div>
                            </div>
                            <div class="hero-level-card">
                                <div class="hero-level-label">Level</div>
                                <div class="hero-level-value">${char.level || 1}</div>
                            </div>
                        </div>

                        <div class="quick-stat-grid">
                            <div class="quick-stat-card">
                                <div class="quick-stat-label">Hit Points</div>
                                <div class="quick-stat-value">${currentHp} / ${maxHp}</div>
                                <div class="quick-stat-sub">Max HP</div>
                            </div>
                            <div class="quick-stat-card">
                                <div class="quick-stat-label">Armor Class</div>
                                <div class="quick-stat-value">${calculatedAC}</div>
                                <div class="quick-stat-sub">Includes armor, shield & Dex</div>
                            </div>
                            <div class="quick-stat-card">
                                <div class="quick-stat-label">Speed</div>
                                <div class="quick-stat-value">${char.speed || 30} ft</div>
                                <div class="quick-stat-sub">Walking speed</div>
                            </div>
                            <div class="quick-stat-card">
                                <div class="quick-stat-label">Initiative</div>
                                <div class="quick-stat-value">${formatModifier(initiative)}</div>
                                <div class="quick-stat-sub">Dexterity check bonus</div>
                            </div>
                            <div class="quick-stat-card">
                                <div class="quick-stat-label">Proficiency</div>
                                <div class="quick-stat-value">${formatModifier(profBonus)}</div>
                                <div class="quick-stat-sub">Current bonus</div>
                            </div>
                            <div class="quick-stat-card">
                                <div class="quick-stat-label">Passive Perception</div>
                                <div class="quick-stat-value">${passivePerception}</div>
                                <div class="quick-stat-sub">10 + bonuses</div>
                            </div>
                            <div class="quick-stat-card">
                                <div class="quick-stat-label">Hit Dice</div>
                                <div class="quick-stat-value">${hitDice}</div>
                                <div class="quick-stat-sub">${char.class || 'Class'}</div>
                            </div>
                            ${barbarianAttackCard}
                        </div>
                        <div class="class-helper-wrapper" id="classFeatureHelpers"></div>

                        <div class="sheet-columns">
                            <div>
                                <div class="stat-section-title">Ability Scores</div>
                                <div class="abilities-grid">
                                    ${renderAbility('STR', abilities.strength || 10)}
                                    ${renderAbility('DEX', abilities.dexterity || 10)}
                                    ${renderAbility('CON', abilities.constitution || 10)}
                                    ${renderAbility('INT', abilities.intelligence || 10)}
                                    ${renderAbility('WIS', abilities.wisdom || 10)}
                                    ${renderAbility('CHA', abilities.charisma || 10)}
                                </div>

                                <div class="stat-section-title">Saving Throws</div>
                                <div class="saves-grid">
                                    ${renderSavingThrow('Strength', strMod, profBonus, char.savingThrows?.includes('strength'))}
                                    ${renderSavingThrow('Dexterity', dexMod, profBonus, char.savingThrows?.includes('dexterity'))}
                                    ${renderSavingThrow('Constitution', conMod, profBonus, char.savingThrows?.includes('constitution'))}
                                    ${renderSavingThrow('Intelligence', intMod, profBonus, char.savingThrows?.includes('intelligence'))}
                                    ${renderSavingThrow('Wisdom', wisMod, profBonus, char.savingThrows?.includes('wisdom'))}
                                    ${renderSavingThrow('Charisma', chaMod, profBonus, char.savingThrows?.includes('charisma'))}
                                </div>

                                ${expertiseBadges}
                            </div>

                            <div>
                                <div class="stat-section-title">Skills</div>
                                <div class="skills-grid">
                                    ${renderSkill('Acrobatics', dexMod, profBonus, 'dexterity', char.skills, expertiseSet)}
                                    ${renderSkill('Animal Handling', wisMod, profBonus, 'wisdom', char.skills, expertiseSet)}
                                    ${renderSkill('Arcana', intMod, profBonus, 'intelligence', char.skills, expertiseSet)}
                                    ${renderSkill('Athletics', strMod, profBonus, 'strength', char.skills, expertiseSet)}
                                    ${renderSkill('Deception', chaMod, profBonus, 'charisma', char.skills, expertiseSet)}
                                    ${renderSkill('History', intMod, profBonus, 'intelligence', char.skills, expertiseSet)}
                                    ${renderSkill('Insight', wisMod, profBonus, 'wisdom', char.skills, expertiseSet)}
                                    ${renderSkill('Intimidation', chaMod, profBonus, 'charisma', char.skills, expertiseSet)}
                                    ${renderSkill('Investigation', intMod, profBonus, 'intelligence', char.skills, expertiseSet)}
                                    ${renderSkill('Medicine', wisMod, profBonus, 'wisdom', char.skills, expertiseSet)}
                                    ${renderSkill('Nature', intMod, profBonus, 'intelligence', char.skills, expertiseSet)}
                                    ${renderSkill('Perception', wisMod, profBonus, 'wisdom', char.skills, expertiseSet)}
                                    ${renderSkill('Performance', chaMod, profBonus, 'charisma', char.skills, expertiseSet)}
                                    ${renderSkill('Persuasion', chaMod, profBonus, 'charisma', char.skills, expertiseSet)}
                                    ${renderSkill('Religion', intMod, profBonus, 'intelligence', char.skills, expertiseSet)}
                                    ${renderSkill('Sleight of Hand', dexMod, profBonus, 'dexterity', char.skills, expertiseSet)}
                                    ${renderSkill('Stealth', dexMod, profBonus, 'dexterity', char.skills, expertiseSet)}
                                    ${renderSkill('Survival', wisMod, profBonus, 'wisdom', char.skills, expertiseSet)}
                                </div>

                            </div>
                        </div>

                    <div class="stat-section-title">Equipment</div>
                    <div class="equipment-section" id="equipmentSection">
                        ${renderEquipmentFromInventory()}
                    </div>

                    ${traitsHtml}
                    ${proficienciesHtml}
                    ${backstoryHtml}
                </div>
            </div>
        `;

            document.getElementById('characterSheet').innerHTML = sheetHtml;
            updateLevelUpCallout();
            renderClassFeatureHelpers(char);
            renderCombatRageControlBar().catch(err => console.error('Failed to render combat rage control', err));
            populateBarbarianAttackStats(char).catch(err => console.error('Failed to refresh barbarian attack stats', err));
            if (!options.skipGameUpdate) {
                updateGameUI(char);
            }
        }

        function renderClassFeatureHelpers(char) {
            const container = document.getElementById('classFeatureHelpers');
            if (!container) return;
            if (userRole !== 'player') {
                container.style.display = 'none';
                container.innerHTML = '';
                return;
            }

            container.innerHTML = '';
            container.style.display = 'block';

            (async () => {
                const sections = [];
                const classKey = normalizeClassKey(char.class || '');
                if (classKey === 'barbarian') {
                    sections.push(await buildBarbarianHelper(char));
                }
                if (classKey === 'rogue') {
                    sections.push(await buildRogueHelper(char));
                }
                const filtered = sections.filter(Boolean);
                if (!filtered.length) {
                    container.style.display = 'none';
                    container.innerHTML = '';
                } else {
                    container.innerHTML = filtered.join('');
                    container.style.display = 'block';
                }
            })().catch(err => console.error('Failed to render class helpers', err));
        }

        async function renderCombatRageControlBar() {
            const container = document.getElementById('combatRageControl');
            if (!container) return;
            if (!playerCharacter || normalizeClassKey(playerCharacter.class || '') !== 'barbarian') {
                container.style.display = 'none';
                container.innerHTML = '';
                return;
            }
            const config = await ensureBarbarianConfig(playerCharacter);
            if (!config) {
                container.style.display = 'none';
                container.innerHTML = '';
                return;
            }
            const tracker = getRageTrackerState(playerCharacter.id, config.totalRages);
            container.innerHTML = `
                <div class="rage-control-header">
                    <div>Rage (${tracker.remaining}/${config.totalRages})</div>
                    <div>${tracker.isRaging ? 'Active' : 'Inactive'}</div>
                </div>
                <div class="rage-control-actions">
                    <button onclick="rageControlAction(${playerCharacter.id}, 'use')">Use</button>
                    <button onclick="rageControlAction(${playerCharacter.id}, 'end')">End</button>
                    <button onclick="rageControlAction(${playerCharacter.id}, 'reset')">Reset</button>
                </div>
                <div class="helper-note">Barbarian rage adds ${config.rageDamage} to melee attacks and grants resistances.</div>
            `;
            container.style.display = 'flex';
        }

        function getCharacterDataForActor(actorId, actorType) {
            const numericId = parseInt(actorId, 10);
            if (Number.isNaN(numericId)) return null;
            if (actorType === 'player') {
                if (playerCharacter && playerCharacter.id === numericId) return playerCharacter;
                const dmPlayer = campaignPlayers.find(p => p.id === numericId);
                if (dmPlayer) return dmPlayer;
            }
            return null;
        }

        async function fetchClassLevelInfo(classKey, level) {
            const cacheKey = `${classKey}-${level}`;
            if (classLevelInfoCache[cacheKey]) return classLevelInfoCache[cacheKey];

            try {
                const response = await fetch(`/leveling/class/${classKey}/${level}`);
                const data = await response.json();
                if (!data.success) return null;
                classLevelInfoCache[cacheKey] = data.progression;
                return data.progression;
            } catch (error) {
                console.error('Failed to load class progression', error);
                return null;
            }
        }

        function getProgressionValue(progression, key) {
            if (!progression || !progression.columns) return null;
            const column = progression.columns.find(col => col.key === key);
            return column ? column.value : null;
        }

        function parseBonusValue(value) {
            if (!value && value !== 0) return 0;
            if (typeof value === "number") return value;
            const match = value.toString().match(/-?\d+/);
            return match ? parseInt(match[0], 10) : 0;
        }

        async function ensureBarbarianConfig(char) {
            if (!char || normalizeClassKey(char.class || '') !== 'barbarian') return null;
            const currentLevel = char.level || 1;
            const cached = barbarianHelperConfig[char.id];
            if (cached && cached.level === currentLevel) return cached;

            const progression = await fetchClassLevelInfo('barbarian', currentLevel);
            if (!progression) return null;
            const totalRages = parseInt(getProgressionValue(progression, "rages"), 10) || 2;
            const rageDamage = getProgressionValue(progression, "rageDamage") || "+2";
            barbarianHelperConfig[char.id] = { level: currentLevel, totalRages, rageDamage };
            return barbarianHelperConfig[char.id];
        }

        async function buildBarbarianHelper(char) {
            const config = await ensureBarbarianConfig(char);
            if (!config) return '';

            const { totalRages, rageDamage } = config;
            const tracker = getRageTrackerState(char.id, totalRages);
            const ragingBadge = tracker.isRaging ? 'helper-badge active' : 'helper-badge';
            const ragingText = tracker.isRaging ? 'Raging' : 'Calm';

            return `
                <div class="class-helper-card barbarian-helper">
                    <div class="helper-header">
                        <div>
                            <div class="helper-title">Rage Tracker</div>
                            <div class="helper-subtitle">Rage damage bonus ${rageDamage}</div>
                        </div>
                        <div class="${ragingBadge}">${ragingText}</div>
                    </div>
                    <div class="helper-metrics">
                        <div class="helper-metric">
                            <div class="helper-metric-label">Rages Remaining</div>
                            <div class="helper-metric-value">${tracker.remaining} / ${totalRages}</div>
                        </div>
                    </div>
                    <div class="helper-actions">
                        <button onclick="useRage(${char.id})">Spend Rage</button>
                        <button onclick="endRage(${char.id})">End Rage</button>
                        <button onclick="resetRages(${char.id})">Reset (Long Rest)</button>
                    </div>
                    <div class="helper-note">Raging grants resistance to physical damage and adds ${rageDamage} to melee attacks. Track uses between long rests.</div>
                </div>
            `;
        }

        async function buildRogueHelper(char) {
            const progression = await fetchClassLevelInfo('rogue', char.level || 1);
            if (!progression) return '';
            const sneakDice = getProgressionValue(progression, "sneakAttack") || "1d6";

            return `
                <div class="class-helper-card rogue-helper">
                    <div class="helper-header">
                        <div>
                            <div class="helper-title">Sneak Attack</div>
                            <div class="helper-subtitle">Backstab damage scales with level</div>
                        </div>
                        <div class="helper-badge">${sneakDice}</div>
                    </div>
                    <div class="helper-metrics">
                        <div class="helper-metric">
                            <div class="helper-metric-label">Damage Dice</div>
                            <div class="helper-metric-value">${sneakDice}</div>
                        </div>
                    </div>
                    <div class="helper-actions">
                        <button onclick="rollSneakAttack(${char.id}, '${sneakDice}')">Roll Sneak Attack</button>
                    </div>
                    <div class="helper-note">Once per turn when you have advantage (or an ally is adjacent), add ${sneakDice} extra damage.</div>
                </div>
            `;
        }

        function getRageTrackerState(characterId, totalRages) {
            const key = `rageTracker_${characterId}`;
            if (!rageTrackerState[characterId]) {
                try {
                    rageTrackerState[characterId] = JSON.parse(localStorage.getItem(key)) || {};
                } catch {
                    rageTrackerState[characterId] = {};
                }
            }
            const state = rageTrackerState[characterId];
            if (typeof state.remaining !== "number") state.remaining = totalRages;
            if (typeof state.isRaging !== "boolean") state.isRaging = false;
            state.total = totalRages;
            if (state.remaining > totalRages) state.remaining = totalRages;
            if (state.remaining < 0) state.remaining = 0;
            return state;
        }

        function getBarbarianRageContext(characterId) {
            const config = barbarianHelperConfig[characterId];
            if (!config) return null;
            const tracker = getRageTrackerState(characterId, config.totalRages);
            return { tracker, config };
        }

        function persistRageTracker(characterId) {
            const key = `rageTracker_${characterId}`;
            const state = rageTrackerState[characterId];
            localStorage.setItem(key, JSON.stringify({
                remaining: state.remaining,
                isRaging: state.isRaging
            }));
        }

        function updateRageTracker(characterId, updater) {
            const config = barbarianHelperConfig[characterId];
            if (!config) return;
            const tracker = getRageTrackerState(characterId, config.totalRages);
            const shouldUpdate = updater(tracker, config);
            if (shouldUpdate === false) return;
            persistRageTracker(characterId);
            if (playerCharacter && playerCharacter.id === characterId) {
                renderClassFeatureHelpers(playerCharacter);
                renderCombatRageControlBar().catch(err => console.error('Failed to render combat rage control', err));
                populateBarbarianAttackStats(playerCharacter).catch(err => console.error('Failed to refresh barbarian attack stats', err));
            }
        }

        async function computeBarbarianRageBonus(character, damageType) {
            if (!character || normalizeClassKey(character.class || '') !== 'barbarian') {
                return { bonus: 0, active: false };
            }
            const normalizedType = (damageType || '').toLowerCase();
            const physicalTypes = new Set(['bludgeoning', 'slashing', 'piercing', 'physical', '']);
            if (!physicalTypes.has(normalizedType)) {
                return { bonus: 0, active: false };
            }
            await ensureBarbarianConfig(character);
            const context = getBarbarianRageContext(character.id);
            if (!context || !context.tracker.isRaging) {
                return { bonus: 0, active: false };
            }
            const bonus = Math.max(0, parseBonusValue(context.config.rageDamage) || 0);
            return { bonus, active: bonus > 0 };
        }

        async function populateBarbarianAttackStats(character) {
            const card = document.getElementById('barbarianAttackStatsCard');
            if (!card || !character || normalizeClassKey(character.class || '') !== 'barbarian') return;

            const str = character.abilities?.strength || 10;
            const strMod = getAbilityModifier(str);
            const profBonus = calculateProficiencyBonus(character.level || 1);
            const meleeEl = document.getElementById('barbarianMeleeAttack');
            if (meleeEl) meleeEl.textContent = formatModifier(strMod + profBonus);

            try {
                const rage = await computeBarbarianRageBonus(character, '');
                const rageValEl = document.getElementById('barbarianRageBonusValue');
                const rageStatusEl = document.getElementById('barbarianRageStatus');
                if (rageValEl) rageValEl.textContent = formatModifier(rage.bonus || 0);
                if (rageStatusEl) {
                    rageStatusEl.textContent = rage.active ? '(raging)' : '(inactive)';
                    rageStatusEl.style.color = rage.active ? '#f97316' : '#94a3b8';
                }
            } catch (error) {
                console.error('Failed to populate barbarian attack stats', error);
            }
        }

        function useRage(characterId) {
            updateRageTracker(characterId, tracker => {
                if (tracker.remaining <= 0) {
                    showLevelToast('No rages left until next long rest.', 'warning');
                    return false;
                }
                tracker.remaining -= 1;
                tracker.isRaging = true;
                showLevelToast('You fly into a rage!', 'info');
                return true;
            });
        }

        function endRage(characterId) {
            updateRageTracker(characterId, tracker => {
                if (!tracker.isRaging) return false;
                tracker.isRaging = false;
                showLevelToast('Rage ends.', 'info');
                return true;
            });
        }

        function resetRages(characterId) {
            updateRageTracker(characterId, tracker => {
                tracker.remaining = tracker.total;
                tracker.isRaging = false;
                showLevelToast('Rages refreshed after a long rest.', 'success');
                return true;
            });
        }

        function rollDiceExpression(expression) {
            if (!expression) return null;
            const match = expression.match(/(\d+)\s*d\s*(\d+)/i);
            if (!match) return null;
            const count = parseInt(match[1], 10);
            const sides = parseInt(match[2], 10);
            if (!count || !sides) return null;
            const rolls = [];
            let total = 0;
            for (let i = 0; i < count; i++) {
                const roll = Math.floor(Math.random() * sides) + 1;
                rolls.push(roll);
                total += roll;
            }
            return { expression: `${count}d${sides}`, sides, rolls, total };
        }

        function rollSneakAttack(characterId, expression) {
            const result = rollDiceExpression(expression);
            if (!result) {
                showThemedAlert('Unable to parse Sneak Attack dice.');
                return;
            }
            const detail = result.rolls.join(' + ');
            const message = `Sneak Attack ${result.expression}: ${detail} = ${result.total}`;
            showLevelToast(message, 'info');
            addToRollHistory({
                label: 'Sneak Attack',
                sides: result.sides,
                roll: result.total,
                modifier: 0,
                total: result.total,
                expression: result.expression
            });
        }

        window.useRage = useRage;
        window.endRage = endRage;
        window.resetRages = resetRages;
        window.rollSneakAttack = rollSneakAttack;
        window.toggleRageFromCombat = toggleRageFromCombat;

        async function updateAttackModalRageControl(character) {
            const container = document.getElementById('rageControl');
            if (!container) return;
            if (!character || normalizeClassKey(character.class || '') !== 'barbarian') {
                container.style.display = 'none';
                container.innerHTML = '';
                return;
            }
            await ensureBarbarianConfig(character);
            const context = getBarbarianRageContext(character.id);
            if (!context) {
                container.style.display = 'none';
                container.innerHTML = '';
                return;
            }
            const { tracker, config } = context;
            container.className = 'form-group rage-control';
            container.innerHTML = `
                <div class="rage-control-header">
                    <div>Rage (${tracker.remaining}/${config.totalRages})</div>
                    <div>${tracker.isRaging ? 'Active' : 'Inactive'}</div>
                </div>
                <div class="rage-control-actions">
                    <button onclick="rageControlAction(${character.id}, 'use')">Use Rage</button>
                    <button onclick="rageControlAction(${character.id}, 'end')">End Rage</button>
                    <button onclick="rageControlAction(${character.id}, 'reset')">Reset</button>
                </div>
                <div class="helper-note">Gain +${parseBonusValue(config.rageDamage)} melee damage while raging.</div>
            `;
            container.style.display = 'flex';
        }

        window.rageControlAction = function(characterId, action) {
            if (action === 'use') useRage(characterId);
            else if (action === 'end') endRage(characterId);
            else if (action === 'reset') resetRages(characterId);
            if (currentAttackActorData && currentAttackActorData.id === characterId) {
                updateAttackModalRageControl(currentAttackActorData);
            }
        };

        function shouldShowRageButton(entity) {
            if (!entity) return false;
            return normalizeClassKey(entity.class || '') === 'barbarian';
        }

        function getRageActionButton(entity) {
            if (!shouldShowRageButton(entity)) return '';
            const config = barbarianHelperConfig[entity.id];
            if (!config) return '';
            const tracker = getRageTrackerState(entity.id, config.totalRages);
            const label = tracker.isRaging
                ? 'End Rage'
                : tracker.remaining > 0
                    ? `Rage (${tracker.remaining})`
                    : 'Rage (0)';
            const disabledAttr = !tracker.isRaging && tracker.remaining <= 0 ? 'disabled' : '';
            return `<button class="action-btn action-btn-rage" ${disabledAttr} onclick="toggleRageFromCombat(${entity.id})">${label}</button>`;
        }

        function toggleRageFromCombat(characterId) {
            const config = barbarianHelperConfig[characterId];
            if (!config) return;
            const tracker = getRageTrackerState(characterId, config.totalRages);
            if (tracker.isRaging) {
                endRage(characterId);
            } else if (tracker.remaining > 0) {
                useRage(characterId);
            } else {
                showLevelToast('No rages remaining.', 'warning');
                return;
            }
            renderInitiativeTracker();
            renderPlayerInitiativeTracker();
            renderCombatRageControlBar().catch(err => console.error('Failed to render combat rage control', err));
        }

        function updateLevelUpCallout() {
            const bar = document.getElementById('levelUpCalloutBar');
            if (!bar) return;
            const pending = userRole === 'player' ? playerCharacter?.pendingLevelUp : null;
            if (!pending || !pending.targetLevel) {
                bar.style.display = 'none';
                bar.innerHTML = '';
                return;
            }

            bar.innerHTML = `
                <button class="levelup-callout" onclick="openLevelUpWorkflow()">
                    Level Up  | Level ${pending.targetLevel}
                </button>
            `;
            bar.style.display = 'flex';
        }

        // Calculate proficiency bonus based on level
        function calculateProficiencyBonus(level) {
            return Math.floor((level - 1) / 4) + 2;
        }

        // Format modifier with + or -
        function formatModifier(mod) {
            return (mod >= 0 ? '+' : '') + mod;
        }

        function renderBarbarianAttackStatsCard(char, strMod, profBonus) {
            const classKey = normalizeClassKey(char.class || '');
            if (classKey !== 'barbarian') return '';
            const baseAttack = strMod + profBonus;
            return `
                <div class="quick-stat-card barbarian-attack-card" id="barbarianAttackStatsCard">
                    <div class="quick-stat-label">Barbarian</div>
                    <div class="quick-stat-value" id="barbarianMeleeAttack">${formatModifier(baseAttack)}</div>
                    <div class="quick-stat-sub">
                        Melee attack (STR + prof)<br>
                        Rage dmg: <span id="barbarianRageBonusValue">+0</span>
                        <span id="barbarianRageStatus" style="color: #94a3b8;">(inactive)</span>
                    </div>
                </div>
            `;
        }

        // Render saving throw
        function renderSavingThrow(name, baseMod, profBonus, isProficient) {
            const total = isProficient ? baseMod + profBonus : baseMod;
            return `
                <div class="save-row ${isProficient ? 'proficient' : ''} rollable" data-roll-label="${name} Save" data-roll-modifier="${total}">
                    <div class="save-prof">${isProficient ? '' : ''}</div>
                    <div class="save-modifier">${formatModifier(total)}</div>
                    <div class="save-name">${name}</div>
                </div>
            `;
        }

        // Render skill
        function renderSkill(name, abilityMod, profBonus, ability, characterSkills, expertiseSet) {
            const skillKey = normalizeSkillKey(name);
            const hasExpertise = expertiseSet?.has(skillKey);
            const hasProficiency = characterSkills?.includes(skillKey);
            const isProficient = hasProficiency || hasExpertise;
            let total = abilityMod;

            if (hasExpertise) {
                total += profBonus * 2;
            } else if (hasProficiency) {
                total += profBonus;
            }

            const abilityLabel = (ability || '').substring(0, 3).toUpperCase();
            const badge = hasExpertise ? '<span class="skill-badge">Expertise</span>' : '';

            return `
                <div class="skill-row ${isProficient ? 'proficient' : ''} ${hasExpertise ? 'expert' : ''} rollable" data-roll-label="Skill: ${name}" data-roll-modifier="${total}">
                    <div class="skill-prof">${isProficient ? '' : ''}</div>
                    <div class="skill-modifier">${formatModifier(total)}</div>
                    <div class="skill-name">${name}</div>
                    <div class="skill-ability">(${abilityLabel}) ${badge}</div>
                </div>
            `;
        }

        function normalizeSkillKey(value) {
            return (value || '').toString().toLowerCase().replace(/[^a-z]/g, '');
        }

        function formatSkillLabel(key) {
            const normalized = normalizeSkillKey(key);
            if (!normalized) return 'Skill';
            return SKILL_LABELS[normalized] || normalized.charAt(0).toUpperCase() + normalized.slice(1);
        }

        // Render equipment from inventory
        function escapeHtml(value) {
            if (value === null || value === undefined) return '';
            return value.toString()
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        function renderEquipmentFromInventory() {
            if (playerInventory.length === 0) {
                return '<div class="empty-equipment">No equipment. Add items in the Inventory section.</div>';
            }

            const equippedItems = playerInventory.filter(item => item.equipped);
            const carriedItems = playerInventory.filter(item => !item.equipped);

            const renderEquipmentCard = item => {
                const category = item.category || item.type || 'gear';
                const icon = category === 'weapon'
                    ? ''
                    : (category === 'armor' || category === 'shield') ? ''
                    : category === 'potion' ? ''
                    : category === 'consumable' ? ''
                    : '';

                const details = [];
                if (item.damage?.dice && category === 'weapon') {
                    details.push(`${item.damage.dice} ${item.damage.type || ''}`.trim());
                }
                if ((item.acBase || item.acBonus) && (category === 'armor' || category === 'shield')) {
                    const parts = [];
                    if (item.acBase) parts.push(`Base ${item.acBase}`);
                    if (item.acBonus) parts.push(`+${item.acBonus}`);
                    details.push(`AC ${parts.join(' ')}`.trim());
                }
                if (item.effect?.dice) {
                    const label = item.effect.type === 'healing'
                        ? 'Heal'
                        : item.effect.type === 'damage'
                            ? `Dmg ${item.effect.damageType || ''}`.trim()
                            : 'Effect';
                    details.push(`${label} ${item.effect.dice}`.trim());
                }

                return `
                    <div class="equipment-item ${item.equipped ? 'equipped' : ''}">
                        <div>
                            <div class="equipment-item-name">
                                <span class="equipment-icon">${icon}</span>
                                ${item.name || 'Unnamed Item'}
                                ${item.equipped ? '<span class="equipment-chip">Equipped</span>' : ''}
                            </div>
                            ${details.length ? `<div class="equipment-meta">${details.join('  ')}</div>` : ''}
                        </div>
                        <div class="equipment-item-qty">${item.quantity || 1}</div>
                    </div>
                `;
            };

            const buildGroup = (title, items) => `
                <div class="equipment-group">
                    <div class="equipment-group-title">${title}</div>
                    <div class="equipment-list">
                        ${items.map(renderEquipmentCard).join('')}
                    </div>
                </div>
            `;

            const groups = [];
            if (equippedItems.length) {
                groups.push(buildGroup('Equipped', equippedItems));
            }
            if (carriedItems.length) {
                groups.push(buildGroup(equippedItems.length ? 'Pack & Storage' : 'All Items', carriedItems));
            }

            return groups.join('');
        }

        // Render ability box
        function renderAbility(name, score) {
            const modifier = Math.floor((score - 10) / 2);
            const modifierStr = (modifier >= 0 ? '+' : '') + modifier;

            return `
                <div class="ability-box rollable" data-roll-label="${name} Check" data-roll-modifier="${modifier}">
                    <div class="ability-name">${name}</div>
                    <div class="ability-score">${score}</div>
                    <div class="ability-modifier">${modifierStr}</div>
                </div>
            `;
        }

        // Switch Tab
        function switchTab(evt, tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            if (evt && evt.target) {
                evt.target.classList.add('active');
            }

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName + 'Tab').classList.add('active');
        }

        // Dice Roller
        function selectDice(sides) {
            selectedDiceSides = sides;
            document.querySelectorAll('.dice-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        function getDiceDisplayElements() {
            return document.querySelectorAll('[data-dice-display]');
        }

        function getDiceResultElements() {
            return document.querySelectorAll('[data-dice-result]');
        }

        function formatRollBreakdown(roll, modifier, total) {
            if (modifier === 0) {
                return `${total}`;
            }

            const operator = modifier >= 0 ? '+' : '-';
            return `${roll} ${operator} ${Math.abs(modifier)} = ${total}`;
        }

        function hasValue(v) {
            return v !== undefined && v !== null;
        }

        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        // Death save helpers
        function getDeathSaveKey(characterId) {
            return `deathSaves_${characterId}`;
        }

        function getDeathSaveState(characterId) {
            if (!characterId) return { successes: 0, fails: 0 };
            if (!deathSaveStateCache[characterId]) {
                try {
                    deathSaveStateCache[characterId] = JSON.parse(localStorage.getItem(getDeathSaveKey(characterId))) || { successes: 0, fails: 0 };
                } catch {
                    deathSaveStateCache[characterId] = { successes: 0, fails: 0 };
                }
            }
            const state = deathSaveStateCache[characterId];
            state.successes = Math.max(0, Math.min(3, parseInt(state.successes, 10) || 0));
            state.fails = Math.max(0, Math.min(3, parseInt(state.fails, 10) || 0));
            return state;
        }

        function persistDeathSaveState(characterId, state) {
            if (!characterId) return;
            deathSaveStateCache[characterId] = state;
            localStorage.setItem(getDeathSaveKey(characterId), JSON.stringify(state));
        }

        function resetDeathSaves() {
            if (!playerCharacter) return;
            const state = { successes: 0, fails: 0 };
            persistDeathSaveState(playerCharacter.id, state);
            renderDeathSaveTracker(playerCharacter);
        }

        function renderDeathSaveTracker(character, overrideHP = null, overrideMax = null) {
            if (!character || !activeEncounter) return;

            const currentHP = overrideHP !== null ? overrideHP : (character.currentHp ?? character.hp ?? 0);
            const maxHP = overrideMax !== null ? overrideMax : (character.maxHp ?? character.hp ?? 0);
            let state = getDeathSaveState(character.id);

            // If conscious, clear state
            if (currentHP > 0 && (state.successes > 0 || state.fails > 0)) {
                state = { successes: 0, fails: 0 };
                persistDeathSaveState(character.id, state);
            }

            // Nothing to render here; inline cards read state directly
        }

        function buildDeathSaveDots(state) {
            return `
                <div class="death-save-dots" title="Successes">
                    ${[0,1,2].map(i => `<div class="death-dot ${i < state.successes ? 'success' : ''}"></div>`).join('')}
                </div>
                <div class="death-save-dots" title="Failures">
                    ${[0,1,2].map(i => `<div class="death-dot ${i < state.fails ? 'fail' : ''}"></div>`).join('')}
                </div>
            `;
        }

        function applyDeathSaveResult(result) {
            if (!playerCharacter) return;
            const maxHP = playerCharacter.maxHp ?? playerCharacter.hp ?? 0;
            let currentHP = playerCharacter.currentHp ?? playerCharacter.hp ?? 0;
            // Ensure downed characters stay at 0 HP unless a nat 20 occurs
            if (currentHP > 0) currentHP = 0;
            let state = getDeathSaveState(playerCharacter.id);

            if (result.nat20) {
                currentHP = Math.max(1, currentHP);
                state = { successes: 0, fails: 0 };
                playerCharacter.currentHp = currentHP;
                playerCharacter.hp = Math.max(playerCharacter.hp ?? 0, currentHP);
                updateHealthBar(currentHP, maxHP);
                const input = document.getElementById('playerHPInput');
                if (input) input.value = currentHP;
                showLevelToast('Nat 20! You regain 1 HP.', 'success');
            } else {
                state.successes = Math.min(3, state.successes + (result.successes || 0));
                state.fails = Math.min(3, state.fails + (result.fails || 0));
                persistDeathSaveState(playerCharacter.id, state);
                if (state.successes >= 3) {
                    // Stabilized at 0 HP
                    currentHP = 0;
                    playerCharacter.currentHp = currentHP;
                    showLevelToast('Stabilized (3 successes).', 'info');
                } else if (state.fails >= 3) {
                    showLevelToast('Death saving throws failed (3).', 'warning');
                }
            }

            // Keep HP at current value (0 when stabilized)
            playerCharacter.currentHp = currentHP;
            persistDeathSaveState(playerCharacter.id, state);
            renderDeathSaveTracker(playerCharacter, currentHP, maxHP);
            persistDeathSaveStatusToEncounter(state, currentHP);
        }

        async function persistDeathSaveStatusToEncounter(state, currentHP) {
            if (!activeEncounter || !playerCharacter) return;
            const participantId = playerCharacter.userId || playerCharacter.id;
            try {
                const response = await fetch(`/encounter/${activeEncounter.id}/participant/${participantId}/hp`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        hp: currentHP,
                        type: 'player',
                        deathFails: state.fails,
                        deathSuccesses: state.successes,
                        defeated: currentHP <= 0 && state.fails >= 3
                    })
                });
                const data = await response.json();
                if (data.success && data.encounter) {
                    activeEncounter = data.encounter;
                    syncParticipantsWithPlayers(activeEncounter);
                    updateCombatUI();
                }
            } catch (err) {
                console.error('Failed to persist death save status', err);
            }
        }

        function rollDeathSave() {
            if (!playerCharacter) return;
            if (!activeEncounter) {
                showThemedAlert('Death saves can only be rolled during an active encounter.');
                return;
            }
            const label = 'Death Save';
            openDiceRollerModal(label, 0);
            animateDiceRoll({
                sides: 20,
                modifier: 0,
                label,
                onComplete: ({ roll }) => {
                    let successes = 0;
                    let fails = 0;
                    let nat20 = false;
                    if (roll === 1) {
                        fails = 2;
                    } else if (roll === 20) {
                        nat20 = true;
                    } else if (roll >= 10) {
                        successes = 1;
                    } else {
                        fails = 1;
                    }
                    addToRollHistory({ label, sides: 20, roll, modifier: 0, total: roll });
                    applyDeathSaveResult({ successes, fails, nat20 });
                    deathSaveRolledThisTurn = true;
                    renderPlayerInitiativeTracker();
                    renderInitiativeTracker();
                }
            });
        }

        function openDiceRollerModal(label, modifier) {
            const modal = document.getElementById('diceRollerModal');
            if (!modal) return;

            modal.classList.add('active');
            modal.setAttribute('aria-hidden', 'false');

            const titleEl = document.getElementById('diceModalTitle');
            if (titleEl) {
                titleEl.textContent = label || 'Roll';
            }

            const subtitleEl = document.getElementById('diceModalSubtitle');
            if (subtitleEl) {
                subtitleEl.textContent = `Modifier ${formatModifier(modifier)}`;
            }

            const modalResult = document.getElementById('modalDiceResult');
            if (modalResult) {
                modalResult.textContent = 'Rolling...';
            }

            const rollValue = document.getElementById('diceModalRollValue');
            if (rollValue) {
                rollValue.textContent = '';
            }

            const modifierValue = document.getElementById('diceModalModifierValue');
            if (modifierValue) {
                modifierValue.textContent = formatModifier(modifier);
            }

            const totalValue = document.getElementById('diceModalTotalValue');
            if (totalValue) {
                totalValue.textContent = '';
            }
        }

        function closeDiceRollerModal() {
            const modal = document.getElementById('diceRollerModal');
            if (!modal) return;

            modal.classList.remove('active');
            modal.setAttribute('aria-hidden', 'true');
        }

        function hideCriticalEffect() {
            const overlay = document.getElementById('criticalEffect');
            if (!overlay) return;

            overlay.classList.remove('active', 'success', 'fail');
            if (criticalEffectTimeout) {
                clearTimeout(criticalEffectTimeout);
                criticalEffectTimeout = null;
            }
        }

        function showCriticalEffect(type, roll) {
            const overlay = document.getElementById('criticalEffect');
            if (!overlay) return;

            const iconEl = document.getElementById('criticalEffectIcon');
            const textEl = document.getElementById('criticalEffectText');
            const isSuccess = type === 'success';

            overlay.classList.remove('active', 'success', 'fail');
            // Force reflow to restart animation
            void overlay.offsetWidth;

            overlay.classList.add(isSuccess ? 'success' : 'fail', 'active');
            if (iconEl) {
                iconEl.textContent = isSuccess ? '' : '';
            }
            if (textEl) {
                textEl.textContent = isSuccess
                    ? `Critical Success! (Natural ${roll})`
                    : `Critical Fail! (Natural ${roll})`;
            }

            if (criticalEffectTimeout) {
                clearTimeout(criticalEffectTimeout);
            }
            criticalEffectTimeout = setTimeout(() => {
                overlay.classList.remove('active');
                criticalEffectTimeout = null;
            }, 2500);
        }

        function updateDiceResultDisplay(label, roll, modifier, total) {
            const breakdown = formatRollBreakdown(roll, modifier, total);

            getDiceDisplayElements().forEach(el => {
                el.textContent = roll;
                el.classList.remove('rolling');
            });

            getDiceResultElements().forEach(el => {
                el.textContent = label ? `${label}: ${breakdown}` : breakdown;
            });

            const rollValue = document.getElementById('diceModalRollValue');
            if (rollValue) {
                rollValue.textContent = roll;
            }

            const modifierValue = document.getElementById('diceModalModifierValue');
            if (modifierValue) {
                modifierValue.textContent = formatModifier(modifier);
            }

            const totalValue = document.getElementById('diceModalTotalValue');
            if (totalValue) {
                totalValue.textContent = total;
            }
        }

        function animateDiceRoll({ sides, modifier = 0, label = '', onComplete }) {
            let count = 0;
            const diceElements = getDiceDisplayElements();

            hideCriticalEffect();

            diceElements.forEach(el => el.classList.add('rolling'));

            const interval = setInterval(() => {
                const interimRoll = Math.floor(Math.random() * sides) + 1;
                diceElements.forEach(el => {
                    el.textContent = interimRoll;
                });
                count++;
                if (count > 10) {
                    clearInterval(interval);
                    const roll = Math.floor(Math.random() * sides) + 1;
                    const total = roll + modifier;

                    updateDiceResultDisplay(label, roll, modifier, total);

                    if (sides === 20) {
                        if (roll === 20) {
                            showCriticalEffect('success', roll);
                        } else if (roll === 1) {
                            showCriticalEffect('fail', roll);
                        }
                    }

                    if (typeof onComplete === 'function') {
                        onComplete({ roll, total });
                    }
                }
            }, 100);
        }

        function triggerModifierRoll(label, modifier = 0) {
            const cleanModifier = parseInt(modifier, 10) || 0;
            openDiceRollerModal(label, cleanModifier);
            animateDiceRoll({
                sides: 20,
                modifier: cleanModifier,
                label,
                onComplete: ({ roll, total }) => {
                    addToRollHistory({ label, sides: 20, roll, modifier: cleanModifier, total });
                }
            });
        }

        function rollDice() {
            const modifier = parseInt(document.getElementById('diceModifier').value) || 0;
            animateDiceRoll({
                sides: selectedDiceSides,
                modifier,
                label: '',
                onComplete: ({ roll, total }) => {
                    addToRollHistory({ sides: selectedDiceSides, roll, modifier, total });
                }
            });
        }

        function addToRollHistory({ label, sides, roll, modifier, total, expression }) {
            const historyItem = {
                label,
                sides,
                roll,
                modifier,
                total,
                expression
            };

            rollHistory.unshift(historyItem);
            if (rollHistory.length > 5) rollHistory.pop();

            const historyDiv = document.getElementById('rollHistory');
            const historyList = document.getElementById('rollHistoryList');

            historyDiv.style.display = 'block';

            const html = rollHistory.map(h => {
                const breakdown = formatRollBreakdown(h.roll, h.modifier, h.total);
                const labelPrefix = h.label ? `${escapeHtml(h.label)}  ` : '';
                const diceLabel = h.expression ? h.expression : `d${h.sides}`;
                return `<div class="roll-history-item">${labelPrefix}${escapeHtml(diceLabel)}: ${breakdown}</div>`;
            }).join('');

            historyList.innerHTML = html;

            postDiceLog(historyItem);
        }

        document.addEventListener('click', function(event) {
            const rollTarget = event.target.closest('[data-roll-modifier]');
            if (!rollTarget) {
                return;
            }

            const modifier = rollTarget.getAttribute('data-roll-modifier');
            const label = rollTarget.getAttribute('data-roll-label') || 'Roll';
            triggerModifierRoll(label, modifier);
        });

        const diceModalElement = document.getElementById('diceRollerModal');
        if (diceModalElement) {
            diceModalElement.addEventListener('click', function(event) {
                if (event.target === diceModalElement) {
                    closeDiceRollerModal();
                }
            });
        }

        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeDiceRollerModal();
            }
        });


        // Start Polling
        function startPolling() {
            updateLiveSyncIndicators();
            pollCombatStatus();
            pollInterval = setInterval(pollCombatStatus, 3000);
            if (!liveSyncInterval) {
                liveSyncInterval = setInterval(updateLiveSyncIndicators, 2000);
            }
        }

        // Stop Polling
        function stopPolling() {
            if (pollInterval) {
                clearInterval(pollInterval);
                pollInterval = null;
            }
            if (liveSyncInterval) {
                clearInterval(liveSyncInterval);
                liveSyncInterval = null;
            }
        }

        // Show error
        function showError(message) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('errorContainer').innerHTML = `
                <div class="error-message">${message}</div>
            `;
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('addNPCDropdown');
            if (dropdown && !dropdown.contains(event.target)) {
                dropdown.classList.remove('active');
            }
        });

        // Initialize
        if (isToolsPopup) {
            document.body.classList.add('tools-popup');
        }

        currentUser = checkAuth();
        if (currentUser && campaignId) {
            loadCampaign();
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            stopPolling();
            disconnectQuestStream();
            stopDiceLogPolling();
        });
    </script>
</body>
</html>
